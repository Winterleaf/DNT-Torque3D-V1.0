// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN ? AS IS? BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (?DNT ?) and DotNetT orque
// Customizer (?DNTC?)is governed by this license agreement (? Agreement?).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNT or DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to DNT or DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment?s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.
// 
// Last updated: 10/18/2012
// 

#include "DotNetC.h"  
#include "torqueConfig.h"
#include <string>

static S32 sChaseQueueSize = 0;
static MatrixF* sChaseQueue = 0;
static S32 sChaseQueueHead = 0;
static S32 sChaseQueueTail = 0;


//~~~~~~~~~~~~~~~~~~~~//~~~~~~~~~~~~~~~~~~~~//
// Network Object Identification

//  These useful console methods come from the following code resource:
//
//  How to Identify Objects from Client to Server or Server to Client by Nathan Davies
//    http://www.garagegames.com/index.php?sec=mg&mod=resource&page=view&qid=4852
//

DefineEngineMethod(NetConnection, GetGhostIndex, S32, (NetObject* obj),,
                   "Returns the ghost-index for an object.\n\n"
                   "@ingroup AFX")
{
  if (obj)
    return object->getGhostIndex(obj);
  return 0;
}

DefineEngineMethod(NetConnection, ResolveGhost, S32, (int ghostIndex),,
                   "Resolves a ghost-index into an object ID.\n\n"
                   "@ingroup AFX")
{
  if (ghostIndex != -1)
  {
    NetObject* pObject = NULL;
    if( object->isGhostingTo())
      pObject = object->resolveGhost(ghostIndex);
    else if( object->isGhostingFrom())
      pObject = object->resolveObjectFromGhostIndex(ghostIndex);
    if (pObject)
      return pObject->getId();
  } 
  return 0;
}

static bool isInSet(char c, const char *set)
{
   if (set)
      while (*set)
         if (c == *set++)
            return true;

   return false;
}

static S32 buildFileList(const char* pattern, bool recurse, bool multiMatch)
{
	//Con::errorf("pattern is %s",pattern);

   static const String sSlash( "/" );

   sgFindFilesResults.clear();

   String sPattern(Torque::Path::CleanSeparators(pattern));
   //Con::errorf("spattern %s",sPattern.c_str());

    
   if(sPattern.isEmpty())
   {
      Con::errorf("findFirstFile() requires a search pattern");
      return -1;
   }

   if(!Con::expandScriptFilename(sgScriptFilenameBuffer, sizeof(sgScriptFilenameBuffer), sPattern.c_str()))
   {
      Con::errorf("findFirstFile() given initial directory cannot be expanded: '%s'", pattern);
      return -1;
   }
   sPattern = String::ToString(sgScriptFilenameBuffer);
   //Con::errorf("sPattern %s",sPattern.c_str());

   String::SizeType slashPos = sPattern.find('/', 0, String::Right);
//    if(slashPos == String::NPos)
//    {
//       Con::errorf("findFirstFile() missing search directory or expression: '%s'", sPattern.c_str());
//       return -1;
//    }

   // Build the initial search path
   Torque::Path givenPath(Torque::Path::CompressPath(sPattern));
   givenPath.setFileName("*");
   givenPath.setExtension("*");

   if(givenPath.getPath().length() > 0 && givenPath.getPath().find('*', 0, String::Right) == givenPath.getPath().length()-1)
   {
      // Deal with legacy searches of the form '*/*.*'
      String suspectPath = givenPath.getPath();
      String::SizeType newLen = suspectPath.length()-1;
      if(newLen > 0 && suspectPath.find('/', 0, String::Right) == suspectPath.length()-2)
      {
         --newLen;
      }
      givenPath.setPath(suspectPath.substr(0, newLen));
   }

   //Con::errorf("Given Path: %s",givenPath.getFullPath().c_str());

   Torque::FS::FileSystemRef fs = Torque::FS::GetFileSystem(givenPath);
   //Torque::Path path = fs->mapTo(givenPath);
   Torque::Path path = givenPath;
   
   // Make sure that we have a root so the correct file system can be determined when using zips
   if(givenPath.isRelative())
      path = Torque::Path::Join(Torque::FS::GetCwd(), '/', givenPath);

   //Con::errorf("full path %s",path.c_str());
   
   path.setFileName(String::EmptyString);
   path.setExtension(String::EmptyString);
   if(!Torque::FS::IsDirectory(path))
   {
      Con::errorf("findFirstFile() invalid initial search directory: '%s'", path.getFullPath().c_str());
      return -1;
   }

   // Build the search expression
   const String expression(slashPos != String::NPos ? sPattern.substr(slashPos+1) : sPattern);
   if(expression.isEmpty())
   {
      Con::errorf("findFirstFile() requires a search expression: '%s'", sPattern.c_str());
      return -1;
   }

   S32 results = Torque::FS::FindByPattern(path, expression, recurse, sgFindFilesResults, multiMatch );
   if(givenPath.isRelative() && results > 0)
   {
      // Strip the CWD out of the returned paths
      // MakeRelativePath() returns incorrect results (it adds a leading ..) so doing this the dirty way
      const String cwd = Torque::FS::GetCwd().getFullPath();
      for(S32 i = 0;i < sgFindFilesResults.size();++i)
      {
		  //Con::errorf("Entry->%s",sgFindFilesResults[i].c_str());
         String str = sgFindFilesResults[i];
         if(str.compare(cwd, cwd.length(), String::NoCase) == 0)
            str = str.substr(cwd.length());
         sgFindFilesResults[i] = str;
      }
   }
   return results;
}

   static StringTableEntry getDSOPath(const char *scriptPath)
{
#ifndef TORQUE2D_TOOLS_FIXME

   // [tom, 11/17/2006] Force old behavior for the player. May not want to do this.
   const char *slash = dStrrchr(scriptPath, '/');
   if(slash != NULL)
      return StringTable->insertn(scriptPath, slash - scriptPath, true);
   
   slash = dStrrchr(scriptPath, ':');
   if(slash != NULL)
      return StringTable->insertn(scriptPath, (slash - scriptPath) + 1, true);
   
   return "";

#else

   char relPath[1024], dsoPath[1024];
   bool isPrefs = false;

   // [tom, 11/17/2006] Prefs are handled slightly differently to avoid dso name clashes
   StringTableEntry prefsPath = Platform::getPrefsPath();
   if(dStrnicmp(scriptPath, prefsPath, dStrlen(prefsPath)) == 0)
   {
      relPath[0] = 0;
      isPrefs = true;
   }
   else
   {
      StringTableEntry strippedPath = Platform::stripBasePath(scriptPath);
      dStrcpy(relPath, strippedPath);

      char *slash = dStrrchr(relPath, '/');
      if(slash)
         *slash = 0;
   }

   const char *overridePath;
   if(! isPrefs)
      overridePath = Con::getVariable("$Scripts::OverrideDSOPath");
   else
      overridePath = prefsPath;

   if(overridePath && *overridePath)
      Platform::makeFullPathName(relPath, dsoPath, sizeof(dsoPath), overridePath);
   else
   {
      char t[1024];
      dSprintf(t, sizeof(t), "compiledScripts/%s", relPath);
      Platform::makeFullPathName(t, dsoPath, sizeof(dsoPath), Platform::getPrefsPath());
   }

   return StringTable->insert(dsoPath);

#endif
}


static CameraSpline::Knot::Type resolveKnotType(const char *arg)
{
   if (dStricmp(arg, "Position Only") == 0) 
      return CameraSpline::Knot::POSITION_ONLY;
   if (dStricmp(arg, "Kink") == 0) 
      return CameraSpline::Knot::KINK;
   return CameraSpline::Knot::NORMAL;
}

static CameraSpline::Knot::Path resolveKnotPath(const char *arg)
{
   if (!dStricmp(arg, "Linear"))
      return CameraSpline::Knot::LINEAR;
   return CameraSpline::Knot::SPLINE;
}

class RCE : public NetEvent
{
public:
   typedef NetEvent Parent;
   enum {MaxRemoteCommandArgs = 20,CommandArgsBits = 5};

private:
   S32 mArgc;
   char *mArgv[MaxRemoteCommandArgs + 1];
   NetStringHandle mTagv[MaxRemoteCommandArgs + 1];
   static char mBuf[1024];
public:
   RCE(S32 argc=0, const char **argv=NULL, NetConnection *conn = NULL)
   {
      mArgc = argc;
      for(S32 i = 0; i < argc; i++)
      {
         if(argv[i][0] == StringTagPrefixByte)
         {
            char buffer[256];
            mTagv[i+1] = NetStringHandle(dAtoi(argv[i]+1));
            if(conn)
            {
               dSprintf(buffer + 1, sizeof(buffer) - 1, "%d", conn->getNetSendId(mTagv[i+1]));
               buffer[0] = StringTagPrefixByte;
               mArgv[i+1] = dStrdup(buffer);
            }
         }
         else
            mArgv[i+1] = dStrdup(argv[i]);
      }
   }
   
   ~RCE()
   {
      for(S32 i = 0; i < mArgc; i++)
         dFree(mArgv[i+1]);
   }

   virtual void pack(NetConnection* conn, BitStream *bstream)
   {
      bstream->writeInt(mArgc, CommandArgsBits);
      // write it out reversed... why?
      // automatic string substitution with later arguments -
      // handled automatically by the system.

      for(S32 i = 0; i < mArgc; i++)
         conn->packString(bstream, mArgv[i+1]);
   }

   virtual void write(NetConnection* conn, BitStream *bstream)
   {
      pack(conn, bstream);
   }

   virtual void unpack(NetConnection* conn, BitStream *bstream)
   {

      mArgc = bstream->readInt(CommandArgsBits);
      // read it out backwards
      for(S32 i = 0; i < mArgc; i++)
      {
         conn->unpackString(bstream, mBuf);
         mArgv[i+1] = dStrdup(mBuf);
      }
   }

   virtual void process(NetConnection *conn)
   {
      static char idBuf[10];

      // de-tag the command name
	   for(S32 i = mArgc - 1; i >= 0; i--)
      {
		// Con::errorf("nClient--> Param %i '%s'",i, mArgv[i+1]);
         char *arg = mArgv[i+1];
         if(*arg == StringTagPrefixByte)
         {
            // it's a tag:
            U32 localTag = dAtoi(arg + 1);
            NetStringHandle tag = conn->translateRemoteStringId(localTag);
            NetStringTable::expandString( tag,
                                          mBuf,
                                          sizeof(mBuf),
                                          (mArgc - 1) - i,
                                          (const char**)(mArgv + i + 2) );
            dFree(mArgv[i+1]);
            mArgv[i+1] = dStrdup(mBuf);
			//Con::errorf("nClient--> Param %i detag '%s'",i,mBuf);
         }
      }
      const char *rmtCommandName = dStrchr(mArgv[1], ' ') + 1;
      if(conn->isConnectionToServer())
      {
		 
         dStrcpy(mBuf, "clientCmd");
         dStrcat(mBuf, rmtCommandName);

         char *temp = mArgv[1];
         mArgv[1] = mBuf;

	//	 Con::errorf("Client Command is firing!!! '%s' ",mBuf);

         Con::execute(mArgc, (const char **) mArgv+1);
         mArgv[1] = temp;
      }
      else
      {
		  //Con::errorf("Server Command is firing!!!");
         dStrcpy(mBuf, "serverCmd");
         dStrcat(mBuf, rmtCommandName);
         char *temp = mArgv[1];

         dSprintf(idBuf, sizeof(idBuf), "%d", conn->getId());
         mArgv[0] = mBuf;
         mArgv[1] = idBuf;

         Con::execute(mArgc+1, (const char **) mArgv);
         mArgv[1] = temp;
      }
   }

   DECLARE_CONOBJECT(RCE);
};
char RCE::mBuf[1024];
IMPLEMENT_CO_NETEVENT_V1(RCE);

static void dnc_sendRemoteCommand(NetConnection *conn, S32 argc, const char **argv)
{
    if(U8(argv[0][0]) != StringTagPrefixByte)
   {
      Con::errorf(ConsoleLogEntry::Script, "Remote Command Error - command must be a tag.");
      return;
   }
   S32 i;
   for(i = argc - 1; i >= 0; i--)
   {
      if(argv[i][0] != 0)
         break;
      argc = i;
   }
   for(i = 0; i < argc; i++)
		{
		//Con::errorf("Param %i = '%s'",i,argv[i]);
		conn->validateSendString(argv[i]);
		}
   
   RCE *cevt = new RCE(argc, argv, conn);
   conn->postNetEvent(cevt);
}



//const char * cs_Instance_Eval(const char *evalstring)
//	{
//	char buffer[8000];
//	buffer[0]=0;
//	Handler_Instance_Eval((char*)evalstring,buffer);
//	return Con::getReturnBuffer (buffer);
//	}
//const char * cs_Instance_Eval_Direct_New(S32 argc,const char ** argv)
//	{
//	char buffer[8000];
//	buffer[0]=0;
//	Handler_Instance_Eval_Direct_New(argc,argv,buffer);
//	return Con::getReturnBuffer (buffer);
//	}



const char * cs_Instance_Eval(const char *evalstring)
	{

	char * buffer = new char[8000];
	buffer[0]=0;
	Handler_Instance_Eval((char*)evalstring,buffer);
	const char * r = StringTable->insert( buffer ) ;
	delete[] buffer;

	return r;
	}
const char * cs_Instance_Eval_Direct_New(S32 argc,const char ** argv)
	{
	char * buffer =  new char[8000];
	buffer[0]=0;
	Handler_Instance_Eval_Direct_New(argc,argv,buffer);
	const char * r = StringTable->insert( buffer ) ;
	delete[] buffer;
	return r;
	}



extern "C" __declspec(dllexport) void __cdecl SetHandler_Instance_Eval(void* handler)
	{
	Handler_Instance_Eval = (Instance_Eval)handler;
	}
extern "C" __declspec(dllexport) void __cdecl SetHandler_Instance_Eval_Direct_New(void* handler)
	{
	Handler_Instance_Eval_Direct_New =(Instance_Eval_Direct_New) handler;
	}


DefineEngineFunction( dnEval, const char *, ( const char* script ),( "" ),"@brief Sends a string to DotNet\n\n" "@script csharp or vb.\n")
{
	return cs_Instance_Eval(script);
}
//Had to use a old style function because the new ones only support 11 parameters.
ConsoleFunction(dnEval_Direct_New, const char *, 2, 20, "()" "")
{
	return cs_Instance_Eval_Direct_New(argc,argv);
}

extern "C" __declspec(dllexport) U32 __cdecl clientGroup_getCount()
{
	SimGroup *clientGroup = Sim::getClientGroup();
	return (U32)clientGroup->sizeRecursive();
}
extern "C" __declspec(dllexport) U32 __cdecl clientGroup_getObject(U32 index)
	{
	SimGroup *pClientGroup = Sim::getClientGroup();

	int counter =0;
	SimGroup::iterator itr = pClientGroup->begin();
	for ( ; itr != pClientGroup->end(); itr++ )
		{
		if (counter==index)
			{
			GameConnection* gc = static_cast<GameConnection*>(*itr);
			if ( gc )
				return (U32)gc->getId();
			else
				return (U32)0;
			}
		counter++;
		}
	return (U32)0;
	}
extern "C" __declspec(dllexport) U32 __cdecl SceneObject_getTypeMask(char* sceneobject)
{
	SimObject* sb = Sim::findObject(sceneobject);
	SceneObject* object = dynamic_cast<SceneObject *>(sb);
	if (!object)
		return (U32)0;
	 return (U32)object->getTypeMask();
}
extern "C" __declspec(dllexport) void __cdecl SceneObject_initContainerRadiusSearch(F32 x,F32 y,F32 z, F32 radius,U32 mask,bool useClientContainer,U32 results[500],F32 distresults[500])
{
	SceneContainer* pContainer = useClientContainer ? &gClientContainer : &gServerContainer;
	Point3F pos = Point3F(x,y,z);
	pContainer->initRadiusSearch( pos, radius, mask );
	int i =0;
	while(SceneObject* t = pContainer->containerSearchNextObject())
		{
			if (i>500)
				return;
			results[i] = t->getId();
			distresults[i] = pContainer->containerSearchCurrRadiusDist();
			i++;
		}
}
extern "C" __declspec(dllexport) F32 __cdecl calcExplosionCoverage(F32 x,F32 y,F32 z,U32 id,U32 covMask)
{
	Point3F pos = Point3F(x,y,z);
	Point3F center;

   SceneObject* sceneObject = NULL;
   if (Sim::findObject(id, sceneObject) == false) {
      Con::warnf(ConsoleLogEntry::General, "calcExplosionCoverage: couldn't find object: %s", id);
      return 1.0f;
   }
   if (sceneObject->isClientObject() || sceneObject->getContainer() == NULL) {
      Con::warnf(ConsoleLogEntry::General, "calcExplosionCoverage: object is on the client, or not in the container system");
      return 1.0f;
   }

   sceneObject->getObjBox().getCenter(&center);
   center.convolve(sceneObject->getScale());
   sceneObject->getTransform().mulP(center);

   RayInfo rayInfo;
   sceneObject->disableCollision();
   if (sceneObject->getContainer()->castRay(pos, center, covMask, &rayInfo) == true) {
      // Try casting up and then out
      if (sceneObject->getContainer()->castRay(pos, pos + Point3F(0.0f, 0.0f, 1.0f), covMask, &rayInfo) == false)
      {
         if (sceneObject->getContainer()->castRay(pos + Point3F(0.0f, 0.0f, 1.0f), center, covMask, &rayInfo) == false)
         {
            sceneObject->enableCollision();
            return 1.0f;
         }
      }

      sceneObject->enableCollision();
      return 0.0f;
   } else {
      sceneObject->enableCollision();
      return 1.0f;
   }

}
extern "C" __declspec(dllexport) bool __cdecl doDismount(char * playerDataBlock)
{
	SimObject* sb = Sim::findObject(playerDataBlock);
	Player* object = dynamic_cast<Player *>(sb);
	if (!object)
		return false;
	PlayerData *pd = dynamic_cast<PlayerData *>(object->getDataBlock());
	if (!pd)
		return false;
	pd->doDismount_callback( object );
	

	return true;
}
extern "C" __declspec(dllexport) bool __cdecl SimObject_isField(char * simobject,char * fieldname)
	{
	SimObject* object = Sim::findObject(simobject);
	if (!object)
		return false;
	return object->isField( fieldname );
	}

extern "C" __declspec(dllexport) bool __cdecl NameSpace_isMethod(const char * _sns,const char* _method)
{
	Namespace* ns = Namespace::find(StringTable->insert( _sns ) );
	Namespace::Entry* nse = ns->lookup(StringTable->insert( _method) );
    if( !nse )
       return false;
	return true;
   }

extern "C" __declspec(dllexport) bool __cdecl NameSpace_isInNamespaceHierarchy(char* shapebase, char* name)
{
	SimObject* object = Sim::findObject(shapebase);
	if (!object)
		return false;
	Namespace* nspace = object->getNamespace();
	while( nspace && dStricmp( nspace->mName, name ) != 0 )
		nspace = nspace->mParent;
	return ( nspace != NULL );
}
extern "C" __declspec(dllexport) S32 Console_getSimTime()
	{
	return (S32)Sim::getCurrentTime();
	}
extern "C" __declspec(dllexport) bool __cdecl isObject(char * simobj_id)
	{
	return  (Sim::findObject(simobj_id) != NULL);
	}
extern "C" __declspec(dllexport) void __cdecl Console_printf(char * message)
	{
	Con::printf("%s",message);
	}
extern "C" __declspec(dllexport) void __cdecl Console_warnf(char * message)
	{
	Con::warnf("%s",message);
	}
extern "C" __declspec(dllexport) void __cdecl Console_errorf(char * message)
	{
	Con::errorf("%s",message);
	}
extern "C" __declspec(dllexport) void __cdecl ConsoleCall(char * cmd,char * result,bool echo)
	{
	const char* r = Con::evaluate( cmd,echo);
	if (r) 
		dSprintf(result,4096,"%s",r); 
	else
		dSprintf(result,4096,"%s",""); 
	}


extern "C" __declspec(dllexport) void __cdecl cs_torque_getvariable(char* name,char* result)
	{
	dSprintf(result,4096,"%s",Con::getVariable(StringTable->insert(name)));
	}
extern "C" __declspec(dllexport) void __cdecl cs_torque_setvariable(char* name, char* value)
	{
	Con::setVariable(StringTable->insert(name), StringTable->insert(value));
	}

extern "C" __declspec(dllexport) void __cdecl wle_script_simobject_getfield_string(U32 id, char* _fieldName,char * retval)
   {
   dSprintf(retval,4096,"");
   const char* fieldName =NULL;
   fieldName = StringTable->insert(_fieldName);
   SimObject *object = Sim::findObject( id );
   if( object )
      dSprintf(retval,4096,"%s", object->getDataField(fieldName, ""));

   }

extern "C" __declspec(dllexport) void __cdecl wle_script_simobject_setfield_string(U32 objectId, char* _fieldName, char* v)
   {
   const char* fieldName =NULL;
   fieldName = StringTable->insert(_fieldName);
   SimObject *object = Sim::findObject( objectId );
   if( object )
      {
         object->setDataField(fieldName, "",(const char*) v);
      }
   }





extern "C" __declspec(dllexport) void __cdecl deleteVariables(char * pattern) 
	{
	Con::removeVariable(pattern);
	}
extern "C" __declspec(dllexport) bool __cdecl objectHasMethod(char* name,char* method)
	{
	SimObject* _obj = Sim::findObject(name);
	return	(_obj->isMethod(method));
	}
extern "C" __declspec(dllexport) U32 __cdecl GetObjectID(char * simobj_id)
{
	SimObject* s = Sim::findObject(simobj_id);
	if (!s)
		return 0;
	return s->getId();
}
extern "C" __declspec(dllexport) bool __cdecl isFile(char * sfileName)
	{
	char sgScriptFilenameBuffer[1024];
	String cleanfilename(Torque::Path::CleanSeparators(sfileName));
	Con::expandScriptFilename(sgScriptFilenameBuffer, sizeof(sgScriptFilenameBuffer), cleanfilename.c_str());
	Torque::Path givenPath(Torque::Path::CompressPath(sgScriptFilenameBuffer));
	return Torque::FS::IsFile(givenPath);
}
extern "C" __declspec(dllexport) S32 __cdecl getFileCRC(char * sfileName)
{
	char sgScriptFilenameBuffer[1024];
	String cleanfilename(Torque::Path::CleanSeparators(sfileName));
	Con::expandScriptFilename(sgScriptFilenameBuffer, sizeof(sgScriptFilenameBuffer), cleanfilename.c_str());
	Torque::Path givenPath(Torque::Path::CompressPath(sgScriptFilenameBuffer));
	Torque::FS::FileNodeRef fileRef = Torque::FS::GetFileNode( givenPath );
	if ( fileRef == NULL )
		{
		Con::errorf("getFileCRC() - could not access file: [%s]", givenPath.getFullPath().c_str() );
		return (S32)-1;
		}
	return (S32)fileRef->getChecksum();
	}
extern "C" __declspec(dllexport) void __cdecl pathOnMissionLoadDone()
{
   // Need to load subobjects for all loaded interiors...
   SimGroup* pMissionGroup = dynamic_cast<SimGroup*>(Sim::findObject("MissionGroup"));
   AssertFatal(pMissionGroup != NULL, "Error, mission done loading and no mission group?");

   U32 currStart = 0;
   U32 currEnd   = 1;
   Vector<SimGroup*> groups;
   groups.push_back(pMissionGroup);

   while (true) {
      for (U32 i = currStart; i < currEnd; i++) {
         for (SimGroup::iterator itr = groups[i]->begin(); itr != groups[i]->end(); itr++) {
            if (dynamic_cast<SimGroup*>(*itr) != NULL)
               groups.push_back(static_cast<SimGroup*>(*itr));
         }
      }

      if (groups.size() == currEnd) {
         break;
      } else {
         currStart = currEnd;
         currEnd   = groups.size();
      }
   }

   for (U32 i = 0; i < groups.size(); i++) {
      SimPath::Path* pPath = dynamic_cast<SimPath::Path*>(groups[i]);
      if (pPath)
         pPath->updatePath();
   }
}
extern "C" __declspec(dllexport) void __cdecl clearServerPaths()
	{
	gServerPathManager->clearPaths();
	}
extern "C" __declspec(dllexport) void __cdecl getAddress(char * client,char * _buffer)
	{
	SimObject* _conn_obj = Sim::findObject(client);
	NetConnection* object = dynamic_cast<NetConnection *>(_conn_obj);
	if (object)
		{
		if(object->isLocalConnection())
			{
			dSprintf(_buffer,256,"%s","local");
			return;
			}
		Net::addressToString(object->getNetAddress(), _buffer);
		}
	else
		dSprintf(_buffer,256,"%s","");
	return;
	}
extern "C" __declspec(dllexport) void __cdecl physicsStartSimulation(char * variable)
	{
    if ( PHYSICSMGR )
		PHYSICSMGR->enableSimulation((const char*)variable, true );
	}
extern "C" __declspec(dllexport) void __cdecl physicsStopSimulation(char * variable)
	{
	if ( PHYSICSMGR )
		PHYSICSMGR->enableSimulation( (const char*)variable, false );
	}
extern "C" __declspec(dllexport) U32 __cdecl getDataBlock(char * simobject)
	{
	SimObject* _simobject = Sim::findObject(simobject);
	GameBase* gb = dynamic_cast<GameBase *>(_simobject);
	if (gb)
		{
		return (U32)(gb->getDataBlock()? gb->getDataBlock()->getId(): 0);
		}
	return (U32)0;
	}
extern "C" __declspec(dllexport) bool __cdecl isFunction(char * functionname)
	{
    return Con::isFunction((const char*)functionname);  
    }
extern "C" __declspec(dllexport) U32 __cdecl spawnObject(char * _spawnClass, char * _spawnDataBlock, char * _spawnName, char * _spawnProperties, char* _spawnScript)
	{
	SimObject* spawnObject = Sim::spawnObject((const char*)_spawnClass, (const char*)_spawnDataBlock, (const char*)_spawnName, (const char*)_spawnProperties, (const char*)_spawnScript);
	if (spawnObject)
		return (U32)spawnObject->getId();
	else
		return (U32)-1;
	}
extern "C" __declspec(dllexport) bool __cdecl isMemberOfClass (char * className, char* superClassName)
{
	AbstractClassRep *pRep = AbstractClassRep::findClassRep( className );
   while (pRep)
   {
      if( !dStricmp( pRep->getClassName(), superClassName ) )
         return true;
      pRep = pRep->getParentClass();
   }
   return false;
}
extern "C" __declspec(dllexport) void __cdecl getTaggedString (char * tag,char* ret)
{
	const char *indexPtr = tag;
   if (*indexPtr == StringTagPrefixByte)
      indexPtr++;
   
   dSprintf(ret,4096,gNetStringTable->lookupString(dAtoi(indexPtr)));
}
extern "C" __declspec(dllexport) void __cdecl addTaggedString (char * inString,char * ret)
{
	NetStringHandle s(inString);
	gNetStringTable->incStringRefScript(s.getIndex());
	ret[0] = StringTagPrefixByte;
	dSprintf(ret + 1, 9, "%d", s.getIndex());
}
extern "C" __declspec(dllexport) S32 __cdecl nameToID (char * name)
	{
	SimObject *obj = Sim::findObject(name);
	if(obj)
		return (S32)obj->getId();
	else
		return (S32)-1;
	}
extern "C" __declspec(dllexport) U32 __cdecl getParent (char* simobject)
	{
	SimObject *parent;
	if(Sim::findObject(simobject, parent))
		{
		return (U32)parent->getId();
		}
	return (U32)0;
	}
extern "C" __declspec(dllexport) void __cdecl getName (U32 simobject,char * ret)
{
	SimObject* _simobject = Sim::findObject(simobject);
	if (!_simobject)
		{
		dSprintf(ret,1024, "%s","");
		return;
		}
	
	const char *ret1 = _simobject->getName();
	//Con::errorf("-----------> Get Name '%s' ",ret1);
	if (ret1)
		dSprintf(ret,1024, "%s",ret1);
	else
		dSprintf(ret,1024, "%s","");
}
extern "C" __declspec(dllexport) void __cdecl getClassName (char* simobject,char * ret)
	{
	SimObject* _simobject = Sim::findObject(simobject);
	if (!_simobject)
		return;
	const char *ret1 = _simobject->getClassName();
	if (ret1)
		dSprintf(ret,4096, "%s",ret1);
	else
		dSprintf(ret,4096, "%s","");
}
extern "C" __declspec(dllexport) void __cdecl containerRayCast(F64 start_x,F64 start_y,F64 start_z,F64 end_x,F64 end_y,F64 end_z,U32 mask,U32 exempt,bool useClientContainer,char* result)
	{
	Point3F start =  Point3F(start_x,start_y,start_z);
	Point3F end =  Point3F(end_x,end_y,end_z);
	SceneObject *pExempt;
	if (exempt!=0)
		pExempt = dynamic_cast<SceneObject*>(Sim::findObject(exempt));
	else
		pExempt = NULL;

	if (pExempt)
      pExempt->enableCollision();

	 SceneContainer* pContainer = useClientContainer ? &gClientContainer : &gServerContainer;

	RayInfo rinfo;
	S32 ret = 0;
	if (pContainer->castRay(start, end, mask, &rinfo) == true)
		ret = rinfo.object->getId();
	if (pExempt)
		pExempt->enableCollision();
   // add the hit position and normal?
   if(ret)
		{
		dSprintf(result, 256, "%d %g %g %g %g %g %g",
               ret, rinfo.point.x, rinfo.point.y, rinfo.point.z,
               rinfo.normal.x, rinfo.normal.y, rinfo.normal.z);
		}
   else
	   dSprintf(result, 256,"");
  
	}
extern "C" __declspec(dllexport) S32 __cdecl ContainerRadiusSearch(F32 x,F32 y,F32 z,F32 searchRadius, U32 searchMask, bool useClientContainer,U32 foundobjectIds[100])
	{
	Point3F searchPoint =  Point3F(x, y, z);
	Point3F mSearchReferencePoint =  Point3F(x, y, z);
	Vector<SimObjectPtr<SceneObject>*>  mSearchList;
	SceneContainer* pContainer = useClientContainer ? &gClientContainer : &gServerContainer;
	Box3F queryBox(searchPoint, searchPoint);
	queryBox.minExtents -= Point3F(searchRadius, searchRadius, searchRadius);
	queryBox.maxExtents += Point3F(searchRadius, searchRadius, searchRadius);
	SimpleQueryList queryList;
	pContainer->findObjects(queryBox, searchMask, SimpleQueryList::insertionCallback, &queryList);
	F32 radiusSquared = searchRadius * searchRadius;
	const F32* pPoint = &searchPoint.x;
	for (U32 i = 0; i < queryList.mList.size(); i++)
		{
		const F32* bMins;
		const F32* bMaxs;
		bMins = &queryList.mList[i]->getWorldBox().minExtents.x;
		bMaxs = &queryList.mList[i]->getWorldBox().maxExtents.x;
		F32 sum = 0;
		for (U32 j = 0; j < 3; j++)
			{
			if (pPoint[j] < bMins[j])
				sum += (pPoint[j] - bMins[j])*(pPoint[j] - bMins[j]);
			else if (pPoint[j] > bMaxs[j])
				sum += (pPoint[j] - bMaxs[j])*(pPoint[j] - bMaxs[j]);
			}
		if (sum < radiusSquared || queryList.mList[i]->isGlobalBounds())
			{
			mSearchList.push_back(new SimObjectPtr<SceneObject>);
			*(mSearchList.last()) = queryList.mList[i];
			}
		}
	
	S32 countofrecords = 0;

	if (mSearchList.size() != 0)
		{
		countofrecords =mSearchList.size();
		for (int i = 0;i<mSearchList.size();i++)
			{
			if (i<100)
				foundobjectIds[i] = mSearchList[i]->getObject()->getId();
			else
				i = mSearchList.size()+1;
			}
		}
	return (S32)countofrecords;
	}
/*Console*/

/*Math*/
extern "C" __declspec(dllexport) void __cdecl Math_MatrixMulVector(F32 x,F32 y,F32 z,F32 ang,F32 ax,F32 ay,F32 az,F32 XX,F32 YY,F32 ZZ,char* retval)
{
	TransformF txfm;
	Point3F p3f;
	p3f.x = x;
	p3f.y = y;
	p3f.z = z;

	//Point3D
	Point3F aap3f;
	aap3f.x = ax;
	aap3f.y = ay;
	aap3f.z = az;
	AngAxisF aaf;
	aaf.axis = aap3f;
	aaf.angle =ang;
	txfm.mPosition = p3f;
	txfm.mOrientation = aaf;
	VectorF vector = VectorF(XX,YY,ZZ);
	MatrixF m = txfm.getMatrix();
	Box3F f ;
	//f.
	//TransformF h = TransformF(m);
	
	m.mulV( vector );
	
	dSprintf(retval,1024, "%f %f %f ",vector.x,vector.y,vector.z);

	//Con::errorf(" %f %f %f ",vector.x,vector.y,vector.z);
	//RXX = vector.x;
	//RYY = vector.y;
	//RZZ = vector.z;
}
extern "C" __declspec(dllexport) void __cdecl Math_MatrixCreateFromEuler(F32 x,F32 y,F32 z,char* ret)
	{
	Point3F angles = Point3F(x,y,z);
	QuatF rotQ( angles );
	AngAxisF aa;
	aa.set(rotQ);

	TransformF tret = TransformF( Point3F::Zero, aa );
	dSprintf(ret,1024,"%f %f %f %f %f %f %f ",tret.getPosition().x,tret.getPosition().y,tret.getPosition().z,tret.getOrientation().axis.x,tret.getOrientation().axis.y,tret.getOrientation().axis.z,tret.getOrientation().angle);
	}
extern "C" __declspec(dllexport) void __cdecl getEulerRotation (char* simobject, F32 x,F32 y, F32 z)
{
	SimObject* _simobject = Sim::findObject(simobject);
	if (!_simobject)
		return;
	ShapeBase* sb =  dynamic_cast<ShapeBase *>(_simobject);
	if (!sb)
		return;

	Point3F euler = sb->getTransform().toEuler();
   
   // Convert to degrees.
   x = mRadToDeg( euler.x );
   y = mRadToDeg( euler.y );
   z = mRadToDeg( euler.z );
}
/*Math*/

/*Net*/
extern "C" __declspec(dllexport) void __cdecl commandToServer(S32 argc,char ** _argv)
{
	std::vector<const char*> arguments;
	for (int i =0;i<argc;i++)
		{
		arguments.push_back(_argv[i]);
		}
   const char** argv = &arguments[0];

   
   NetConnection *conn = NetConnection::getConnectionToServer();
   if(!conn)
      return;
   dnc_sendRemoteCommand(conn, argc - 1, argv + 1);
   arguments.clear();
}
extern "C" __declspec(dllexport) void __cdecl commandToClient(S32 argc,char ** _argv)
{
	std::vector<const char*> arguments;
	for (int i =0;i<argc;i++)
		arguments.push_back(_argv[i]);
    const char** argv = &arguments[0];
	NetConnection *conn;
    if(!Sim::findObject(argv[1], conn))
		{
		Con::errorf("Unable to find connection %s" ,argv[1] );
		for (int i =0;i<argc;i++)
			Con::errorf("%s",_argv[i]);
		return;
		}
	dnc_sendRemoteCommand(conn, argc - 2, argv + 2);
	arguments.clear();
}
/*Net*/

/*SimObject*/
extern "C" __declspec(dllexport) void __cdecl removeTaggedString(char* tag)
{
   gNetStringTable->removeString(dAtoi(tag), true);
}
extern "C" __declspec(dllexport) void __cdecl SimObject_Call(char* simobject, S32 argc,char ** _argv,char* ret)
	{
	dSprintf(ret,4096, "");
	SimObject* object = Sim::findObject(simobject);
	if (!object)
		{
			Con::errorf("------------------------------------>WARNING Cannot Find object '%s'.%s.",simobject,_argv[0]);
		return;
		}
	std::vector<const char*> arguments;
	for (int i =0;i<argc;i++)
		arguments.push_back(_argv[i]);
    const char** argv = &arguments[0];
	const char* r = Con::execute( object, argc, argv  );
	if (r)
		dSprintf(ret,4096, "%s",r);
	arguments.clear();
	}
extern "C" __declspec(dllexport) void __cdecl execute (S32 argc,char ** _argv,char* ret)
{
	dSprintf(ret,4096, "");
	std::vector<const char*> arguments;
	for (int i =0;i<argc;i++)
		arguments.push_back(_argv[i]);
    const char** argv = &arguments[0];
	const char* r = Con::execute(argc,argv);
	if (r)
		dSprintf(ret,4096, "%s",r);
	arguments.clear();
}
extern "C" __declspec(dllexport) void __cdecl Classname_Call(char* className,char* function, S32 argc,char ** _argv,char* ret,bool debug)
	{
	dSprintf(ret,1024,"%s","");
	StringTableEntry nameSpace = StringTable->insert(className);
	StringTableEntry name =  StringTable->insert(function);

	Namespace* ns = NULL;

	if (!nameSpace || !dStrlen(nameSpace))
		ns = Namespace::mGlobalNamespace;
	else
		{
		nameSpace = StringTable->insert(nameSpace);
		ns = Namespace::find(nameSpace); //can specify a package here, maybe need, maybe not
		}

	if (!ns)
		{
		Con::errorf("ERROR: Unable call function (%s) because Namespace (%s) not found.",name,nameSpace);
		return ;
		}
    name = StringTable->insert(name);

	Namespace::Entry* entry = ns->lookupRecursive(name);

	if (!entry)
		{
		Con::errorf("ERROR: Unable to call function (%s::%s), cannot find entry for function.",nameSpace,name);
		return;
		}

	std::vector<const char*> arguments;
	for (int i =0;i<argc;i++)
		{
		if (debug)
			Con::errorf("Adding '%s' to vector",_argv[i]);
		arguments.push_back(_argv[i]);
		}

	const char** argv = &arguments[0];
	if (debug)
		Con::errorf("Calling function %s::%s",nameSpace,name);
	const char* resultstring = entry->execute( argc,argv, &gEvalState);
	if (resultstring)
		if (dStrlen(resultstring)>0)
			dSprintf(ret,1024,"%s",resultstring);

	arguments.clear();
	
	}
extern "C" __declspec(dllexport) void __cdecl ParentCall(char* sim_object,char* function,S32 namespacedepth,char* ret,S32 argc,char ** _argv,bool debug)
{
	dSprintf(ret,1024,"%s","");
	SimObject* object = Sim::findObject(sim_object);
	if (!object)
		{
		Con::errorf("Cannot find simobject");
		return;
		}
	Namespace* 	ns = object->getNamespace();
	for (int i = 0;i<=namespacedepth;i++)
		{
		ns = ns->getParent();
		if (!ns)
			{
			Con::errorf("OOOPS... NAMESPACE NOT FOUND");
			return;
			}
		if (debug)
			Con::errorf("Digging NameSpace for object (%s), Found NameSpace (%s) at a depth of (%i) on way to destination (%i)",sim_object,ns->getName(),  i,namespacedepth-1);
		}
	if (!ns)
		{
		Con::errorf("WARNING!!!! --->Cannot Find Namespace");
		return;
		}

	std::vector<const char*> arguments;
	for (int i =0;i<argc;i++)
		{
		if (debug)
		Con::errorf("Adding '%s' to vector",_argv[i]);
		arguments.push_back(_argv[i]);
		}

	const char** argv = &arguments[0];
	StringTableEntry callMethod = StringTable->insert( function );
	Namespace::Entry* funct = ns->lookup(callMethod);
	if (!funct)
		{
		Con::errorf("Cannot find parent");
		return;
		}
	const char* resultstring = funct->execute( argc,argv, &gEvalState);

	if (dStrlen(resultstring)>0)
		dSprintf(ret,1024,"%s",resultstring);
	arguments.clear();
}

extern "C" __declspec(dllexport) void __cdecl ParentCallFunct(char* function,S32 namespacedepth,char* ret,S32 argc,char ** _argv,bool debug)
{
	dSprintf(ret,1024,"%s","");
	StringTableEntry callMethod = StringTable->insert( function );
	if (!Con::isFunction(callMethod))
		{
		Con::errorf("Function Does not exist!");
		return;
		}
	else
		if (debug)
			Con::errorf("------>Found Function!!!");
	Namespace* 	ns =Namespace::global()->lookup(callMethod)->mNamespace ;
	if (!ns)
		{
		Con::errorf("Namespace not working");
		return;
		}
	for (int i = 0;i<=namespacedepth;i++)
		{
		ns = ns->getParent();
		if (!ns)
			{
			Con::errorf("OOOPS... NAMESPACE NOT FOUND");
			return;
			}
		if (debug)
			Con::errorf("Digging NameSpace for object (%s), Found NameSpace (%s) at a depth of (%i) on way to destination (%i)",function,ns->getName(),  i,namespacedepth-1);
		}
	if (debug)
		Con::errorf("Current NameSpace is %s",ns->mName);

	std::vector<const char*> arguments;
	for (int i =0;i<argc;i++)
		{
		if (debug)
			Con::errorf("Adding '%s' to vector",_argv[i]);
		arguments.push_back(_argv[i]);
		}
	const char** argv = &arguments[0];
	Namespace::Entry* funct = ns->lookup(callMethod);
	if (!funct)
		{
		Con::errorf("Cannot find parent Function!!!!!!!!!!!");
		return;
		}
	//Con::errorf("Calling Function");
	const char* resultstring = funct->execute( argc,argv, &gEvalState);
	if (resultstring)
		if (dStrlen(resultstring)>0)
			dSprintf(ret,1024,"%s",resultstring);
	arguments.clear();

}

//Con::executef("onDataBlockObjectReceived",  Con::getIntArg(i),Con::getIntArg(iCount));





extern "C" __declspec(dllexport) S32  __cdecl wle_fn_addBadWord(char * x__badWord)
{
const char* badWord = (const char*)x__badWord;
bool wle_returnObject;
{
	{wle_returnObject =gBadWordFilter->addBadWord(badWord);
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_filterString(char * x__baseString, char * x__replacementChars,  char* retval)
{
dSprintf(retval,4096,"");
const char* baseString = (const char*)x__baseString;
const char* replacementChars = (const char*)x__replacementChars;
const char * wle_returnObject;
{
	const char *replaceStr = NULL;
	if(replacementChars)
		replaceStr = replacementChars;
	else
		replaceStr = gBadWordFilter->getDefaultReplaceStr();
	char *ret = Con::getReturnBuffer(dStrlen(baseString) + 1);
	dStrcpy(ret, baseString);
	gBadWordFilter->filterString(ret, replaceStr);
	{wle_returnObject =ret;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_containsBadWords(char * x__text)
{
const char* text = (const char*)x__text;
bool wle_returnObject;
{
	{wle_returnObject =gBadWordFilter->containsBadWords(text);
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__strToPlayerName(char * x__a1,  char* retval)
{
dSprintf(retval,4096,"");
const char* a1 = (const char*)x__a1;
const char* wle_returnObject;
{
S32 argc = 2;
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
const char** argv = &arguments[0];
{
   
   const char* ptr = argv[1];
	// Strip leading spaces and underscores:
   while ( *ptr == ' ' || *ptr == '_' )
      ptr++;
   U32 len = dStrlen( ptr );
   if ( len )
   {
      char* ret = Con::getReturnBuffer( MaxPlayerNameLength + 1 );
      char* rptr = ret;
      ret[MaxPlayerNameLength - 1] = '\0';
      ret[MaxPlayerNameLength] = '\0';
      bool space = false;
      U8 ch;
      while ( *ptr && dStrlen( ret ) < MaxPlayerNameLength )
      {
         ch = (U8) *ptr;
         // Strip all illegal characters:
         if ( ch < 32 || ch == ',' || ch == '.' || ch == '\'' || ch == '`' )
         {
            ptr++;
            continue;
         }
         // Don't allow double spaces or space-underline combinations:
         if ( ch == ' ' || ch == '_' )
         {
            if ( space )
            {
               ptr++;
               continue;
            }
            else
               space = true;
         }
         else
            space = false;
         *rptr++ = *ptr;
         ptr++;
      }
      *rptr = '\0';
		//finally, strip out the ML text control chars...
		{wle_returnObject =GuiMLTextCtrl::stripControlChars(ret);
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   }
	{wle_returnObject =( "" );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__lockMouse(char * x__a1)
{
const char* a1 = (const char*)x__a1;
{
S32 argc = 2;
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
const char** argv = &arguments[0];
{
   Platform::setWindowLocked(dAtob(argv[1]));
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn__setNetPort(char * x__a1, char * x__a2)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
bool wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   bool bind = true;
   if (argc == 3)
      bind = dAtob(argv[2]);
   {wle_returnObject =Net::openPort(dAtoi(argv[1]), bind);
return (S32)(wle_returnObject);}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn__getVersionNumber()
{
{
{
  return (S32)( getVersionNumber());
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__getVersionString(char* retval)
{
dSprintf(retval,4096,"");
const char* wle_returnObject;
{
{
   {wle_returnObject =getVersionString();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__getEngineName(char* retval)
{
dSprintf(retval,4096,"");
const char* wle_returnObject;
{
{
   {wle_returnObject =getEngineProductString();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__getBuildString(char* retval)
{
dSprintf(retval,4096,"");
const char* wle_returnObject;
{
{
#ifdef TORQUE_DEBUG
   {wle_returnObject ="Debug";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
#else
   {wle_returnObject ="Release";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
#endif
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnHTTPObject_get(char * x__object, char * x__Address, char * x__requirstURI, char * x__query)
{
HTTPObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* Address = (const char*)x__Address;
const char* requirstURI = (const char*)x__requirstURI;
const char* query = (const char*)x__query;
{
   if( !query || !query[ 0 ] )
		object->get(Address, requirstURI, NULL);
   else
		object->get(Address, requirstURI, query);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnHTTPObject_post(char * x__object, char * x__Address, char * x__requirstURI, char * x__query, char * x__post)
{
HTTPObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* Address = (const char*)x__Address;
const char* requirstURI = (const char*)x__requirstURI;
const char* query = (const char*)x__query;
const char* post = (const char*)x__post;
{
   object->post(Address, requirstURI, query, post);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__removeTaggedString(char * x__a1)
{
const char* a1 = (const char*)x__a1;
{
S32 argc = 2;
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
const char** argv = &arguments[0];
{
   gNetStringTable->removeString(dAtoi(argv[1]+1), true);
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__addTaggedString(char * x__a1,  char* retval)
{
dSprintf(retval,4096,"");
const char* a1 = (const char*)x__a1;
const char* wle_returnObject;
{
S32 argc = 2;
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
const char** argv = &arguments[0];
{
   NetStringHandle s(argv[1]);
   gNetStringTable->incStringRefScript(s.getIndex());
   char *ret = Con::getReturnBuffer(10);
   ret[0] = StringTagPrefixByte;
   dSprintf(ret + 1, 9, "%d", s.getIndex());
   {wle_returnObject =ret;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__buildTaggedString(char * x__a1, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10,  char* retval)
{
dSprintf(retval,4096,"");
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* wle_returnObject;
{
S32 argc = 11;
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
if (argc>=5)
arguments.push_back(a4);
if (argc>=6)
arguments.push_back(a5);
if (argc>=7)
arguments.push_back(a6);
if (argc>=8)
arguments.push_back(a7);
if (argc>=9)
arguments.push_back(a8);
if (argc>=10)
arguments.push_back(a9);
if (argc>=11)
arguments.push_back(a10);
const char** argv = &arguments[0];
{
   const char *indexPtr = argv[1];
   if (*indexPtr == StringTagPrefixByte)
      indexPtr++;
   const char *fmtString = gNetStringTable->lookupString(dAtoi(indexPtr));
   char *strBuffer = Con::getReturnBuffer(512);
   const char *fmtStrPtr = fmtString;
   char *strBufPtr = strBuffer;
   S32 strMaxLength = 511;
   if (!fmtString)
      goto done;
   //build the string
   while (*fmtStrPtr)
   {
      //look for an argument tag
      if (*fmtStrPtr == '%')
      {
         if (fmtStrPtr[1] >= '1' && fmtStrPtr[1] <= '9')
         {
            S32 argIndex = S32(fmtStrPtr[1] - '0') + 1;
            if (argIndex >= argc)
               goto done;
            const char *argStr = argv[argIndex];
            if (!argStr)
               goto done;
            S32 strLength = dStrlen(argStr);
            if (strLength > strMaxLength)
               goto done;
            dStrcpy(strBufPtr, argStr);
            strBufPtr += strLength;
            strMaxLength -= strLength;
            fmtStrPtr += 2;
            continue;
         }
      }
      //if we don't continue, just copy the character
      if (strMaxLength <= 0)
         goto done;
      *strBufPtr++ = *fmtStrPtr++;
      strMaxLength--;
   }
done:
   *strBufPtr = '\0';
   {wle_returnObject =strBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__queryAllServers(char * x__a1, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10, char * x__a11)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* a11 = (const char*)x__a11;
{
S32 argc = 12;
if (dStrlen(a11)==0)
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
else
argc=12;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
if (argc>=5)
arguments.push_back(a4);
if (argc>=6)
arguments.push_back(a5);
if (argc>=7)
arguments.push_back(a6);
if (argc>=8)
arguments.push_back(a7);
if (argc>=9)
arguments.push_back(a8);
if (argc>=10)
arguments.push_back(a9);
if (argc>=11)
arguments.push_back(a10);
if (argc>=12)
arguments.push_back(a11);
const char** argv = &arguments[0];
{
   
   U32 lanPort = dAtoi(argv[1]);
   U8 flags = dAtoi(argv[2]);
   // It's not a good idea to hold onto args, recursive calls to
   // console exec will trash them.
   char* gameType = dStrdup(argv[3]);
   char* missionType = dStrdup(argv[4]);
   U8 minPlayers = dAtoi(argv[5]);
   U8 maxPlayers = dAtoi(argv[6]);
   U8 maxBots = dAtoi(argv[7]);
   U32 regionMask = dAtoi(argv[8]);
   U32 maxPing = dAtoi(argv[9]);
   U16 minCPU = dAtoi(argv[10]);
   U8 filterFlags = dAtoi(argv[11]);
   U32 buddyList = 0;
   clearServerList();
   queryMasterServer(flags,gameType,missionType,minPlayers,maxPlayers,
      maxBots,regionMask,maxPing,minCPU,filterFlags,0,&buddyList);
   queryLanServers(lanPort, flags, gameType, missionType, minPlayers, maxPlayers, maxBots,
	   regionMask, maxPing, minCPU, filterFlags);
   dFree(gameType);
   dFree(missionType);
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__queryLanServers(char * x__a1, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10, char * x__a11)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* a11 = (const char*)x__a11;
{
S32 argc = 12;
if (dStrlen(a11)==0)
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
else
argc=12;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
if (argc>=5)
arguments.push_back(a4);
if (argc>=6)
arguments.push_back(a5);
if (argc>=7)
arguments.push_back(a6);
if (argc>=8)
arguments.push_back(a7);
if (argc>=9)
arguments.push_back(a8);
if (argc>=10)
arguments.push_back(a9);
if (argc>=11)
arguments.push_back(a10);
if (argc>=12)
arguments.push_back(a11);
const char** argv = &arguments[0];
{
   
   U32 lanPort = dAtoi(argv[1]);
   U8 flags = dAtoi(argv[2]);
   // It's not a good idea to hold onto args, recursive calls to
   // console exec will trash them.
   char* gameType = dStrdup(argv[3]);
   char* missionType = dStrdup(argv[4]);
   U8 minPlayers = dAtoi(argv[5]);
   U8 maxPlayers = dAtoi(argv[6]);
   U8 maxBots = dAtoi(argv[7]);
   U32 regionMask = dAtoi(argv[8]);
   U32 maxPing = dAtoi(argv[9]);
   U16 minCPU = dAtoi(argv[10]);
   U8 filterFlags = dAtoi(argv[11]);
   clearServerList();
   queryLanServers(lanPort, flags, gameType, missionType, minPlayers, maxPlayers, maxBots,
	   regionMask, maxPing, minCPU, filterFlags);
   dFree(gameType);
   dFree(missionType);
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__queryMasterServer(char * x__a1, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
{
S32 argc = 11;
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
if (argc>=5)
arguments.push_back(a4);
if (argc>=6)
arguments.push_back(a5);
if (argc>=7)
arguments.push_back(a6);
if (argc>=8)
arguments.push_back(a7);
if (argc>=9)
arguments.push_back(a8);
if (argc>=10)
arguments.push_back(a9);
if (argc>=11)
arguments.push_back(a10);
const char** argv = &arguments[0];
{
   
   U8 flags = dAtoi(argv[1]);
   // It's not a good idea to hold onto args, recursive calls to
   // console exec will trash them.
   char* gameType = dStrdup(argv[2]);
   char* missionType = dStrdup(argv[3]);
   U8 minPlayers = dAtoi(argv[4]);
   U8 maxPlayers = dAtoi(argv[5]);
   U8 maxBots = dAtoi(argv[6]);
   U32 regionMask = dAtoi(argv[7]);
   U32 maxPing = dAtoi(argv[8]);
   U16 minCPU = dAtoi(argv[9]);
   U8 filterFlags = dAtoi(argv[10]);
   U32 buddyList = 0;
   clearServerList();
   queryMasterServer(flags,gameType,missionType,minPlayers,maxPlayers,
      maxBots,regionMask,maxPing,minCPU,filterFlags,0,&buddyList);
   dFree(gameType);
   dFree(missionType);
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__querySingleServer(char * x__a1, char * x__a2)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   
   NetAddress addr;
   char* addrText;
   addrText = dStrdup(argv[1]);
   U8 flags = dAtoi(argv[2]);
   Net::stringToAddress( addrText, &addr );
   querySingleServer(&addr,flags);
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn__setServerInfo(char * x__a1)
{
const char* a1 = (const char*)x__a1;
bool wle_returnObject;
{
S32 argc = 2;
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
const char** argv = &arguments[0];
{
   
   U32 index = dAtoi(argv[1]);
   if (index >= 0 && index < gServerList.size()) {
      ServerInfo& info = gServerList[index];
      char addrString[256];
      Net::addressToString( &info.address, addrString );
      Con::setIntVariable("ServerInfo::Status",info.status);
      Con::setVariable("ServerInfo::Address",addrString);
      Con::setVariable("ServerInfo::Name",info.name);
      Con::setVariable("ServerInfo::GameType",info.gameType);
      Con::setVariable("ServerInfo::MissionName",info.missionName);
      Con::setVariable("ServerInfo::MissionType",info.missionType);
      Con::setVariable("ServerInfo::State",info.statusString);
      Con::setVariable("ServerInfo::Info",info.infoString);
      Con::setIntVariable("ServerInfo::PlayerCount",info.numPlayers);
      Con::setIntVariable("ServerInfo::MaxPlayers",info.maxPlayers);
      Con::setIntVariable("ServerInfo::BotCount",info.numBots);
      Con::setIntVariable("ServerInfo::Version",info.version);
      Con::setIntVariable("ServerInfo::Ping",info.ping);
      Con::setIntVariable("ServerInfo::CPUSpeed",info.cpuSpeed);
      Con::setBoolVariable("ServerInfo::Favorite",info.isFavorite);
      Con::setBoolVariable("ServerInfo::Dedicated",info.isDedicated());
      Con::setBoolVariable("ServerInfo::Password",info.isPassworded());
      {wle_returnObject =true;
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnTCPObject_send(char * x__object, char * x__data)
{
TCPObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* data = (const char*)x__data;
{
   object->send( (const U8*)data, dStrlen(data) );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnTCPObject_listen(char * x__object, int port)
{
TCPObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->listen(U32(port));
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnTCPObject_connect(char * x__object, char * x__address)
{
TCPObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* address = (const char*)x__address;
{
   object->connect(address);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnTCPObject_disconnect(char * x__object)
{
TCPObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->disconnect();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__testJavaScriptBridge(char * x__a1, char * x__a2, char * x__a3,  char* retval)
{
dSprintf(retval,4096,"");
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char * wle_returnObject;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
	S32 failed = 0;
	if(argc != 4)
		failed = 1;
	else
	{
		if (dStrcmp(argv[1],"one"))
			failed = 2;
		if (dStrcmp(argv[2],"two"))
			failed = 2;
		if (dStrcmp(argv[3],"three"))
			failed = 2;
	}
	//attempt to call from TorqueScript -> JavaScript
	const char* jret = Con::evaluate("JS::bridgeCallback(\"one\",\"two\",\"three\");");
	if (dStrcmp(jret,"42"))
		failed = 3;
	char *ret = Con::getReturnBuffer(256);
	dSprintf(ret, 256, "%i", failed);
	{wle_returnObject =ret;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__TestFunction2Args(char * x__a1, char * x__a2,  char* retval)
{
dSprintf(retval,4096,"");
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char * wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
{
   {wle_returnObject =" Value";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnDynamicConsoleMethodComponent_callMethod(char * x__object, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10, char * x__a11, char * x__a12, char * x__a13, char * x__a14, char * x__a15, char * x__a16, char * x__a17, char * x__a18, char * x__a19, char * x__a20, char * x__a21, char * x__a22, char * x__a23, char * x__a24, char * x__a25, char * x__a26, char * x__a27, char * x__a28, char * x__a29, char * x__a30, char * x__a31, char * x__a32, char * x__a33, char * x__a34, char * x__a35, char * x__a36, char * x__a37, char * x__a38, char * x__a39, char * x__a40, char * x__a41, char * x__a42, char * x__a43, char * x__a44, char * x__a45, char * x__a46, char * x__a47, char * x__a48, char * x__a49, char * x__a50, char * x__a51, char * x__a52, char * x__a53, char * x__a54, char * x__a55, char * x__a56, char * x__a57, char * x__a58, char * x__a59, char * x__a60, char * x__a61, char * x__a62, char * x__a63)
{
DynamicConsoleMethodComponent* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* a11 = (const char*)x__a11;
const char* a12 = (const char*)x__a12;
const char* a13 = (const char*)x__a13;
const char* a14 = (const char*)x__a14;
const char* a15 = (const char*)x__a15;
const char* a16 = (const char*)x__a16;
const char* a17 = (const char*)x__a17;
const char* a18 = (const char*)x__a18;
const char* a19 = (const char*)x__a19;
const char* a20 = (const char*)x__a20;
const char* a21 = (const char*)x__a21;
const char* a22 = (const char*)x__a22;
const char* a23 = (const char*)x__a23;
const char* a24 = (const char*)x__a24;
const char* a25 = (const char*)x__a25;
const char* a26 = (const char*)x__a26;
const char* a27 = (const char*)x__a27;
const char* a28 = (const char*)x__a28;
const char* a29 = (const char*)x__a29;
const char* a30 = (const char*)x__a30;
const char* a31 = (const char*)x__a31;
const char* a32 = (const char*)x__a32;
const char* a33 = (const char*)x__a33;
const char* a34 = (const char*)x__a34;
const char* a35 = (const char*)x__a35;
const char* a36 = (const char*)x__a36;
const char* a37 = (const char*)x__a37;
const char* a38 = (const char*)x__a38;
const char* a39 = (const char*)x__a39;
const char* a40 = (const char*)x__a40;
const char* a41 = (const char*)x__a41;
const char* a42 = (const char*)x__a42;
const char* a43 = (const char*)x__a43;
const char* a44 = (const char*)x__a44;
const char* a45 = (const char*)x__a45;
const char* a46 = (const char*)x__a46;
const char* a47 = (const char*)x__a47;
const char* a48 = (const char*)x__a48;
const char* a49 = (const char*)x__a49;
const char* a50 = (const char*)x__a50;
const char* a51 = (const char*)x__a51;
const char* a52 = (const char*)x__a52;
const char* a53 = (const char*)x__a53;
const char* a54 = (const char*)x__a54;
const char* a55 = (const char*)x__a55;
const char* a56 = (const char*)x__a56;
const char* a57 = (const char*)x__a57;
const char* a58 = (const char*)x__a58;
const char* a59 = (const char*)x__a59;
const char* a60 = (const char*)x__a60;
const char* a61 = (const char*)x__a61;
const char* a62 = (const char*)x__a62;
const char* a63 = (const char*)x__a63;
{
S32 argc = 64;
if (dStrlen(a63)==0)
if (dStrlen(a62)==0)
if (dStrlen(a61)==0)
if (dStrlen(a60)==0)
if (dStrlen(a59)==0)
if (dStrlen(a58)==0)
if (dStrlen(a57)==0)
if (dStrlen(a56)==0)
if (dStrlen(a55)==0)
if (dStrlen(a54)==0)
if (dStrlen(a53)==0)
if (dStrlen(a52)==0)
if (dStrlen(a51)==0)
if (dStrlen(a50)==0)
if (dStrlen(a49)==0)
if (dStrlen(a48)==0)
if (dStrlen(a47)==0)
if (dStrlen(a46)==0)
if (dStrlen(a45)==0)
if (dStrlen(a44)==0)
if (dStrlen(a43)==0)
if (dStrlen(a42)==0)
if (dStrlen(a41)==0)
if (dStrlen(a40)==0)
if (dStrlen(a39)==0)
if (dStrlen(a38)==0)
if (dStrlen(a37)==0)
if (dStrlen(a36)==0)
if (dStrlen(a35)==0)
if (dStrlen(a34)==0)
if (dStrlen(a33)==0)
if (dStrlen(a32)==0)
if (dStrlen(a31)==0)
if (dStrlen(a30)==0)
if (dStrlen(a29)==0)
if (dStrlen(a28)==0)
if (dStrlen(a27)==0)
if (dStrlen(a26)==0)
if (dStrlen(a25)==0)
if (dStrlen(a24)==0)
if (dStrlen(a23)==0)
if (dStrlen(a22)==0)
if (dStrlen(a21)==0)
if (dStrlen(a20)==0)
if (dStrlen(a19)==0)
if (dStrlen(a18)==0)
if (dStrlen(a17)==0)
if (dStrlen(a16)==0)
if (dStrlen(a15)==0)
if (dStrlen(a14)==0)
if (dStrlen(a13)==0)
if (dStrlen(a12)==0)
if (dStrlen(a11)==0)
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
else
argc=12;
else
argc=13;
else
argc=14;
else
argc=15;
else
argc=16;
else
argc=17;
else
argc=18;
else
argc=19;
else
argc=20;
else
argc=21;
else
argc=22;
else
argc=23;
else
argc=24;
else
argc=25;
else
argc=26;
else
argc=27;
else
argc=28;
else
argc=29;
else
argc=30;
else
argc=31;
else
argc=32;
else
argc=33;
else
argc=34;
else
argc=35;
else
argc=36;
else
argc=37;
else
argc=38;
else
argc=39;
else
argc=40;
else
argc=41;
else
argc=42;
else
argc=43;
else
argc=44;
else
argc=45;
else
argc=46;
else
argc=47;
else
argc=48;
else
argc=49;
else
argc=50;
else
argc=51;
else
argc=52;
else
argc=53;
else
argc=54;
else
argc=55;
else
argc=56;
else
argc=57;
else
argc=58;
else
argc=59;
else
argc=60;
else
argc=61;
else
argc=62;
else
argc=63;
else
argc=64;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
if (argc>5)
arguments.push_back(a5);
if (argc>6)
arguments.push_back(a6);
if (argc>7)
arguments.push_back(a7);
if (argc>8)
arguments.push_back(a8);
if (argc>9)
arguments.push_back(a9);
if (argc>10)
arguments.push_back(a10);
if (argc>11)
arguments.push_back(a11);
if (argc>12)
arguments.push_back(a12);
if (argc>13)
arguments.push_back(a13);
if (argc>14)
arguments.push_back(a14);
if (argc>15)
arguments.push_back(a15);
if (argc>16)
arguments.push_back(a16);
if (argc>17)
arguments.push_back(a17);
if (argc>18)
arguments.push_back(a18);
if (argc>19)
arguments.push_back(a19);
if (argc>20)
arguments.push_back(a20);
if (argc>21)
arguments.push_back(a21);
if (argc>22)
arguments.push_back(a22);
if (argc>23)
arguments.push_back(a23);
if (argc>24)
arguments.push_back(a24);
if (argc>25)
arguments.push_back(a25);
if (argc>26)
arguments.push_back(a26);
if (argc>27)
arguments.push_back(a27);
if (argc>28)
arguments.push_back(a28);
if (argc>29)
arguments.push_back(a29);
if (argc>30)
arguments.push_back(a30);
if (argc>31)
arguments.push_back(a31);
if (argc>32)
arguments.push_back(a32);
if (argc>33)
arguments.push_back(a33);
if (argc>34)
arguments.push_back(a34);
if (argc>35)
arguments.push_back(a35);
if (argc>36)
arguments.push_back(a36);
if (argc>37)
arguments.push_back(a37);
if (argc>38)
arguments.push_back(a38);
if (argc>39)
arguments.push_back(a39);
if (argc>40)
arguments.push_back(a40);
if (argc>41)
arguments.push_back(a41);
if (argc>42)
arguments.push_back(a42);
if (argc>43)
arguments.push_back(a43);
if (argc>44)
arguments.push_back(a44);
if (argc>45)
arguments.push_back(a45);
if (argc>46)
arguments.push_back(a46);
if (argc>47)
arguments.push_back(a47);
if (argc>48)
arguments.push_back(a48);
if (argc>49)
arguments.push_back(a49);
if (argc>50)
arguments.push_back(a50);
if (argc>51)
arguments.push_back(a51);
if (argc>52)
arguments.push_back(a52);
if (argc>53)
arguments.push_back(a53);
if (argc>54)
arguments.push_back(a54);
if (argc>55)
arguments.push_back(a55);
if (argc>56)
arguments.push_back(a56);
if (argc>57)
arguments.push_back(a57);
if (argc>58)
arguments.push_back(a58);
if (argc>59)
arguments.push_back(a59);
if (argc>60)
arguments.push_back(a60);
if (argc>61)
arguments.push_back(a61);
if (argc>62)
arguments.push_back(a62);
if (argc>63)
arguments.push_back(a63);
const char** argv = &arguments[0];
{
   object->callMethodArgList( argc - 1, argv + 2 );
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimComponent_addComponents(char * x__object, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10, char * x__a11, char * x__a12, char * x__a13, char * x__a14, char * x__a15, char * x__a16, char * x__a17, char * x__a18, char * x__a19, char * x__a20, char * x__a21, char * x__a22, char * x__a23, char * x__a24, char * x__a25, char * x__a26, char * x__a27, char * x__a28, char * x__a29, char * x__a30, char * x__a31, char * x__a32, char * x__a33, char * x__a34, char * x__a35, char * x__a36, char * x__a37, char * x__a38, char * x__a39, char * x__a40, char * x__a41, char * x__a42, char * x__a43, char * x__a44, char * x__a45, char * x__a46, char * x__a47, char * x__a48, char * x__a49, char * x__a50, char * x__a51, char * x__a52, char * x__a53, char * x__a54, char * x__a55, char * x__a56, char * x__a57, char * x__a58, char * x__a59, char * x__a60, char * x__a61, char * x__a62, char * x__a63)
{
SimComponent* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* a11 = (const char*)x__a11;
const char* a12 = (const char*)x__a12;
const char* a13 = (const char*)x__a13;
const char* a14 = (const char*)x__a14;
const char* a15 = (const char*)x__a15;
const char* a16 = (const char*)x__a16;
const char* a17 = (const char*)x__a17;
const char* a18 = (const char*)x__a18;
const char* a19 = (const char*)x__a19;
const char* a20 = (const char*)x__a20;
const char* a21 = (const char*)x__a21;
const char* a22 = (const char*)x__a22;
const char* a23 = (const char*)x__a23;
const char* a24 = (const char*)x__a24;
const char* a25 = (const char*)x__a25;
const char* a26 = (const char*)x__a26;
const char* a27 = (const char*)x__a27;
const char* a28 = (const char*)x__a28;
const char* a29 = (const char*)x__a29;
const char* a30 = (const char*)x__a30;
const char* a31 = (const char*)x__a31;
const char* a32 = (const char*)x__a32;
const char* a33 = (const char*)x__a33;
const char* a34 = (const char*)x__a34;
const char* a35 = (const char*)x__a35;
const char* a36 = (const char*)x__a36;
const char* a37 = (const char*)x__a37;
const char* a38 = (const char*)x__a38;
const char* a39 = (const char*)x__a39;
const char* a40 = (const char*)x__a40;
const char* a41 = (const char*)x__a41;
const char* a42 = (const char*)x__a42;
const char* a43 = (const char*)x__a43;
const char* a44 = (const char*)x__a44;
const char* a45 = (const char*)x__a45;
const char* a46 = (const char*)x__a46;
const char* a47 = (const char*)x__a47;
const char* a48 = (const char*)x__a48;
const char* a49 = (const char*)x__a49;
const char* a50 = (const char*)x__a50;
const char* a51 = (const char*)x__a51;
const char* a52 = (const char*)x__a52;
const char* a53 = (const char*)x__a53;
const char* a54 = (const char*)x__a54;
const char* a55 = (const char*)x__a55;
const char* a56 = (const char*)x__a56;
const char* a57 = (const char*)x__a57;
const char* a58 = (const char*)x__a58;
const char* a59 = (const char*)x__a59;
const char* a60 = (const char*)x__a60;
const char* a61 = (const char*)x__a61;
const char* a62 = (const char*)x__a62;
const char* a63 = (const char*)x__a63;
bool wle_returnObject;
{
S32 argc = 64;
if (dStrlen(a63)==0)
if (dStrlen(a62)==0)
if (dStrlen(a61)==0)
if (dStrlen(a60)==0)
if (dStrlen(a59)==0)
if (dStrlen(a58)==0)
if (dStrlen(a57)==0)
if (dStrlen(a56)==0)
if (dStrlen(a55)==0)
if (dStrlen(a54)==0)
if (dStrlen(a53)==0)
if (dStrlen(a52)==0)
if (dStrlen(a51)==0)
if (dStrlen(a50)==0)
if (dStrlen(a49)==0)
if (dStrlen(a48)==0)
if (dStrlen(a47)==0)
if (dStrlen(a46)==0)
if (dStrlen(a45)==0)
if (dStrlen(a44)==0)
if (dStrlen(a43)==0)
if (dStrlen(a42)==0)
if (dStrlen(a41)==0)
if (dStrlen(a40)==0)
if (dStrlen(a39)==0)
if (dStrlen(a38)==0)
if (dStrlen(a37)==0)
if (dStrlen(a36)==0)
if (dStrlen(a35)==0)
if (dStrlen(a34)==0)
if (dStrlen(a33)==0)
if (dStrlen(a32)==0)
if (dStrlen(a31)==0)
if (dStrlen(a30)==0)
if (dStrlen(a29)==0)
if (dStrlen(a28)==0)
if (dStrlen(a27)==0)
if (dStrlen(a26)==0)
if (dStrlen(a25)==0)
if (dStrlen(a24)==0)
if (dStrlen(a23)==0)
if (dStrlen(a22)==0)
if (dStrlen(a21)==0)
if (dStrlen(a20)==0)
if (dStrlen(a19)==0)
if (dStrlen(a18)==0)
if (dStrlen(a17)==0)
if (dStrlen(a16)==0)
if (dStrlen(a15)==0)
if (dStrlen(a14)==0)
if (dStrlen(a13)==0)
if (dStrlen(a12)==0)
if (dStrlen(a11)==0)
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
else
argc=12;
else
argc=13;
else
argc=14;
else
argc=15;
else
argc=16;
else
argc=17;
else
argc=18;
else
argc=19;
else
argc=20;
else
argc=21;
else
argc=22;
else
argc=23;
else
argc=24;
else
argc=25;
else
argc=26;
else
argc=27;
else
argc=28;
else
argc=29;
else
argc=30;
else
argc=31;
else
argc=32;
else
argc=33;
else
argc=34;
else
argc=35;
else
argc=36;
else
argc=37;
else
argc=38;
else
argc=39;
else
argc=40;
else
argc=41;
else
argc=42;
else
argc=43;
else
argc=44;
else
argc=45;
else
argc=46;
else
argc=47;
else
argc=48;
else
argc=49;
else
argc=50;
else
argc=51;
else
argc=52;
else
argc=53;
else
argc=54;
else
argc=55;
else
argc=56;
else
argc=57;
else
argc=58;
else
argc=59;
else
argc=60;
else
argc=61;
else
argc=62;
else
argc=63;
else
argc=64;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
if (argc>5)
arguments.push_back(a5);
if (argc>6)
arguments.push_back(a6);
if (argc>7)
arguments.push_back(a7);
if (argc>8)
arguments.push_back(a8);
if (argc>9)
arguments.push_back(a9);
if (argc>10)
arguments.push_back(a10);
if (argc>11)
arguments.push_back(a11);
if (argc>12)
arguments.push_back(a12);
if (argc>13)
arguments.push_back(a13);
if (argc>14)
arguments.push_back(a14);
if (argc>15)
arguments.push_back(a15);
if (argc>16)
arguments.push_back(a16);
if (argc>17)
arguments.push_back(a17);
if (argc>18)
arguments.push_back(a18);
if (argc>19)
arguments.push_back(a19);
if (argc>20)
arguments.push_back(a20);
if (argc>21)
arguments.push_back(a21);
if (argc>22)
arguments.push_back(a22);
if (argc>23)
arguments.push_back(a23);
if (argc>24)
arguments.push_back(a24);
if (argc>25)
arguments.push_back(a25);
if (argc>26)
arguments.push_back(a26);
if (argc>27)
arguments.push_back(a27);
if (argc>28)
arguments.push_back(a28);
if (argc>29)
arguments.push_back(a29);
if (argc>30)
arguments.push_back(a30);
if (argc>31)
arguments.push_back(a31);
if (argc>32)
arguments.push_back(a32);
if (argc>33)
arguments.push_back(a33);
if (argc>34)
arguments.push_back(a34);
if (argc>35)
arguments.push_back(a35);
if (argc>36)
arguments.push_back(a36);
if (argc>37)
arguments.push_back(a37);
if (argc>38)
arguments.push_back(a38);
if (argc>39)
arguments.push_back(a39);
if (argc>40)
arguments.push_back(a40);
if (argc>41)
arguments.push_back(a41);
if (argc>42)
arguments.push_back(a42);
if (argc>43)
arguments.push_back(a43);
if (argc>44)
arguments.push_back(a44);
if (argc>45)
arguments.push_back(a45);
if (argc>46)
arguments.push_back(a46);
if (argc>47)
arguments.push_back(a47);
if (argc>48)
arguments.push_back(a48);
if (argc>49)
arguments.push_back(a49);
if (argc>50)
arguments.push_back(a50);
if (argc>51)
arguments.push_back(a51);
if (argc>52)
arguments.push_back(a52);
if (argc>53)
arguments.push_back(a53);
if (argc>54)
arguments.push_back(a54);
if (argc>55)
arguments.push_back(a55);
if (argc>56)
arguments.push_back(a56);
if (argc>57)
arguments.push_back(a57);
if (argc>58)
arguments.push_back(a58);
if (argc>59)
arguments.push_back(a59);
if (argc>60)
arguments.push_back(a60);
if (argc>61)
arguments.push_back(a61);
if (argc>62)
arguments.push_back(a62);
if (argc>63)
arguments.push_back(a63);
const char** argv = &arguments[0];
{
   for(S32 i = 2; i < argc; i++)
   {
      SimComponent *obj = dynamic_cast<SimComponent*> (Sim::findObject(argv[i]) );
      if(obj)
         object->addComponent(obj);
      else
         Con::printf("SimComponent::addComponents - Invalid Component Object \"%s\"", argv[i]);
   }
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimComponent_removeComponents(char * x__object, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10, char * x__a11, char * x__a12, char * x__a13, char * x__a14, char * x__a15, char * x__a16, char * x__a17, char * x__a18, char * x__a19, char * x__a20, char * x__a21, char * x__a22, char * x__a23, char * x__a24, char * x__a25, char * x__a26, char * x__a27, char * x__a28, char * x__a29, char * x__a30, char * x__a31, char * x__a32, char * x__a33, char * x__a34, char * x__a35, char * x__a36, char * x__a37, char * x__a38, char * x__a39, char * x__a40, char * x__a41, char * x__a42, char * x__a43, char * x__a44, char * x__a45, char * x__a46, char * x__a47, char * x__a48, char * x__a49, char * x__a50, char * x__a51, char * x__a52, char * x__a53, char * x__a54, char * x__a55, char * x__a56, char * x__a57, char * x__a58, char * x__a59, char * x__a60, char * x__a61, char * x__a62, char * x__a63)
{
SimComponent* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* a11 = (const char*)x__a11;
const char* a12 = (const char*)x__a12;
const char* a13 = (const char*)x__a13;
const char* a14 = (const char*)x__a14;
const char* a15 = (const char*)x__a15;
const char* a16 = (const char*)x__a16;
const char* a17 = (const char*)x__a17;
const char* a18 = (const char*)x__a18;
const char* a19 = (const char*)x__a19;
const char* a20 = (const char*)x__a20;
const char* a21 = (const char*)x__a21;
const char* a22 = (const char*)x__a22;
const char* a23 = (const char*)x__a23;
const char* a24 = (const char*)x__a24;
const char* a25 = (const char*)x__a25;
const char* a26 = (const char*)x__a26;
const char* a27 = (const char*)x__a27;
const char* a28 = (const char*)x__a28;
const char* a29 = (const char*)x__a29;
const char* a30 = (const char*)x__a30;
const char* a31 = (const char*)x__a31;
const char* a32 = (const char*)x__a32;
const char* a33 = (const char*)x__a33;
const char* a34 = (const char*)x__a34;
const char* a35 = (const char*)x__a35;
const char* a36 = (const char*)x__a36;
const char* a37 = (const char*)x__a37;
const char* a38 = (const char*)x__a38;
const char* a39 = (const char*)x__a39;
const char* a40 = (const char*)x__a40;
const char* a41 = (const char*)x__a41;
const char* a42 = (const char*)x__a42;
const char* a43 = (const char*)x__a43;
const char* a44 = (const char*)x__a44;
const char* a45 = (const char*)x__a45;
const char* a46 = (const char*)x__a46;
const char* a47 = (const char*)x__a47;
const char* a48 = (const char*)x__a48;
const char* a49 = (const char*)x__a49;
const char* a50 = (const char*)x__a50;
const char* a51 = (const char*)x__a51;
const char* a52 = (const char*)x__a52;
const char* a53 = (const char*)x__a53;
const char* a54 = (const char*)x__a54;
const char* a55 = (const char*)x__a55;
const char* a56 = (const char*)x__a56;
const char* a57 = (const char*)x__a57;
const char* a58 = (const char*)x__a58;
const char* a59 = (const char*)x__a59;
const char* a60 = (const char*)x__a60;
const char* a61 = (const char*)x__a61;
const char* a62 = (const char*)x__a62;
const char* a63 = (const char*)x__a63;
bool wle_returnObject;
{
S32 argc = 64;
if (dStrlen(a63)==0)
if (dStrlen(a62)==0)
if (dStrlen(a61)==0)
if (dStrlen(a60)==0)
if (dStrlen(a59)==0)
if (dStrlen(a58)==0)
if (dStrlen(a57)==0)
if (dStrlen(a56)==0)
if (dStrlen(a55)==0)
if (dStrlen(a54)==0)
if (dStrlen(a53)==0)
if (dStrlen(a52)==0)
if (dStrlen(a51)==0)
if (dStrlen(a50)==0)
if (dStrlen(a49)==0)
if (dStrlen(a48)==0)
if (dStrlen(a47)==0)
if (dStrlen(a46)==0)
if (dStrlen(a45)==0)
if (dStrlen(a44)==0)
if (dStrlen(a43)==0)
if (dStrlen(a42)==0)
if (dStrlen(a41)==0)
if (dStrlen(a40)==0)
if (dStrlen(a39)==0)
if (dStrlen(a38)==0)
if (dStrlen(a37)==0)
if (dStrlen(a36)==0)
if (dStrlen(a35)==0)
if (dStrlen(a34)==0)
if (dStrlen(a33)==0)
if (dStrlen(a32)==0)
if (dStrlen(a31)==0)
if (dStrlen(a30)==0)
if (dStrlen(a29)==0)
if (dStrlen(a28)==0)
if (dStrlen(a27)==0)
if (dStrlen(a26)==0)
if (dStrlen(a25)==0)
if (dStrlen(a24)==0)
if (dStrlen(a23)==0)
if (dStrlen(a22)==0)
if (dStrlen(a21)==0)
if (dStrlen(a20)==0)
if (dStrlen(a19)==0)
if (dStrlen(a18)==0)
if (dStrlen(a17)==0)
if (dStrlen(a16)==0)
if (dStrlen(a15)==0)
if (dStrlen(a14)==0)
if (dStrlen(a13)==0)
if (dStrlen(a12)==0)
if (dStrlen(a11)==0)
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
else
argc=12;
else
argc=13;
else
argc=14;
else
argc=15;
else
argc=16;
else
argc=17;
else
argc=18;
else
argc=19;
else
argc=20;
else
argc=21;
else
argc=22;
else
argc=23;
else
argc=24;
else
argc=25;
else
argc=26;
else
argc=27;
else
argc=28;
else
argc=29;
else
argc=30;
else
argc=31;
else
argc=32;
else
argc=33;
else
argc=34;
else
argc=35;
else
argc=36;
else
argc=37;
else
argc=38;
else
argc=39;
else
argc=40;
else
argc=41;
else
argc=42;
else
argc=43;
else
argc=44;
else
argc=45;
else
argc=46;
else
argc=47;
else
argc=48;
else
argc=49;
else
argc=50;
else
argc=51;
else
argc=52;
else
argc=53;
else
argc=54;
else
argc=55;
else
argc=56;
else
argc=57;
else
argc=58;
else
argc=59;
else
argc=60;
else
argc=61;
else
argc=62;
else
argc=63;
else
argc=64;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
if (argc>5)
arguments.push_back(a5);
if (argc>6)
arguments.push_back(a6);
if (argc>7)
arguments.push_back(a7);
if (argc>8)
arguments.push_back(a8);
if (argc>9)
arguments.push_back(a9);
if (argc>10)
arguments.push_back(a10);
if (argc>11)
arguments.push_back(a11);
if (argc>12)
arguments.push_back(a12);
if (argc>13)
arguments.push_back(a13);
if (argc>14)
arguments.push_back(a14);
if (argc>15)
arguments.push_back(a15);
if (argc>16)
arguments.push_back(a16);
if (argc>17)
arguments.push_back(a17);
if (argc>18)
arguments.push_back(a18);
if (argc>19)
arguments.push_back(a19);
if (argc>20)
arguments.push_back(a20);
if (argc>21)
arguments.push_back(a21);
if (argc>22)
arguments.push_back(a22);
if (argc>23)
arguments.push_back(a23);
if (argc>24)
arguments.push_back(a24);
if (argc>25)
arguments.push_back(a25);
if (argc>26)
arguments.push_back(a26);
if (argc>27)
arguments.push_back(a27);
if (argc>28)
arguments.push_back(a28);
if (argc>29)
arguments.push_back(a29);
if (argc>30)
arguments.push_back(a30);
if (argc>31)
arguments.push_back(a31);
if (argc>32)
arguments.push_back(a32);
if (argc>33)
arguments.push_back(a33);
if (argc>34)
arguments.push_back(a34);
if (argc>35)
arguments.push_back(a35);
if (argc>36)
arguments.push_back(a36);
if (argc>37)
arguments.push_back(a37);
if (argc>38)
arguments.push_back(a38);
if (argc>39)
arguments.push_back(a39);
if (argc>40)
arguments.push_back(a40);
if (argc>41)
arguments.push_back(a41);
if (argc>42)
arguments.push_back(a42);
if (argc>43)
arguments.push_back(a43);
if (argc>44)
arguments.push_back(a44);
if (argc>45)
arguments.push_back(a45);
if (argc>46)
arguments.push_back(a46);
if (argc>47)
arguments.push_back(a47);
if (argc>48)
arguments.push_back(a48);
if (argc>49)
arguments.push_back(a49);
if (argc>50)
arguments.push_back(a50);
if (argc>51)
arguments.push_back(a51);
if (argc>52)
arguments.push_back(a52);
if (argc>53)
arguments.push_back(a53);
if (argc>54)
arguments.push_back(a54);
if (argc>55)
arguments.push_back(a55);
if (argc>56)
arguments.push_back(a56);
if (argc>57)
arguments.push_back(a57);
if (argc>58)
arguments.push_back(a58);
if (argc>59)
arguments.push_back(a59);
if (argc>60)
arguments.push_back(a60);
if (argc>61)
arguments.push_back(a61);
if (argc>62)
arguments.push_back(a62);
if (argc>63)
arguments.push_back(a63);
const char** argv = &arguments[0];
{
   for(S32 i = 2; i < argc; i++)
   {
      SimComponent *obj = dynamic_cast<SimComponent*> (Sim::findObject(argv[i]) );
      if(obj)
         object->removeComponent(obj);
      else
         Con::printf("SimComponent::removeComponents - Invalid Component Object \"%s\"", argv[i]);
   }
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimComponent_getComponentCount(char * x__object)
{
SimComponent* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
  return (S32)( object->getComponentCount());
}
}
;
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimComponent_getComponent(char * x__object, char * x__a2)
{
SimComponent* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   S32 idx = dAtoi(argv[2]);
   if(idx < 0 || idx >= object->getComponentCount())
   {
      Con::errorf("SimComponent::getComponent - Invalid index %d", idx);
     return (S32)( 0);
   }
   SimComponent *c = object->getComponent(idx);
  return (S32)( c ? c->getId() : 0);
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimComponent_setEnabled(char * x__object, char * x__a2)
{
SimComponent* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->setEnabled(dAtob(argv[2]));
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimComponent_isEnabled(char * x__object)
{
SimComponent* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
{
   {wle_returnObject =object->isEnabled();
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimComponent_setIsTemplate(char * x__object, char * x__a2)
{
SimComponent* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->setIsTemplate(dAtob(argv[2]));
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimComponent_getIsTemplate(char * x__object)
{
SimComponent* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
{
   {wle_returnObject =object->getIsTemplate();
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnArrayObject_getIndexFromValue(char * x__object, char * x__value)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* value = (const char*)x__value;
{
  return (S32)( object->getIndexFromValue( value ));
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnArrayObject_getIndexFromKey(char * x__object, char * x__key)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* key = (const char*)x__key;
{
  return (S32)( object->getIndexFromKey( key ));
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_getValue(char * x__object, S32 index,  char* retval)
{
dSprintf(retval,4096,"");
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->getValueFromIndex( index ).c_str();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_getKey(char * x__object, S32 index,  char* retval)
{
dSprintf(retval,4096,"");
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->getKeyFromIndex( index ).c_str();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_setKey(char * x__object, char * x__key, S32 index)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* key = (const char*)x__key;

{
   object->setKey( key, index );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_setValue(char * x__object, char * x__value, S32 index)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* value = (const char*)x__value;

{
   object->setValue( value, index );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnArrayObject_count(char * x__object)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( (S32)object->count());
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnArrayObject_countValue(char * x__object, char * x__value)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* value = (const char*)x__value;
{
  return (S32)( (S32)object->countValue( value ));
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnArrayObject_countKey(char * x__object, char * x__key)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* key = (const char*)x__key;
{
  return (S32)( (S32)object->countKey( key ));
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_add(char * x__object, char * x__key, char * x__value)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* key = (const char*)x__key;
const char* value = (const char*)x__value;
{
   object->push_back( key, value );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_push_back(char * x__object, char * x__key, char * x__value)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* key = (const char*)x__key;
const char* value = (const char*)x__value;
{
   object->push_back( key, value );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_push_front(char * x__object, char * x__key, char * x__value)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* key = (const char*)x__key;
const char* value = (const char*)x__value;
{
   object->push_front( key, value );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_insert(char * x__object, char * x__key, char * x__value, S32 index)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* key = (const char*)x__key;
const char* value = (const char*)x__value;

{
   object->insert( key, value, index );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_pop_back(char * x__object)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->pop_back();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_pop_front(char * x__object)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->pop_front();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_erase(char * x__object, S32 index)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->erase( index );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_empty(char * x__object)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->empty();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_uniqueValue(char * x__object)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->uniqueValue();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_uniqueKey(char * x__object)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->uniqueKey();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnArrayObject_duplicate(char * x__object, char * x__target)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
ArrayObject* target; Sim::findObject(x__target, target ); 
bool wle_returnObject;
{
   if ( target )
   {
      object->duplicate( target );
      {wle_returnObject =true;
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnArrayObject_crop(char * x__object, char * x__target)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
ArrayObject* target; Sim::findObject(x__target, target ); 
bool wle_returnObject;
{
   if ( target )
   {
      object->crop( target );
      {wle_returnObject =true;
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnArrayObject_append(char * x__object, char * x__target)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
ArrayObject* target; Sim::findObject(x__target, target ); 
bool wle_returnObject;
{
   if ( target )
   {
      object->append( target );
      {wle_returnObject =true;
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_sort(char * x__object, bool ascending)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->sort( true, ascending, false );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_sorta(char * x__object)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->sort( true, true, false );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_sortd(char * x__object)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->sort( true, false, false );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_sortk(char * x__object, bool ascending)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->sort( false, ascending, false );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_sortka(char * x__object)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->sort( false, true, false );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_sortkd(char * x__object)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->sort( false, false, false );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_sortn(char * x__object, bool ascending)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->sort( true, ascending, true );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_sortna(char * x__object)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->sort( true, true, true );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_sortnd(char * x__object)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->sort( true, false, true );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_sortnk(char * x__object, bool ascending)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->sort( false, ascending, true );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_sortnka(char * x__object)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->sort( false, true, true );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_sortnkd(char * x__object)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->sort( false, false, true );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_sortf(char * x__object, char * x__functionName)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* functionName = (const char*)x__functionName;
{
   object->sort( true, true, functionName );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_sortfk(char * x__object, char * x__functionName)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* functionName = (const char*)x__functionName;
{
   object->sort( false, true, functionName );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_sortfd(char * x__object, char * x__functionName)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* functionName = (const char*)x__functionName;
{
   object->sort( true, false, functionName );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_sortfkd(char * x__object, char * x__functionName)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* functionName = (const char*)x__functionName;
{
   object->sort( false, false, functionName );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnArrayObject_moveFirst(char * x__object)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->moveFirst());
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnArrayObject_moveLast(char * x__object)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->moveLast());
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnArrayObject_moveNext(char * x__object)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->moveNext());
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnArrayObject_movePrev(char * x__object)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->movePrev());
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnArrayObject_getCurrent(char * x__object)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getCurrent());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_setCurrent(char * x__object, S32 index)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setCurrent( index );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnArrayObject_echo(char * x__object)
{
ArrayObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->echo();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_log(char * x__message)
{
const char* message = (const char*)x__message;
{
   Con::printf( "%s", message );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_logError(char * x__message)
{
const char* message = (const char*)x__message;
{
   Con::errorf( "%s", message );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_logWarning(char * x__message)
{
const char* message = (const char*)x__message;
{
   Con::warnf( "%s", message );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_dumpConsoleClasses(bool dumpScript, bool dumpEngine)
{

{
   Namespace::dumpClasses( dumpScript, dumpEngine );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_dumpConsoleFunctions(bool dumpScript, bool dumpEngine)
{

{
   Namespace::dumpFunctions( dumpScript, dumpEngine );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__nextToken(char * x__a1, char * x__a2, char * x__a3,  char* retval)
{
dSprintf(retval,4096,"");
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char * wle_returnObject;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   char *str = (char *) argv[1];
   const char *token = argv[2];
   const char *delim = argv[3];
   if( str )
   {
      // skip over any characters that are a member of delim
      // no need for special '\0' check since it can never be in delim
      while (isInSet(*str, delim))
         str++;
      // skip over any characters that are NOT a member of delim
      const char *tmp = str;
      while (*str && !isInSet(*str, delim))
         str++;
      // terminate the token
      if (*str)
         *str++ = 0;
      // set local variable if inside a function
      if (gEvalState.getStackDepth() > 0 && 
         gEvalState.getCurrentFrame().scopeName)
         Con::setLocalVariable(token,tmp);
      else
         Con::setVariable(token,tmp);
      // advance str past the 'delim space'
      while (isInSet(*str, delim))
         str++;
   }
   {wle_returnObject =str;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__getTag(char * x__a1,  char* retval)
{
dSprintf(retval,4096,"");
const char* a1 = (const char*)x__a1;
const char * wle_returnObject;
{
S32 argc = 2;
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
const char** argv = &arguments[0];
{
   
   if(argv[1][0] == StringTagPrefixByte)
   {
      const char * space = dStrchr(argv[1], ' ');
      U32 len;
      if(space)
         len = space - argv[1];
      else
         len = dStrlen(argv[1]) + 1;
      char * ret = Con::getReturnBuffer(len);
      dStrncpy(ret, argv[1] + 1, len - 1);
      ret[len - 1] = 0;
      {wle_returnObject =(ret);
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   }
   else
      {wle_returnObject =(argv[1]);
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__echo(char * x__a1, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10, char * x__a11, char * x__a12, char * x__a13, char * x__a14, char * x__a15, char * x__a16, char * x__a17, char * x__a18, char * x__a19)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* a11 = (const char*)x__a11;
const char* a12 = (const char*)x__a12;
const char* a13 = (const char*)x__a13;
const char* a14 = (const char*)x__a14;
const char* a15 = (const char*)x__a15;
const char* a16 = (const char*)x__a16;
const char* a17 = (const char*)x__a17;
const char* a18 = (const char*)x__a18;
const char* a19 = (const char*)x__a19;
{
S32 argc = 20;
if (dStrlen(a19)==0)
if (dStrlen(a18)==0)
if (dStrlen(a17)==0)
if (dStrlen(a16)==0)
if (dStrlen(a15)==0)
if (dStrlen(a14)==0)
if (dStrlen(a13)==0)
if (dStrlen(a12)==0)
if (dStrlen(a11)==0)
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
else
argc=12;
else
argc=13;
else
argc=14;
else
argc=15;
else
argc=16;
else
argc=17;
else
argc=18;
else
argc=19;
else
argc=20;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
if (argc>=5)
arguments.push_back(a4);
if (argc>=6)
arguments.push_back(a5);
if (argc>=7)
arguments.push_back(a6);
if (argc>=8)
arguments.push_back(a7);
if (argc>=9)
arguments.push_back(a8);
if (argc>=10)
arguments.push_back(a9);
if (argc>=11)
arguments.push_back(a10);
if (argc>=12)
arguments.push_back(a11);
if (argc>=13)
arguments.push_back(a12);
if (argc>=14)
arguments.push_back(a13);
if (argc>=15)
arguments.push_back(a14);
if (argc>=16)
arguments.push_back(a15);
if (argc>=17)
arguments.push_back(a16);
if (argc>=18)
arguments.push_back(a17);
if (argc>=19)
arguments.push_back(a18);
if (argc>=20)
arguments.push_back(a19);
const char** argv = &arguments[0];
{
   U32 len = 0;
   S32 i;
   for(i = 1; i < argc; i++)
      len += dStrlen(argv[i]);
   char *ret = Con::getReturnBuffer(len + 1);
   ret[0] = 0;
   for(i = 1; i < argc; i++)
      dStrcat(ret, argv[i]);
   Con::printf("%s", ret);
   ret[0] = 0;
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__warn(char * x__a1, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10, char * x__a11, char * x__a12, char * x__a13, char * x__a14, char * x__a15, char * x__a16, char * x__a17, char * x__a18, char * x__a19)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* a11 = (const char*)x__a11;
const char* a12 = (const char*)x__a12;
const char* a13 = (const char*)x__a13;
const char* a14 = (const char*)x__a14;
const char* a15 = (const char*)x__a15;
const char* a16 = (const char*)x__a16;
const char* a17 = (const char*)x__a17;
const char* a18 = (const char*)x__a18;
const char* a19 = (const char*)x__a19;
{
S32 argc = 20;
if (dStrlen(a19)==0)
if (dStrlen(a18)==0)
if (dStrlen(a17)==0)
if (dStrlen(a16)==0)
if (dStrlen(a15)==0)
if (dStrlen(a14)==0)
if (dStrlen(a13)==0)
if (dStrlen(a12)==0)
if (dStrlen(a11)==0)
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
else
argc=12;
else
argc=13;
else
argc=14;
else
argc=15;
else
argc=16;
else
argc=17;
else
argc=18;
else
argc=19;
else
argc=20;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
if (argc>=5)
arguments.push_back(a4);
if (argc>=6)
arguments.push_back(a5);
if (argc>=7)
arguments.push_back(a6);
if (argc>=8)
arguments.push_back(a7);
if (argc>=9)
arguments.push_back(a8);
if (argc>=10)
arguments.push_back(a9);
if (argc>=11)
arguments.push_back(a10);
if (argc>=12)
arguments.push_back(a11);
if (argc>=13)
arguments.push_back(a12);
if (argc>=14)
arguments.push_back(a13);
if (argc>=15)
arguments.push_back(a14);
if (argc>=16)
arguments.push_back(a15);
if (argc>=17)
arguments.push_back(a16);
if (argc>=18)
arguments.push_back(a17);
if (argc>=19)
arguments.push_back(a18);
if (argc>=20)
arguments.push_back(a19);
const char** argv = &arguments[0];
{
   U32 len = 0;
   S32 i;
   for(i = 1; i < argc; i++)
      len += dStrlen(argv[i]);
   char *ret = Con::getReturnBuffer(len + 1);
   ret[0] = 0;
   for(i = 1; i < argc; i++)
      dStrcat(ret, argv[i]);
   Con::warnf(ConsoleLogEntry::General, "%s", ret);
   ret[0] = 0;
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__error(char * x__a1, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10, char * x__a11, char * x__a12, char * x__a13, char * x__a14, char * x__a15, char * x__a16, char * x__a17, char * x__a18, char * x__a19)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* a11 = (const char*)x__a11;
const char* a12 = (const char*)x__a12;
const char* a13 = (const char*)x__a13;
const char* a14 = (const char*)x__a14;
const char* a15 = (const char*)x__a15;
const char* a16 = (const char*)x__a16;
const char* a17 = (const char*)x__a17;
const char* a18 = (const char*)x__a18;
const char* a19 = (const char*)x__a19;
{
S32 argc = 20;
if (dStrlen(a19)==0)
if (dStrlen(a18)==0)
if (dStrlen(a17)==0)
if (dStrlen(a16)==0)
if (dStrlen(a15)==0)
if (dStrlen(a14)==0)
if (dStrlen(a13)==0)
if (dStrlen(a12)==0)
if (dStrlen(a11)==0)
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
else
argc=12;
else
argc=13;
else
argc=14;
else
argc=15;
else
argc=16;
else
argc=17;
else
argc=18;
else
argc=19;
else
argc=20;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
if (argc>=5)
arguments.push_back(a4);
if (argc>=6)
arguments.push_back(a5);
if (argc>=7)
arguments.push_back(a6);
if (argc>=8)
arguments.push_back(a7);
if (argc>=9)
arguments.push_back(a8);
if (argc>=10)
arguments.push_back(a9);
if (argc>=11)
arguments.push_back(a10);
if (argc>=12)
arguments.push_back(a11);
if (argc>=13)
arguments.push_back(a12);
if (argc>=14)
arguments.push_back(a13);
if (argc>=15)
arguments.push_back(a14);
if (argc>=16)
arguments.push_back(a15);
if (argc>=17)
arguments.push_back(a16);
if (argc>=18)
arguments.push_back(a17);
if (argc>=19)
arguments.push_back(a18);
if (argc>=20)
arguments.push_back(a19);
const char** argv = &arguments[0];
{
   U32 len = 0;
   S32 i;
   for(i = 1; i < argc; i++)
      len += dStrlen(argv[i]);
   char *ret = Con::getReturnBuffer(len + 1);
   ret[0] = 0;
   for(i = 1; i < argc; i++)
      dStrcat(ret, argv[i]);
   Con::errorf(ConsoleLogEntry::General, "%s", ret);
   ret[0] = 0;
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__realQuit()
{
{
{
    
   Platform::postQuitMessage(0);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__call(char * x__a1, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10, char * x__a11, char * x__a12, char * x__a13, char * x__a14, char * x__a15, char * x__a16, char * x__a17, char * x__a18, char * x__a19,  char* retval)
{
dSprintf(retval,4096,"");
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* a11 = (const char*)x__a11;
const char* a12 = (const char*)x__a12;
const char* a13 = (const char*)x__a13;
const char* a14 = (const char*)x__a14;
const char* a15 = (const char*)x__a15;
const char* a16 = (const char*)x__a16;
const char* a17 = (const char*)x__a17;
const char* a18 = (const char*)x__a18;
const char* a19 = (const char*)x__a19;
const char * wle_returnObject;
{
S32 argc = 20;
if (dStrlen(a19)==0)
if (dStrlen(a18)==0)
if (dStrlen(a17)==0)
if (dStrlen(a16)==0)
if (dStrlen(a15)==0)
if (dStrlen(a14)==0)
if (dStrlen(a13)==0)
if (dStrlen(a12)==0)
if (dStrlen(a11)==0)
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
else
argc=12;
else
argc=13;
else
argc=14;
else
argc=15;
else
argc=16;
else
argc=17;
else
argc=18;
else
argc=19;
else
argc=20;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
if (argc>=5)
arguments.push_back(a4);
if (argc>=6)
arguments.push_back(a5);
if (argc>=7)
arguments.push_back(a6);
if (argc>=8)
arguments.push_back(a7);
if (argc>=9)
arguments.push_back(a8);
if (argc>=10)
arguments.push_back(a9);
if (argc>=11)
arguments.push_back(a10);
if (argc>=12)
arguments.push_back(a11);
if (argc>=13)
arguments.push_back(a12);
if (argc>=14)
arguments.push_back(a13);
if (argc>=15)
arguments.push_back(a14);
if (argc>=16)
arguments.push_back(a15);
if (argc>=17)
arguments.push_back(a16);
if (argc>=18)
arguments.push_back(a17);
if (argc>=19)
arguments.push_back(a18);
if (argc>=20)
arguments.push_back(a19);
const char** argv = &arguments[0];
{
   {wle_returnObject =Con::execute( argc - 1, argv + 1 );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__eval(char * x__a1,  char* retval)
{
dSprintf(retval,4096,"");
const char* a1 = (const char*)x__a1;
const char * wle_returnObject;
{
S32 argc = 2;
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
const char** argv = &arguments[0];
{
   
   {wle_returnObject =Con::evaluate(argv[1], false, NULL);
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__getVariable(char * x__a1,  char* retval)
{
dSprintf(retval,4096,"");
const char* a1 = (const char*)x__a1;
const char * wle_returnObject;
{
S32 argc = 2;
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
const char** argv = &arguments[0];
{
   {wle_returnObject =Con::getVariable(argv[1]);
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__setVariable(char * x__a1, char * x__a2)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   return Con::setVariable(argv[1], argv[2]);
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn__isFunction(char * x__a1)
{
const char* a1 = (const char*)x__a1;
bool wle_returnObject;
{
S32 argc = 2;
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
const char** argv = &arguments[0];
{
   {wle_returnObject =Con::isFunction(argv[1]);
return (S32)(wle_returnObject);}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn__isMethod(char * x__a1, char * x__a2)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
bool wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   Namespace* ns = Namespace::find( StringTable->insert( argv[1] ) );
   Namespace::Entry* nse = ns->lookup( StringTable->insert( argv[2] ) );
   if( !nse )
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__getMethodPackage(char * x__a1, char * x__a2,  char* retval)
{
dSprintf(retval,4096,"");
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   Namespace* ns = Namespace::find( StringTable->insert( argv[1] ) );
   if( !ns )
      {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   Namespace::Entry* nse = ns->lookup( StringTable->insert( argv[2] ) );
   if( !nse )
      {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   {wle_returnObject =nse->mPackage;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn__isDefined(char * x__a1, char * x__a2)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
bool wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   if(dStrlen(argv[1]) == 0)
   {
      Con::errorf("isDefined() - did you forget to put quotes around the variable name?");
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   }
   StringTableEntry name = StringTable->insert(argv[1]);
   // Deal with <var>.<value>
   if (dStrchr(name, '.'))
   {
      static char scratchBuffer[4096];
      S32 len = dStrlen(name);
      AssertFatal(len < sizeof(scratchBuffer)-1, "isDefined() - name too long");
      dMemcpy(scratchBuffer, name, len+1);
      char * token = dStrtok(scratchBuffer, ".");
      if (!token || token[0] == '\0')
         {wle_returnObject =false;
return (S32)(wle_returnObject);}
      StringTableEntry objName = StringTable->insert(token);
      // Attempt to find the object
      SimObject * obj = Sim::findObject(objName);
      // If we didn't find the object then we can safely
      // assume that the field variable doesn't exist
      if (!obj)
         {wle_returnObject =false;
return (S32)(wle_returnObject);}
      // Get the name of the field
      token = dStrtok(0, ".\0");
      if (!token)
         {wle_returnObject =false;
return (S32)(wle_returnObject);}
      while (token != NULL)
      {
         StringTableEntry valName = StringTable->insert(token);
         // Store these so we can restore them after we search for the variable
         bool saveModStatic = obj->canModStaticFields();
         bool saveModDyn = obj->canModDynamicFields();
         // Set this so that we can search both static and dynamic fields
         obj->setModStaticFields(true);
         obj->setModDynamicFields(true);
         const char* value = obj->getDataField(valName, 0);
         // Restore our mod flags to be safe
         obj->setModStaticFields(saveModStatic);
         obj->setModDynamicFields(saveModDyn);
         if (!value)
         {
            obj->setDataField(valName, 0, argv[2]);
            {wle_returnObject =false;
return (S32)(wle_returnObject);}
         }
         else
         {
            // See if we are field on a field
            token = dStrtok(0, ".\0");
            if (token)
            {
               // The previous field must be an object
               obj = Sim::findObject(value);
               if (!obj)
                  {wle_returnObject =false;
return (S32)(wle_returnObject);}
            }
            else
            {
               if (dStrlen(value) > 0)
                  {wle_returnObject =true;
return (S32)(wle_returnObject);}
               else if (argc > 2)
                  obj->setDataField(valName, 0, argv[2]);
            }
         }
      }
   }
   else if (name[0] == '%')
   {
      // Look up a local variable
      if( gEvalState.getStackDepth() > 0 )
      {
         Dictionary::Entry* ent = gEvalState.getCurrentFrame().lookup(name);
         if (ent)
            {wle_returnObject =true;
return (S32)(wle_returnObject);}
         else if (argc > 2)
            gEvalState.getCurrentFrame().setVariable(name, argv[2]);
      }
      else
         Con::errorf("%s() - no local variable frame.", __FUNCTION__);
   }
   else if (name[0] == '$')
   {
      // Look up a global value
      Dictionary::Entry* ent = gEvalState.globalVars.lookup(name);
      if (ent)
         {wle_returnObject =true;
return (S32)(wle_returnObject);}
      else if (argc > 2)
         gEvalState.globalVars.setVariable(name, argv[2]);
   }
   else
   {
      // Is it an object?
      if (dStrcmp(argv[1], "0") && dStrcmp(argv[1], "") && (Sim::findObject(argv[1]) != NULL))
         {wle_returnObject =true;
return (S32)(wle_returnObject);}
      else if (argc > 2)
         Con::errorf("%s() - can't assign a value to a variable of the form \"%s\"", __FUNCTION__, argv[1]);
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__getModNameFromPath(char * x__a1,  char* retval)
{
dSprintf(retval,4096,"");
const char* a1 = (const char*)x__a1;
const char * wle_returnObject;
{
S32 argc = 2;
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
const char** argv = &arguments[0];
{
   StringTableEntry modPath = Con::getModNameFromPath(argv[1]);
   {wle_returnObject =modPath ? modPath : "";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__getPrefsPath(char * x__a1,  char* retval)
{
dSprintf(retval,4096,"");
const char* a1 = (const char*)x__a1;
const char * wle_returnObject;
{
S32 argc = 2;
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
const char** argv = &arguments[0];
{
   const char *filename = Platform::getPrefsPath(argc > 1 ? argv[1] : NULL);
   if(filename == NULL || *filename == 0)
      {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
     
   {wle_returnObject =filename;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn__execPrefs(char * x__a1, char * x__a2, char * x__a3)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
bool wle_returnObject;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   const char *filename = Platform::getPrefsPath(argv[1]);
   if(filename == NULL || *filename == 0)
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   // Scripts do this a lot, so we may as well help them out
   if(! Platform::isFile(filename) && ! Torque::FS::IsFile(filename))
      {wle_returnObject =true;
return (S32)(wle_returnObject);}
   argv[0] = "exec";
   argv[1] = filename;
   {wle_returnObject =dAtob(Con::execute(argc, argv));
return (S32)(wle_returnObject);}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_strasc(char * x__chr)
{
const char* chr = (const char*)x__chr;
{
  return (int)( oneUTF8toUTF32( chr ));
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_strformat(char * x__format, char * x__value,  char* retval)
{
dSprintf(retval,4096,"");
const char* format = (const char*)x__format;
const char* value = (const char*)x__value;
const char* wle_returnObject;
{
   char* pBuffer = Con::getReturnBuffer(64);
   const char *pch = format;
   pBuffer[0] = '\0';
   while (*pch != '\0' && *pch !='%')
      pch++;
   while (*pch != '\0' && !dIsalpha(*pch))
      pch++;
   if (*pch == '\0')
   {
      Con::errorf("strFormat: Invalid format string!\n");
      {wle_returnObject =pBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   }
   
   switch(*pch)
   {
      case 'c':
      case 'C':
      case 'd':
      case 'i':
      case 'o':
      case 'u':
      case 'x':
      case 'X':
         dSprintf( pBuffer, 64, format, dAtoi( value ) );
         break;
      case 'e':
      case 'E':
      case 'f':
      case 'g':
      case 'G':
         dSprintf( pBuffer, 64, format, dAtof( value ) );
         break;
      default:
         Con::errorf("strFormat: Invalid format string!\n");
         break;
   }
   {wle_returnObject =pBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_strcmp(char * x__str1, char * x__str2)
{
const char* str1 = (const char*)x__str1;
const char* str2 = (const char*)x__str2;
{
  return (S32)( dStrcmp( str1, str2 ));
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_stricmp(char * x__str1, char * x__str2)
{
const char* str1 = (const char*)x__str1;
const char* str2 = (const char*)x__str2;
{
  return (S32)( dStricmp( str1, str2 ));
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_strnatcmp(char * x__str1, char * x__str2)
{
const char* str1 = (const char*)x__str1;
const char* str2 = (const char*)x__str2;
{
  return (S32)( dStrnatcmp( str1, str2 ));
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_strinatcmp(char * x__str1, char * x__str2)
{
const char* str1 = (const char*)x__str1;
const char* str2 = (const char*)x__str2;
{
  return (S32)( dStrnatcasecmp( str1, str2 ));
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_strlen(char * x__str)
{
const char* str = (const char*)x__str;
{
  return (S32)( dStrlen( str ));
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_strstr(char * x__string, char * x__substring)
{
const char* string = (const char*)x__string;
const char* substring = (const char*)x__substring;
{
   const char* retpos = dStrstr( string, substring );
   if( !retpos )
     return (S32)( -1);
      
  return (S32)( retpos - string);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_strpos(char * x__haystack, char * x__needle, int offset)
{
const char* haystack = (const char*)x__haystack;
const char* needle = (const char*)x__needle;

{
   S32 start = offset;
   U32 sublen = dStrlen( needle );
   U32 strlen = dStrlen( haystack );
   if(start < 0)
     return (S32)( -1);
   if(sublen + start > strlen)
     return (S32)( -1);
   for(; start + sublen <= strlen; start++)
      if(!dStrncmp(haystack + start, needle, sublen))
        return (S32)( start);
  return (S32)( -1);
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_ltrim(char * x__str,  char* retval)
{
dSprintf(retval,4096,"");
const char* str = (const char*)x__str;
const char* wle_returnObject;
{
   const char *ret = str;
   while(*ret == ' ' || *ret == '\n' || *ret == '\t')
      ret++;
   {wle_returnObject =ret;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_rtrim(char * x__str,  char* retval)
{
dSprintf(retval,4096,"");
const char* str = (const char*)x__str;
const char* wle_returnObject;
{
   S32 firstWhitespace = 0;
   S32 pos = 0;
   while(str[pos])
   {
      if(str[pos] != ' ' && str[pos] != '\n' && str[pos] != '\t')
         firstWhitespace = pos + 1;
      pos++;
   }
   char *ret = Con::getReturnBuffer(firstWhitespace + 1);
   dStrncpy(ret, str, firstWhitespace);
   ret[firstWhitespace] = 0;
   {wle_returnObject =ret;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_trim(char * x__str,  char* retval)
{
dSprintf(retval,4096,"");
const char* str = (const char*)x__str;
const char* wle_returnObject;
{
   const char *ptr = str;
   while(*ptr == ' ' || *ptr == '\n' || *ptr == '\t')
      ptr++;
   S32 firstWhitespace = 0;
   S32 pos = 0;
   while(ptr[pos])
   {
      if(ptr[pos] != ' ' && ptr[pos] != '\n' && ptr[pos] != '\t')
         firstWhitespace = pos + 1;
      pos++;
   }
   char *ret = Con::getReturnBuffer(firstWhitespace + 1);
   dStrncpy(ret, ptr, firstWhitespace);
   ret[firstWhitespace] = 0;
   {wle_returnObject =ret;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_stripChars(char * x__str, char * x__chars,  char* retval)
{
dSprintf(retval,4096,"");
const char* str = (const char*)x__str;
const char* chars = (const char*)x__chars;
const char* wle_returnObject;
{
   char* ret = Con::getReturnBuffer( dStrlen( str ) + 1 );
   dStrcpy( ret, str );
   U32 pos = dStrcspn( ret, chars );
   while ( pos < dStrlen( ret ) )
   {
      dStrcpy( ret + pos, ret + pos + 1 );
      pos = dStrcspn( ret, chars );
   }
   {wle_returnObject =( ret );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_strlwr(char * x__str,  char* retval)
{
dSprintf(retval,4096,"");
const char* str = (const char*)x__str;
const char* wle_returnObject;
{
   char *ret = Con::getReturnBuffer(dStrlen(str) + 1);
   dStrcpy(ret, str);
   {wle_returnObject =dStrlwr(ret);
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_strupr(char * x__str,  char* retval)
{
dSprintf(retval,4096,"");
const char* str = (const char*)x__str;
const char* wle_returnObject;
{
   char *ret = Con::getReturnBuffer(dStrlen(str) + 1);
   dStrcpy(ret, str);
   {wle_returnObject =dStrupr(ret);
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_strchr(char * x__str, char * x__chr,  char* retval)
{
dSprintf(retval,4096,"");
const char* str = (const char*)x__str;
const char* chr = (const char*)x__chr;
const char* wle_returnObject;
{
   const char *ret = dStrchr( str, chr[ 0 ] );
   {wle_returnObject =ret ? ret : "";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_strrchr(char * x__str, char * x__chr,  char* retval)
{
dSprintf(retval,4096,"");
const char* str = (const char*)x__str;
const char* chr = (const char*)x__chr;
const char* wle_returnObject;
{
   const char *ret = dStrrchr( str, chr[ 0 ] );
   {wle_returnObject =ret ? ret : "";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_strreplace(char * x__source, char * x__from, char * x__to,  char* retval)
{
dSprintf(retval,4096,"");
const char* source = (const char*)x__source;
const char* from = (const char*)x__from;
const char* to = (const char*)x__to;
const char* wle_returnObject;
{
   S32 fromLen = dStrlen( from );
   if(!fromLen)
      {wle_returnObject =source;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   S32 toLen = dStrlen( to );
   S32 count = 0;
   const char *scan = source;
   while(scan)
   {
      scan = dStrstr(scan, from);
      if(scan)
      {
         scan += fromLen;
         count++;
      }
   }
   char *ret = Con::getReturnBuffer(dStrlen(source) + 1 + (toLen - fromLen) * count);
   U32 scanp = 0;
   U32 dstp = 0;
   for(;;)
   {
      const char *scan = dStrstr(source + scanp, from);
      if(!scan)
      {
         dStrcpy(ret + dstp, source + scanp);
         {wle_returnObject =ret;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
      }
      U32 len = scan - (source + scanp);
      dStrncpy(ret + dstp, source + scanp, len);
      dstp += len;
      dStrcpy(ret + dstp, to);
      dstp += toLen;
      scanp += len + fromLen;
   }
   {wle_returnObject =ret;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_strrepeat(char * x__str, S32 numTimes, char * x__delimiter,  char* retval)
{
dSprintf(retval,4096,"");
const char* str = (const char*)x__str;

const char* delimiter = (const char*)x__delimiter;
const char* wle_returnObject;
{
   StringBuilder result;
   bool isFirst = false;
   for( U32 i = 0; i < numTimes; ++ i )
   {
      if( !isFirst )
         result.append( delimiter );
         
      result.append( str );
      isFirst = false;
   }
   
   {wle_returnObject =Con::getReturnBuffer( result );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getSubStr(char * x__str, S32 start, S32 numChars,  char* retval)
{
dSprintf(retval,4096,"");
const char* str = (const char*)x__str;

const char* wle_returnObject;
{
   S32 baseLen = dStrlen( str );
   if( numChars == -1 )
      numChars = baseLen - start;
      
   if (start < 0 || numChars < 0) {
      Con::errorf(ConsoleLogEntry::Script, "getSubStr(...): error, starting position and desired length must be >= 0: (%d, %d)", start, numChars);
      {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   }
   if (baseLen < start)
      {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   U32 actualLen = numChars;
   if (start + numChars > baseLen)
      actualLen = baseLen - start;
   char *ret = Con::getReturnBuffer(actualLen + 1);
   dStrncpy(ret, str + start, actualLen);
   ret[actualLen] = '\0';
   {wle_returnObject =ret;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_strIsMatchExpr(char * x__pattern, char * x__str, bool caseSensitive)
{
const char* pattern = (const char*)x__pattern;
const char* str = (const char*)x__str;

bool wle_returnObject;
{
   {wle_returnObject =FindMatch::isMatch( pattern, str, caseSensitive );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_strIsMatchMultipleExpr(char * x__patterns, char * x__str, bool caseSensitive)
{
const char* patterns = (const char*)x__patterns;
const char* str = (const char*)x__str;

bool wle_returnObject;
{
   {wle_returnObject =FindMatch::isMatchMultipleExprs( patterns, str, caseSensitive );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_getTrailingNumber(char * x__str)
{
const char* str = (const char*)x__str;
{
   S32 suffix = -1;
   String outStr( String::GetTrailingNumber( str, suffix ) );
  return (S32)( suffix);
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_stripTrailingNumber(char * x__str,  char* retval)
{
dSprintf(retval,1024,"");
const char* str = (const char*)x__str;
String wle_returnObject;
{
   S32 suffix;
   {wle_returnObject =String::GetTrailingNumber( str, suffix );
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_isspace(char * x__str, S32 index)
{
const char* str = (const char*)x__str;

bool wle_returnObject;
{
   if( index >= 0 && index < dStrlen( str ) )
      {wle_returnObject =dIsspace( str[ index ] );
return (S32)(wle_returnObject);}
   else
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_isalnum(char * x__str, S32 index)
{
const char* str = (const char*)x__str;

bool wle_returnObject;
{
   if( index >= 0 && index < dStrlen( str ) )
      {wle_returnObject =dIsalnum( str[ index ] );
return (S32)(wle_returnObject);}
   else
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_startsWith(char * x__str, char * x__prefix, bool caseSensitive)
{
const char* str = (const char*)x__str;
const char* prefix = (const char*)x__prefix;

bool wle_returnObject;
{
   // if the target string is empty, return true (all strings start with the empty string)
   S32 srcLen = dStrlen( str );
   S32 targetLen = dStrlen( prefix );
   if( targetLen == 0 )
      {wle_returnObject =true;
return (S32)(wle_returnObject);}
   // else if the src string is empty, return false (empty src does not start with non-empty target)
   else if( srcLen == 0 )
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   if( caseSensitive )
      {wle_returnObject =( dStrncmp( str, prefix, targetLen ) == 0 );
return (S32)(wle_returnObject);}
   // both src and target are non empty, create temp buffers for lowercase operation
   char* srcBuf = new char[ srcLen + 1 ];
   char* targetBuf = new char[ targetLen + 1 ];
   // copy src and target into buffers
   dStrcpy( srcBuf, str );
   dStrcpy( targetBuf, prefix );
   // reassign src/target pointers to lowercase versions
   str = dStrlwr( srcBuf );
   prefix = dStrlwr( targetBuf );
   // do the comparison
   bool startsWith = dStrncmp( str, prefix, targetLen ) == 0;
   // delete temp buffers
   delete [] srcBuf;
   delete [] targetBuf;
   {wle_returnObject =startsWith;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_endsWith(char * x__str, char * x__suffix, bool caseSensitive)
{
const char* str = (const char*)x__str;
const char* suffix = (const char*)x__suffix;

bool wle_returnObject;
{
   // if the target string is empty, return true (all strings end with the empty string)
   S32 srcLen = dStrlen( str );
   S32 targetLen = dStrlen( suffix );
   if (targetLen == 0)
      {wle_returnObject =true;
return (S32)(wle_returnObject);}
   // else if the src string is empty, return false (empty src does not end with non-empty target)
   else if (srcLen == 0)
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   else if( targetLen > srcLen )
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
      
   if( caseSensitive )
      {wle_returnObject =( dStrcmp( &str[ srcLen - targetLen ], suffix ) == 0 );
return (S32)(wle_returnObject);}
   // both src and target are non empty, create temp buffers for lowercase operation
   char* srcBuf = new char[ srcLen + 1 ];
   char* targetBuf = new char[ targetLen + 1 ];
   // copy src and target into buffers
   dStrcpy( srcBuf, str );
   dStrcpy( targetBuf, suffix );
   // reassign src/target pointers to lowercase versions
   str = dStrlwr( srcBuf );
   suffix = dStrlwr( targetBuf );
   // set the src pointer to the appropriate place to check the end of the string
   str += srcLen - targetLen;
   // do the comparison
   bool endsWith = dStrcmp( str, suffix ) == 0;
   // delete temp buffers
   delete [] srcBuf;
   delete [] targetBuf;
   {wle_returnObject =endsWith;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_strchrpos(char * x__str, char * x__chr, S32 start)
{
const char* str = (const char*)x__str;
const char* chr = (const char*)x__chr;

{
   if( start != 0 && start >= dStrlen( str ) )
     return (S32)( -1);
   
   const char* ret = dStrchr( &str[ start ], chr[ 0 ] );
  return (S32)( ret ? ret - str : -1);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_strrchrpos(char * x__str, char * x__chr, S32 start)
{
const char* str = (const char*)x__str;
const char* chr = (const char*)x__chr;

{
   if( start != 0 && start >= dStrlen( str ) )
     return (S32)( -1);
   const char* ret = dStrrchr( str, chr[ 0 ] );
   if( !ret )
     return (S32)( -1);
      
   S32 index = ret - str;
   if( index < start )
     return (S32)( -1);
      
  return (S32)( index);
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getWord(char * x__text, S32 index,  char* retval)
{
dSprintf(retval,4096,"");
const char* text = (const char*)x__text;

const char* wle_returnObject;
{
   {wle_returnObject =Con::getReturnBuffer( StringUnit::getUnit( text, index, " \t\n") );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getWords(char * x__text, S32 startIndex, S32 endIndex,  char* retval)
{
dSprintf(retval,4096,"");
const char* text = (const char*)x__text;

const char* wle_returnObject;
{
   if( endIndex < 0 )
      endIndex = 1000000;
   {wle_returnObject =Con::getReturnBuffer( StringUnit::getUnits( text, startIndex, endIndex, " \t\n" ) );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_setWord(char * x__text, S32 index, char * x__replacement,  char* retval)
{
dSprintf(retval,4096,"");
const char* text = (const char*)x__text;

const char* replacement = (const char*)x__replacement;
const char* wle_returnObject;
{
   {wle_returnObject =Con::getReturnBuffer( StringUnit::setUnit( text, index, replacement, " \t\n") );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_removeWord(char * x__text, S32 index,  char* retval)
{
dSprintf(retval,4096,"");
const char* text = (const char*)x__text;

const char* wle_returnObject;
{
   {wle_returnObject =Con::getReturnBuffer( StringUnit::removeUnit( text, index, " \t\n" ) );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_getWordCount(char * x__text)
{
const char* text = (const char*)x__text;
{
  return (S32)( StringUnit::getUnitCount( text, " \t\n" ));
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getField(char * x__text, S32 index,  char* retval)
{
dSprintf(retval,4096,"");
const char* text = (const char*)x__text;

const char* wle_returnObject;
{
   {wle_returnObject =Con::getReturnBuffer( StringUnit::getUnit( text, index, "\t\n" ) );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getFields(char * x__text, S32 startIndex, S32 endIndex,  char* retval)
{
dSprintf(retval,4096,"");
const char* text = (const char*)x__text;

const char* wle_returnObject;
{
   if( endIndex < 0 )
      endIndex = 1000000;
   {wle_returnObject =Con::getReturnBuffer( StringUnit::getUnits( text, startIndex, endIndex, "\t\n" ) );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_setField(char * x__text, S32 index, char * x__replacement,  char* retval)
{
dSprintf(retval,4096,"");
const char* text = (const char*)x__text;

const char* replacement = (const char*)x__replacement;
const char* wle_returnObject;
{
   {wle_returnObject =Con::getReturnBuffer( StringUnit::setUnit( text, index, replacement, "\t\n" ) );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_removeField(char * x__text, S32 index,  char* retval)
{
dSprintf(retval,4096,"");
const char* text = (const char*)x__text;

const char* wle_returnObject;
{
   {wle_returnObject =Con::getReturnBuffer( StringUnit::removeUnit( text, index, "\t\n" ) );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_getFieldCount(char * x__text)
{
const char* text = (const char*)x__text;
{
  return (S32)( StringUnit::getUnitCount( text, "\t\n" ));
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getRecord(char * x__text, S32 index,  char* retval)
{
dSprintf(retval,4096,"");
const char* text = (const char*)x__text;

const char* wle_returnObject;
{
   {wle_returnObject =Con::getReturnBuffer( StringUnit::getUnit( text, index, "\n" ) );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getRecords(char * x__text, S32 startIndex, S32 endIndex,  char* retval)
{
dSprintf(retval,4096,"");
const char* text = (const char*)x__text;

const char* wle_returnObject;
{
   if( endIndex < 0 )
      endIndex = 1000000;
   {wle_returnObject =Con::getReturnBuffer( StringUnit::getUnits( text, startIndex, endIndex, "\n" ) );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_setRecord(char * x__text, S32 index, char * x__replacement,  char* retval)
{
dSprintf(retval,4096,"");
const char* text = (const char*)x__text;

const char* replacement = (const char*)x__replacement;
const char* wle_returnObject;
{
   {wle_returnObject =Con::getReturnBuffer( StringUnit::setUnit( text, index, replacement, "\n" ) );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_removeRecord(char * x__text, S32 index,  char* retval)
{
dSprintf(retval,4096,"");
const char* text = (const char*)x__text;

const char* wle_returnObject;
{
   {wle_returnObject =Con::getReturnBuffer( StringUnit::removeUnit( text, index, "\n" ) );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_getRecordCount(char * x__text)
{
const char* text = (const char*)x__text;
{
  return (S32)( StringUnit::getUnitCount( text, "\n" ));
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_firstWord(char * x__text,  char* retval)
{
dSprintf(retval,4096,"");
const char* text = (const char*)x__text;
const char* wle_returnObject;
{
   {wle_returnObject =Con::getReturnBuffer( StringUnit::getUnit( text, 0, " \t\n" ) );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_restWords(char * x__text,  char* retval)
{
dSprintf(retval,4096,"");
const char* text = (const char*)x__text;
const char* wle_returnObject;
{
   const char* ptr = text;
   while( *ptr && *ptr != ' ' && *ptr != '\t' && *ptr != '\n' )
      ptr ++;
      
   // Skip separator.
   if( *ptr )
      ptr ++;
      
   {wle_returnObject =Con::getReturnBuffer( ptr );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_expandEscape(char * x__text,  char* retval)
{
dSprintf(retval,4096,"");
const char* text = (const char*)x__text;
const char* wle_returnObject;
{
   char* ret = Con::getReturnBuffer(dStrlen( text ) * 2 + 1 );  // worst case situation
   expandEscape( ret, text );
   {wle_returnObject =ret;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_collapseEscape(char * x__text,  char* retval)
{
dSprintf(retval,4096,"");
const char* text = (const char*)x__text;
const char* wle_returnObject;
{
   char* ret = Con::getReturnBuffer( text );
   collapseEscape( ret );
   {wle_returnObject =ret;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_quit()
{
{
   Platform::postQuitMessage(0);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_quitWithErrorMessage(char * x__message)
{
const char* message = (const char*)x__message;
{
   Con::errorf( message );
   Platform::AlertOK( "Error", message );
   
   // [rene 03/30/10] This was previously using forceShutdown which is a bad thing
   //    as the script code should not be allowed to pretty much hard-crash the engine
   //    and prevent proper shutdown.  Changed this to use postQuitMessage.
   
   Platform::postQuitMessage( -1 );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_export(char * x__pattern, char * x__filename, bool append)
{
const char* pattern = (const char*)x__pattern;
const char* filename = (const char*)x__filename;

{
   if( filename && filename[ 0 ] )
   {
#ifndef TORQUE2D_TOOLS_FIXME
      if(Con::expandScriptFilename(scriptFilenameBuffer, sizeof(scriptFilenameBuffer), filename))
         filename = scriptFilenameBuffer;
#else
      filename = Platform::getPrefsPath( filename );
      if(filename == NULL || *filename == 0)
         return;
#endif
   }
   else
      filename = NULL;
   gEvalState.globalVars.exportVariables( pattern, filename, append );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_trace(bool enable)
{
{
   gEvalState.traceOn = enable;
   Con::printf( "Console trace %s", gEvalState.traceOn ? "enabled." : "disabled." );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_debug()
{
{
   Platform::debugBreak();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_detag(char * x__str,  char* retval)
{
dSprintf(retval,4096,"");
const char* str = (const char*)x__str;
const char* wle_returnObject;
{
   if( str[ 0 ] == StringTagPrefixByte )
   {
      const char* word = dStrchr( str, ' ' );
      if( word == NULL )
         {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
         
      char* ret = Con::getReturnBuffer( dStrlen( word + 1 ) + 1 );
      dStrcpy( ret, word + 1 );
      {wle_returnObject =ret;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   }
   else
      {wle_returnObject =str;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_debugv(char * x__variableName)
{
const char* variableName = (const char*)x__variableName;
{
   if( variableName[ 0 ] == '%' )
      Con::errorf( "%s = %s", variableName, Con::getLocalVariable( variableName ) );
   else
      Con::errorf( "%s = %s", variableName, Con::getVariable( variableName ) );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_setLogMode(S32 mode)
{
{
   Con::setLogMode( mode );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_gotoWebPage(char * x__address)
{
const char* address = (const char*)x__address;
{
   // If there's a protocol prefix in the address, just invoke
   // the browser on the given address.
   
   char* protocolSep = dStrstr( address,"://");
   if( protocolSep != NULL )
   {
      Platform::openWebBrowser( address );
      return;
   }
   // If we don't see a protocol seperator, then we know that some bullethead
   // sent us a bad url. We'll first check to see if a file inside the sandbox
   // with that name exists, then we'll just glom "http://" onto the front of 
   // the bogus url, and hope for the best.
   
   String addr;
   if( Platform::isFile( address ) || Platform::isDirectory( address ) )
   {
#ifdef TORQUE2D_TOOLS_FIXME
      addr = String::ToString( "file://%s", address );
#else
      addr = String::ToString( "file://%s/%s", Platform::getCurrentDirectory(), address );
#endif
   }
   else
      addr = String::ToString( "http://%s", address );
   
   Platform::openWebBrowser( addr );
   return;
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_displaySplashWindow()
{
bool wle_returnObject;
{
   {wle_returnObject =Platform::displaySplashWindow();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_getWebDeployment()
{
bool wle_returnObject;
{
   {wle_returnObject =Platform::getWebDeployment();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_countBits(S32 v)
{
{
   S32 c = 0;
   // from 
   // http://graphics.stanford.edu/~seander/bithacks.html
   // for at most 32-bit values in v:
   c =  ((v & 0xfff) * 0x1001001001001ULL & 0x84210842108421ULL) % 0x1f;
   c += (((v & 0xfff000) >> 12) * 0x1001001001001ULL & 0x84210842108421ULL) % 
      0x1f;
   c += ((v >> 24) * 0x1001001001001ULL & 0x84210842108421ULL) % 0x1f;
#ifndef TORQUE_SHIPPING
   // since the above isn't very obvious, for debugging compute the count in a more 
   // traditional way and assert if it is different
   {
      S32 c2 = 0;
      S32 v2 = v;
      for (c2 = 0; v2; v2 >>= 1)
      {
         c2 += v2 & 1;
      }
      if (c2 != c)
         Con::errorf("countBits: Uh oh bit count mismatch");
      AssertFatal(c2 == c, "countBits: uh oh, bit count mismatch");
   }
#endif
  return (S32)( c);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_compile(char * x__fileName, bool overrideNoDSO)
{
const char* fileName = (const char*)x__fileName;

bool wle_returnObject;
{
   Con::expandScriptFilename( scriptFilenameBuffer, sizeof( scriptFilenameBuffer ), fileName );
   // Figure out where to put DSOs
   StringTableEntry dsoPath = getDSOPath(scriptFilenameBuffer);
   if(dsoPath && *dsoPath == 0)
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   // If the script file extention is '.ed.cs' then compile it to a different compiled extention
   bool isEditorScript = false;
   const char *ext = dStrrchr( scriptFilenameBuffer, '.' );
   if( ext && ( dStricmp( ext, ".cs" ) == 0 ) )
   {
      const char* ext2 = ext - 3;
      if( dStricmp( ext2, ".ed.cs" ) == 0 )
         isEditorScript = true;
   }
   else if( ext && ( dStricmp( ext, ".gui" ) == 0 ) )
   {
      const char* ext2 = ext - 3;
      if( dStricmp( ext2, ".ed.gui" ) == 0 )
         isEditorScript = true;
   }
   const char *filenameOnly = dStrrchr(scriptFilenameBuffer, '/');
   if(filenameOnly)
      ++filenameOnly;
   else
      filenameOnly = scriptFilenameBuffer;
 
   char nameBuffer[512];
   if( isEditorScript )
      dStrcpyl(nameBuffer, sizeof(nameBuffer), dsoPath, "/", filenameOnly, ".edso", NULL);
   else
      dStrcpyl(nameBuffer, sizeof(nameBuffer), dsoPath, "/", filenameOnly, ".dso", NULL);
   
   void *data = NULL;
   U32 dataSize = 0;
   Torque::FS::ReadFile(scriptFilenameBuffer, data, dataSize, true);
   if(data == NULL)
   {
      Con::errorf(ConsoleLogEntry::Script, "compile: invalid script file %s.", scriptFilenameBuffer);
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   }
   const char *script = static_cast<const char *>(data);
#ifdef TORQUE_DEBUG
   Con::printf("Compiling %s...", scriptFilenameBuffer);
#endif 
   CodeBlock *code = new CodeBlock();
   code->compile(nameBuffer, scriptFilenameBuffer, script, overrideNoDSO);
   delete code;
   delete[] script;
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_exec(char * x__fileName, bool noCalls, bool journalScript)
{
const char* fileName = (const char*)x__fileName;

bool wle_returnObject;
{
   bool journal = false;
   execDepth++;
   if(journalDepth >= execDepth)
      journalDepth = execDepth + 1;
   else
      journal = true;
   bool ret = false;
   if( journalScript && !journal )
   {
      journal = true;
      journalDepth = execDepth;
   }
   // Determine the filename we actually want...
   Con::expandScriptFilename( scriptFilenameBuffer, sizeof( scriptFilenameBuffer ), fileName );
   // since this function expects a script file reference, if it's a .dso
   // lets terminate the string before the dso so it will act like a .cs
   if(dStrEndsWith(scriptFilenameBuffer, ".dso"))
   {
      scriptFilenameBuffer[dStrlen(scriptFilenameBuffer) - dStrlen(".dso")] = '\0';
   }
   // Figure out where to put DSOs
   StringTableEntry dsoPath = getDSOPath(scriptFilenameBuffer);
   const char *ext = dStrrchr(scriptFilenameBuffer, '.');
   if(!ext)
   {
      // We need an extension!
      Con::errorf(ConsoleLogEntry::Script, "exec: invalid script file name %s.", scriptFilenameBuffer);
      execDepth--;
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   }
   // Check Editor Extensions
   bool isEditorScript = false;
   // If the script file extension is '.ed.cs' then compile it to a different compiled extension
   if( dStricmp( ext, ".cs" ) == 0 )
   {
      const char* ext2 = ext - 3;
      if( dStricmp( ext2, ".ed.cs" ) == 0 )
         isEditorScript = true;
   }
   else if( dStricmp( ext, ".gui" ) == 0 )
   {
      const char* ext2 = ext - 3;
      if( dStricmp( ext2, ".ed.gui" ) == 0 )
         isEditorScript = true;
   }
   StringTableEntry scriptFileName = StringTable->insert(scriptFilenameBuffer);
#ifndef TORQUE_OS_XENON
   // Is this a file we should compile? (anything in the prefs path should not be compiled)
   StringTableEntry prefsPath = Platform::getPrefsPath();
   bool compiled = dStricmp(ext, ".mis") && !journal && !Con::getBoolVariable("Scripts::ignoreDSOs");
   // [tom, 12/5/2006] stripBasePath() fucks up if the filename is not in the exe
   // path, current directory or prefs path. Thus, getDSOFilename() will also screw
   // up and so this allows the scripts to still load but without a DSO.
   if(Platform::isFullPath(Platform::stripBasePath(scriptFilenameBuffer)))
      compiled = false;
   // [tom, 11/17/2006] It seems to make sense to not compile scripts that are in the
   // prefs directory. However, getDSOPath() can handle this situation and will put
   // the dso along with the script to avoid name clashes with tools/game dsos.
   if( (dsoPath && *dsoPath == 0) || (prefsPath && prefsPath[ 0 ] && dStrnicmp(scriptFileName, prefsPath, dStrlen(prefsPath)) == 0) )
      compiled = false;
#else
   bool compiled = false;  // Don't try to compile things on the 360, ignore DSO's when debugging
                           // because PC prefs will screw up stuff like SFX.
#endif
   // If we're in a journaling mode, then we will read the script
   // from the journal file.
   if(journal && Journal::IsPlaying())
   {
      char fileNameBuf[256];
      bool fileRead = false;
      U32 fileSize;
      Journal::ReadString(fileNameBuf);
      Journal::Read(&fileRead);
      if(!fileRead)
      {
         Con::errorf(ConsoleLogEntry::Script, "Journal script read (failed) for %s", fileNameBuf);
         execDepth--;
         {wle_returnObject =false;
return (S32)(wle_returnObject);}
      }
      Journal::Read(&fileSize);
      char *script = new char[fileSize + 1];
      Journal::Read(fileSize, script);
      script[fileSize] = 0;
      Con::printf("Executing (journal-read) %s.", scriptFileName);
      CodeBlock *newCodeBlock = new CodeBlock();
      newCodeBlock->compileExec(scriptFileName, script, noCalls, 0);
      delete [] script;
      execDepth--;
      {wle_returnObject =true;
return (S32)(wle_returnObject);}
   }
   // Ok, we let's try to load and compile the script.
   Torque::FS::FileNodeRef scriptFile = Torque::FS::GetFileNode(scriptFileName);
   Torque::FS::FileNodeRef dsoFile;
   
//    ResourceObject *rScr = gResourceManager->find(scriptFileName);
//    ResourceObject *rCom = NULL;
   char nameBuffer[512];
   char* script = NULL;
   U32 version;
   Stream *compiledStream = NULL;
   Torque::Time scriptModifiedTime, dsoModifiedTime;
   // Check here for .edso
   bool edso = false;
   if( dStricmp( ext, ".edso" ) == 0  && scriptFile != NULL )
   {
      edso = true;
      dsoFile = scriptFile;
      scriptFile = NULL;
      dsoModifiedTime = dsoFile->getModifiedTime();
      dStrcpy( nameBuffer, scriptFileName );
   }
   // If we're supposed to be compiling this file, check to see if there's a DSO
   if(compiled && !edso)
   {
      const char *filenameOnly = dStrrchr(scriptFileName, '/');
      if(filenameOnly)
         ++filenameOnly;
      else
         filenameOnly = scriptFileName;
      char pathAndFilename[1024];
      Platform::makeFullPathName(filenameOnly, pathAndFilename, sizeof(pathAndFilename), dsoPath);
      if( isEditorScript )
         dStrcpyl(nameBuffer, sizeof(nameBuffer), pathAndFilename, ".edso", NULL);
      else
         dStrcpyl(nameBuffer, sizeof(nameBuffer), pathAndFilename, ".dso", NULL);
      dsoFile = Torque::FS::GetFileNode(nameBuffer);
      if(scriptFile != NULL)
         scriptModifiedTime = scriptFile->getModifiedTime();
      
      if(dsoFile != NULL)
         dsoModifiedTime = dsoFile->getModifiedTime();
   }
   // Let's do a sanity check to complain about DSOs in the future.
   //
   // MM:	This doesn't seem to be working correctly for now so let's just not issue
   //		the warning until someone knows how to resolve it.
   //
   //if(compiled && rCom && rScr && Platform::compareFileTimes(comModifyTime, scrModifyTime) < 0)
   //{
      //Con::warnf("exec: Warning! Found a DSO from the future! (%s)", nameBuffer);
   //}
   // If we had a DSO, let's check to see if we should be reading from it.
   if(compiled && dsoFile != NULL && (scriptFile == NULL|| (scriptModifiedTime - dsoModifiedTime) > Torque::Time(0)))
   {
      compiledStream = FileStream::createAndOpen( nameBuffer, Torque::FS::File::Read );
      if (compiledStream)
      {
         // Check the version!
         compiledStream->read(&version);
         if(version != Con::DSOVersion)
         {
            Con::warnf("exec: Found an old DSO (%s, ver %d < %d), ignoring.", nameBuffer, version, Con::DSOVersion);
            delete compiledStream;
            compiledStream = NULL;
         }
      }
   }
   // If we're journalling, let's write some info out.
   if(journal && Journal::IsRecording())
      Journal::WriteString(scriptFileName);
   if(scriptFile != NULL && !compiledStream)
   {
      // If we have source but no compiled version, then we need to compile
      // (and journal as we do so, if that's required).
      void *data;
      U32 dataSize = 0;
      Torque::FS::ReadFile(scriptFileName, data, dataSize, true);
      if(journal && Journal::IsRecording())
         Journal::Write(bool(data != NULL));
         
      if( data == NULL )
      {
         Con::errorf(ConsoleLogEntry::Script, "exec: invalid script file %s.", scriptFileName);
         execDepth--;
         {wle_returnObject =false;
return (S32)(wle_returnObject);}
      }
      else
      {
         if( !dataSize )
         {
            execDepth --;
            {wle_returnObject =false;
return (S32)(wle_returnObject);}
         }
         
         script = (char *)data;
         if(journal && Journal::IsRecording())
         {
            Journal::Write(dataSize);
            Journal::Write(dataSize, data);
         }
      }
#ifndef TORQUE_NO_DSO_GENERATION
      if(compiled)
      {
         // compile this baddie.
#ifdef TORQUE_DEBUG
         Con::printf("Compiling %s...", scriptFileName);
#endif   
         CodeBlock *code = new CodeBlock();
         code->compile(nameBuffer, scriptFileName, script);
         delete code;
         code = NULL;
         compiledStream = FileStream::createAndOpen( nameBuffer, Torque::FS::File::Read );
         if(compiledStream)
         {
            compiledStream->read(&version);
         }
         else
         {
            // We have to exit out here, as otherwise we get double error reports.
            delete [] script;
            execDepth--;
            {wle_returnObject =false;
return (S32)(wle_returnObject);}
         }
      }
#endif
   }
   else
   {
      if(journal && Journal::IsRecording())
         Journal::Write(bool(false));
   }
   if(compiledStream)
   {
      // Delete the script object first to limit memory used
      // during recursive execs.
      delete [] script;
      script = 0;
      // We're all compiled, so let's run it.
#ifdef TORQUE_DEBUG
      Con::printf("Loading compiled script %s.", scriptFileName);
#endif   
      CodeBlock *code = new CodeBlock;
      code->read(scriptFileName, *compiledStream);
      delete compiledStream;
      code->exec(0, scriptFileName, NULL, 0, NULL, noCalls, NULL, 0);
      ret = true;
   }
   else
      if(scriptFile)
      {
         // No compiled script,  let's just try executing it
         // directly... this is either a mission file, or maybe
         // we're on a readonly volume.
#ifdef TORQUE_DEBUG
         Con::printf("Executing %s.", scriptFileName);
#endif   
         CodeBlock *newCodeBlock = new CodeBlock();
         StringTableEntry name = StringTable->insert(scriptFileName);
         newCodeBlock->compileExec(name, script, noCalls, 0);
         ret = true;
      }
      else
      {
         // Don't have anything.
         Con::warnf(ConsoleLogEntry::Script, "Missing file: %s!", scriptFileName);
         ret = false;
      }
   delete [] script;
   execDepth--;
   {wle_returnObject =ret;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_deleteVariables(char * x__pattern)
{
const char* pattern = (const char*)x__pattern;
{
   gEvalState.globalVars.deleteVariables( pattern );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_isShippingBuild()
{
bool wle_returnObject;
{
#ifdef TORQUE_SHIPPING
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
#else
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
#endif
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_isDebugBuild()
{
bool wle_returnObject;
{
#ifdef TORQUE_DEBUG
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
#else
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
#endif
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_isToolBuild()
{
bool wle_returnObject;
{
#ifdef TORQUE_TOOLS
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
#else
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
#endif
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_backtrace()
{
{
   U32 totalSize = 1;
   for(U32 i = 0; i < gEvalState.getStackDepth(); i++)
   {
      if(gEvalState.stack[i]->scopeNamespace && gEvalState.stack[i]->scopeNamespace->mEntryList->mPackage)  
         totalSize += dStrlen(gEvalState.stack[i]->scopeNamespace->mEntryList->mPackage) + 2;  
      if(gEvalState.stack[i]->scopeName)  
      totalSize += dStrlen(gEvalState.stack[i]->scopeName) + 3;
      if(gEvalState.stack[i]->scopeNamespace && gEvalState.stack[i]->scopeNamespace->mName)
         totalSize += dStrlen(gEvalState.stack[i]->scopeNamespace->mName) + 2;
   }
   char *buf = Con::getReturnBuffer(totalSize);
   buf[0] = 0;
   for(U32 i = 0; i < gEvalState.getStackDepth(); i++)
   {
      dStrcat(buf, "->");
      
      if(gEvalState.stack[i]->scopeNamespace && gEvalState.stack[i]->scopeNamespace->mEntryList->mPackage)  
      {  
         dStrcat(buf, "[");  
         dStrcat(buf, gEvalState.stack[i]->scopeNamespace->mEntryList->mPackage);  
         dStrcat(buf, "]");  
      }  
      if(gEvalState.stack[i]->scopeNamespace && gEvalState.stack[i]->scopeNamespace->mName)
      {
         dStrcat(buf, gEvalState.stack[i]->scopeNamespace->mName);
         dStrcat(buf, "::");
      }
      if(gEvalState.stack[i]->scopeName)  
         dStrcat(buf, gEvalState.stack[i]->scopeName);
   }
   Con::printf("BackTrace: %s", buf);
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_isPackage(char * x__identifier)
{
String identifier = String( x__identifier);
bool wle_returnObject;
{
   StringTableEntry name = StringTable->insert(identifier.c_str());
   {wle_returnObject =Namespace::isPackage(name);
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_activatePackage(char * x__packageName)
{
String packageName = String( x__packageName);
{
   StringTableEntry name = StringTable->insert(packageName.c_str());
   Namespace::activatePackage(name);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_deactivatePackage(char * x__packageName)
{
String packageName = String( x__packageName);
{
   StringTableEntry name = StringTable->insert(packageName.c_str());
   Namespace::deactivatePackage(name);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getPackageList(char* retval)
{
dSprintf(retval,4096,"");
const char* wle_returnObject;
{
   if( Namespace::getActivePackagesCount() == 0 )
      {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   // Determine size of return buffer
   dsize_t buffersize = 0;
   for( U32 i = 0; i < Namespace::getActivePackagesCount(); ++i )
   {
      buffersize += dStrlen(Namespace::getActivePackage(i)) + 1;
   }
   U32 maxBufferSize = buffersize + 1;
   char* returnBuffer = Con::getReturnBuffer(maxBufferSize);
   U32 returnLen = 0;
   for( U32 i = 0; i < Namespace::getActivePackagesCount(); ++i )
   {
      dSprintf(returnBuffer + returnLen, maxBufferSize - returnLen, "%s ", Namespace::getActivePackage(i));
      returnLen = dStrlen(returnBuffer);
   }
   // Trim off the last extra space
   if (returnLen > 0 && returnBuffer[returnLen - 1] == ' ')
      returnBuffer[returnLen - 1] = '\0';
   {wle_returnObject =returnBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnConsoleLogger_attach(char * x__object)
{
ConsoleLogger* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
{
   ConsoleLogger *logger = static_cast<ConsoleLogger *>( object );
   {wle_returnObject =logger->attach();
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnConsoleLogger_detach(char * x__object)
{
ConsoleLogger* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
{
   ConsoleLogger *logger = static_cast<ConsoleLogger *>( object );
   {wle_returnObject =logger->detach();
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_isClass(char * x__identifier)
{
const char* identifier = (const char*)x__identifier;
bool wle_returnObject;
{
   AbstractClassRep* rep = AbstractClassRep::findClassRep( identifier );
   {wle_returnObject =rep != NULL;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_isMemberOfClass(char * x__className, char * x__superClassName)
{
const char* className = (const char*)x__className;
const char* superClassName = (const char*)x__superClassName;
bool wle_returnObject;
{
   AbstractClassRep *pRep = AbstractClassRep::findClassRep( className );
   while (pRep)
   {
      if( !dStricmp( pRep->getClassName(), superClassName ) )
         {wle_returnObject =true;
return (S32)(wle_returnObject);}
      pRep = pRep->getParentClass();
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getDescriptionOfClass(char * x__className,  char* retval)
{
dSprintf(retval,4096,"");
const char* className = (const char*)x__className;
const char* wle_returnObject;
{
   AbstractClassRep* rep = AbstractClassRep::findClassRep( className );
   if( rep )
      {wle_returnObject =rep->getDescription();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   Con::errorf( "getDescriptionOfClass - no class called '%s'", className );
   {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getCategoryOfClass(char * x__className,  char* retval)
{
dSprintf(retval,4096,"");
const char* className = (const char*)x__className;
const char* wle_returnObject;
{
   AbstractClassRep* rep = AbstractClassRep::findClassRep( className );
   if( rep )
      {wle_returnObject =rep->getCategory();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   Con::errorf( "getCategoryOfClass - no class called '%s'", className );
   {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_dumpNetStats()
{
{
#ifdef TORQUE_NET_STATS
   for (AbstractClassRep * rep = AbstractClassRep::getClassList(); rep; rep = rep->getNextClass())
   {
      if (rep->mNetStatPack.numEvents || rep->mNetStatUnpack.numEvents || rep->mNetStatWrite.numEvents || rep->mNetStatRead.numEvents)
      {
         Con::printf("class %s net info",rep->getClassName());
         if (rep->mNetStatPack.numEvents)
            Con::printf("   packUpdate: avg (%f), min (%i), max (%i), num (%i)",
                                       F32(rep->mNetStatPack.total)/F32(rep->mNetStatPack.numEvents),
                                       rep->mNetStatPack.min,
                                       rep->mNetStatPack.max,
                                       rep->mNetStatPack.numEvents);
         if (rep->mNetStatUnpack.numEvents)
            Con::printf("   unpackUpdate: avg (%f), min (%i), max (%i), num (%i)",
                                       F32(rep->mNetStatUnpack.total)/F32(rep->mNetStatUnpack.numEvents),
                                       rep->mNetStatUnpack.min,
                                       rep->mNetStatUnpack.max,
                                       rep->mNetStatUnpack.numEvents);
         if (rep->mNetStatWrite.numEvents)
            Con::printf("   write: avg (%f), min (%i), max (%i), num (%i)",
                                       F32(rep->mNetStatWrite.total)/F32(rep->mNetStatWrite.numEvents),
                                       rep->mNetStatWrite.min,
                                       rep->mNetStatWrite.max,
                                       rep->mNetStatWrite.numEvents);
         if (rep->mNetStatRead.numEvents)
            Con::printf("   read: avg (%f), min (%i), max (%i), num (%i)",
                                       F32(rep->mNetStatRead.total)/F32(rep->mNetStatRead.numEvents),
                                       rep->mNetStatRead.min,
                                       rep->mNetStatRead.max,
                                       rep->mNetStatRead.numEvents);
         S32 sum = 0;
         for (S32 i=0; i<32; i++)
            sum  += rep->mDirtyMaskFrequency[i];
         if (sum)
         {
            Con::printf("   Mask bits:");
            for (S32 i=0; i<8; i++)
            {
               F32 avg0  = rep->mDirtyMaskFrequency[i] ? F32(rep->mDirtyMaskTotal[i])/F32(rep->mDirtyMaskFrequency[i]) : 0.0f;
               F32 avg8  = rep->mDirtyMaskFrequency[i+8] ? F32(rep->mDirtyMaskTotal[i+8])/F32(rep->mDirtyMaskFrequency[i+8]) : 0.0f;
               F32 avg16 = rep->mDirtyMaskFrequency[i+16] ? F32(rep->mDirtyMaskTotal[i+16])/F32(rep->mDirtyMaskFrequency[i+16]) : 0.0f;
               F32 avg24 = rep->mDirtyMaskFrequency[i+24] ? F32(rep->mDirtyMaskTotal[i+24])/F32(rep->mDirtyMaskFrequency[i+24]) : 0.0f;
               Con::printf("      %2i - %4i (%6.2f)     %2i - %4i (%6.2f)     %2i - %4i (%6.2f)     %2i - %4i, (%6.2f)",
                  i   ,rep->mDirtyMaskFrequency[i],avg0,
                  i+8 ,rep->mDirtyMaskFrequency[i+8],avg8,
                  i+16,rep->mDirtyMaskFrequency[i+16],avg16,
                  i+24,rep->mDirtyMaskFrequency[i+24],avg24);
            }
         }
      }
      rep->resetNetStats();
   }
#endif
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnFieldBrushObject_queryGroups(char * x__object, char * x__a2,  char* retval)
{
dSprintf(retval,4096,"");
FieldBrushObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
    // Fetch selected object.
    SimObject* pSimObject = dynamic_cast<SimObject*>( Sim::findObject( argv[2] ) );
    // Valid object?
    if ( pSimObject == NULL )
    {
        // No, so warn.
        Con::warnf("FieldBrushObject::queryFieldGroups() - Invalid SimObject!");
        {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
    }
    // Create Returnable Buffer.
    S32 maxBuffer = bufferSizes;
    char* pReturnBuffer = Con::getReturnBuffer(bufferSizes);
    char* pBuffer = pReturnBuffer;
    // Fetch Field List.
    const AbstractClassRep::FieldList& staticFields = pSimObject->getFieldList();
    // Iterate Fields.
    for( U32 fieldIndex = 0; fieldIndex < staticFields.size(); ++fieldIndex )
    {
        // Fetch Field.
        const AbstractClassRep::Field& staticField = staticFields[fieldIndex];
        // Start Group?
        if ( staticField.type == AbstractClassRep::StartGroupFieldType )
        {
            // Yes, so write-out group-name without spaces...
            char* pGroupNameNoSpaces = suppressSpaces(staticField.pGroupname);
            // Will the field fit?
            // NOTE:-   We used "-1" to include the suffix space.
            if ( (maxBuffer - (S32)dStrlen(pGroupNameNoSpaces) - 1) >= 0 )
            {
                // Yes...
                // NOTE:-   The group-name does not have the "_begingroup" suffix which should stay hidden.
                S32 charsWritten = dSprintf( pBuffer, maxBuffer, "%s ", pGroupNameNoSpaces );
                pBuffer += charsWritten;
                maxBuffer -= charsWritten;
            }
            else
            {
                // No, so warn.
                Con::warnf("FieldBrushObject::queryGroups() - Couldn't fit all groups into return string!");
                break;
            }
        }
    }
    // Strip final space.
    if ( pBuffer != pReturnBuffer )
    {
        *(pBuffer-1) = 0;
    }
    // Return Buffer.
    {wle_returnObject =pReturnBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnFieldBrushObject_queryFields(char * x__object, char * x__a2, char * x__a3,  char* retval)
{
dSprintf(retval,4096,"");
FieldBrushObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* wle_returnObject;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
    // Fetch selected object.
    SimObject* pSimObject = dynamic_cast<SimObject*>( Sim::findObject( argv[2] ) );
    // Valid object?
    if ( pSimObject == NULL )
    {
        // No, so warn.
        Con::warnf("FieldBrushObject::queryFields() - Invalid SimObject!");
        {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
    }
    // Create Returnable Buffer.
    S32 maxBuffer = bufferSizes;
    char* pReturnBuffer = Con::getReturnBuffer(bufferSizes);
    char* pBuffer = pReturnBuffer;
    // Fetch Field List.
    const AbstractClassRep::FieldList& staticFields = pSimObject->getFieldList();
    // Did we specify a groups list?
    if ( argc < 4 )
    {
        // No, so return all fields...
        // Iterate fields.
        for( U32 fieldIndex = 0; fieldIndex < staticFields.size(); ++fieldIndex )
        {
            // Fetch Field.
            const AbstractClassRep::Field& staticField = staticFields[fieldIndex];
            // Standard Field?
            if (    staticField.type != AbstractClassRep::StartGroupFieldType &&
                    staticField.type != AbstractClassRep::EndGroupFieldType &&
                    staticField.type != AbstractClassRep::DeprecatedFieldType )
            {
                // Yes, so will the field fit?
                // NOTE:-   We used "-1" to include the suffix space.
                if ( (maxBuffer - (S32)dStrlen(staticField.pFieldname) - 1) >= 0 )
                {
                    // Yes, so write-out field-name.
                    S32 charsWritten = dSprintf( pBuffer, maxBuffer, "%s ", staticField.pFieldname );
                    pBuffer += charsWritten;
                    maxBuffer -= charsWritten;
                }
                else
                {
                    // No, so warn.
                    Con::warnf("FieldBrushObject::queryFields() - Couldn't fit all fields into return string!");
                    break;
                }
            }
        }
        // Strip final space.
        if ( pBuffer != pReturnBuffer )
        {
            *(pBuffer-1) = 0;
        }
        // Return field list.
        {wle_returnObject =pReturnBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
    }
    // Yes, so filter by groups...
    // Group List.
    Vector<StringTableEntry> groups;
    // Yes, so fetch group list.
    const char* groupList =  argv[3];
    // Yes, so calculate group Count.
    const U32 groupCount = StringUnit::getUnitCount( groupList, " \t\n" );
    char tempBuf[256];
    // Iterate groups...
    for ( U32 groupIndex = 0; groupIndex < groupCount; ++groupIndex )
    {
        // Copy string element.
        dStrcpy( tempBuf, StringUnit::getUnit( groupList, groupIndex, " \t\n" ) );
        // Append internal name.
        dStrcat( tempBuf, "_begingroup" );
        // Store Group.
        groups.push_back( StringTable->insert( tempBuf ) );
    }
    // Reset Valid Group.
    bool validGroup = false;
    // Iterate fields.
    for( U32 fieldIndex = 0; fieldIndex < staticFields.size(); ++fieldIndex )
    {
        // Fetch Field.
        const AbstractClassRep::Field& staticField = staticFields[fieldIndex];
        // Handle Group Type.
        switch( staticField.type )
        {
            // Start Group.
            case AbstractClassRep::StartGroupFieldType:
            {
                // Is this group valid?
                // Iterate groups...
                for ( U32 groupIndex = 0; groupIndex < groups.size(); ++groupIndex )
                {
                    // Group selected?
                    if ( groups[groupIndex] == staticField.pFieldname )
                    {
                        // Yes, so flag as valid.
                        validGroup = true;
                        break;
                    }
                }
            } break;
            // End Group.
            case AbstractClassRep::EndGroupFieldType:
            {
                // Reset Valid Group.
                validGroup = false;
            } break;
            // Deprecated.
            case AbstractClassRep::DeprecatedFieldType:
            {
            } break;
            // Standard.
            default:
            {
                // Do we have a valid group?
                if ( validGroup )
                {
                    // Yes, so will the field fit?
                    // NOTE:-   We used "-1" to include the suffix space.
                    if ( (maxBuffer - (S32)dStrlen(staticField.pFieldname) - 1) >= 0 )
                    {
                        // Yes, so write-out field-name.
                        S32 charsWritten = dSprintf( pBuffer, maxBuffer, "%s ", staticField.pFieldname );
                        pBuffer += charsWritten;
                        maxBuffer -= charsWritten;
                    }
                    else
                    {
                        // No, so warn.
                        Con::warnf("FieldBrushObject::queryFields() - Couldn't fit all fields into return string!");
                        // HACK: Easy way to finish iterating fields.
                        fieldIndex = staticFields.size();
                        break;
                    }
                }
            } break;
        };
    }
    // Strip final space.
    if ( pBuffer != pReturnBuffer )
    {
        *(pBuffer-1) = 0;
    }
    // Return field list.
    {wle_returnObject =pReturnBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnFieldBrushObject_copyFields(char * x__object, char * x__a2, char * x__a3)
{
FieldBrushObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
    // Fetch selected object.
    SimObject* pSimObject = dynamic_cast<SimObject*>( Sim::findObject( argv[2] ) );
    // Valid object?
    if ( pSimObject == NULL )
    {
        // No, so warn.
        Con::warnf("FieldBrushObject::copyFields() - Invalid SimObject!");
        return;
    }
    // Fetch field list.
    const char* pFieldList = (argc > 3 ) ? argv[3] : NULL;
    
    // Copy Fields.
    object->copyFields( pSimObject, pFieldList );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnFieldBrushObject_pasteFields(char * x__object, char * x__a2)
{
FieldBrushObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
    // Fetch selected object.
    SimObject* pSimObject = dynamic_cast<SimObject*>( Sim::findObject( argv[2] ) );
    // Valid object?
    if ( pSimObject == NULL )
    {
        // No, so warn.
        Con::warnf("FieldBrushObject::pasteFields() - Invalid SimObject!");
        return;
    }
    // Paste Fields.
    object->pasteFields( pSimObject );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_findFirstFile(char * x__pattern, bool recurse,  char* retval)
{
dSprintf(retval,1024,"");
const char* pattern = (const char*)x__pattern;

String wle_returnObject;
{
   S32 numResults = buildFileList( pattern, recurse, false);
   // For Debugging
   //for ( S32 i = 0; i < sgFindFilesResults.size(); i++ )
   //   Con::printf( " [%i] [%s]", i, sgFindFilesResults[i].c_str() );
   sgFindFilesPos = 1;
   if(numResults < 0)
   {
      Con::errorf("findFirstFile() search directory not found: '%s'", pattern);
return;
   }
   {wle_returnObject =numResults ? sgFindFilesResults[0] : String();
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_findNextFile(char * x__pattern,  char* retval)
{
dSprintf(retval,1024,"");
const char* pattern = (const char*)x__pattern;
String wle_returnObject;
{
   if ( sgFindFilesPos + 1 > sgFindFilesResults.size() )
return;
   {wle_returnObject =sgFindFilesResults[sgFindFilesPos++];
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_getFileCount(char * x__pattern, bool recurse)
{
const char* pattern = (const char*)x__pattern;

{
   S32 numResults = buildFileList( pattern, recurse, false );
   if(numResults < 0)
   {
     return (S32)( 0);
   }
  return (S32)( numResults);
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_findFirstFileMultiExpr(char * x__pattern, bool recurse,  char* retval)
{
dSprintf(retval,1024,"");
const char* pattern = (const char*)x__pattern;

String wle_returnObject;
{
   S32 numResults = buildFileList(pattern, recurse, true);
   // For Debugging
   //for ( S32 i = 0; i < sgFindFilesResults.size(); i++ )
   //   Con::printf( " [%i] [%s]", i, sgFindFilesResults[i].c_str() );
   sgFindFilesPos = 1;
   if(numResults < 0)
   {
      Con::errorf("findFirstFileMultiExpr() search directory not found: '%s'", pattern);
return;
   }
   {wle_returnObject =numResults ? sgFindFilesResults[0] : String();
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_findNextFileMultiExpr(char * x__pattern,  char* retval)
{
dSprintf(retval,1024,"");
const char* pattern = (const char*)x__pattern;
String wle_returnObject;
{
   if ( sgFindFilesPos + 1 > sgFindFilesResults.size() )
return;
   {wle_returnObject =sgFindFilesResults[sgFindFilesPos++];
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_getFileCountMultiExpr(char * x__pattern, bool recurse)
{
const char* pattern = (const char*)x__pattern;

{
   S32 numResults = buildFileList(pattern, recurse, true);
   if(numResults < 0)
   {
     return (S32)( 0);
   }
  return (S32)( numResults);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_getFileCRC(char * x__fileName)
{
const char* fileName = (const char*)x__fileName;
{
   String cleanfilename(Torque::Path::CleanSeparators(fileName));
   Con::expandScriptFilename(sgScriptFilenameBuffer, sizeof(sgScriptFilenameBuffer), cleanfilename.c_str());
   Torque::Path givenPath(Torque::Path::CompressPath(sgScriptFilenameBuffer));
   Torque::FS::FileNodeRef fileRef = Torque::FS::GetFileNode( givenPath );
   if ( fileRef == NULL )
   {
      Con::errorf("getFileCRC() - could not access file: [%s]", givenPath.getFullPath().c_str() );
     return (S32)( -1);
   }
  return (S32)( fileRef->getChecksum());
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_isFile(char * x__fileName)
{
const char* fileName = (const char*)x__fileName;
bool wle_returnObject;
{
   String cleanfilename(Torque::Path::CleanSeparators(fileName));
   Con::expandScriptFilename(sgScriptFilenameBuffer, sizeof(sgScriptFilenameBuffer), cleanfilename.c_str());
   Torque::Path givenPath(Torque::Path::CompressPath(sgScriptFilenameBuffer));
   {wle_returnObject =Torque::FS::IsFile(givenPath);
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_IsDirectory(char * x__directory)
{
const char* directory = (const char*)x__directory;
bool wle_returnObject;
{
   String dir(Torque::Path::CleanSeparators(directory));
   Con::expandScriptFilename(sgScriptFilenameBuffer, sizeof(sgScriptFilenameBuffer), dir.c_str());
   Torque::Path givenPath(Torque::Path::CompressPath(sgScriptFilenameBuffer));
   {wle_returnObject =Torque::FS::IsDirectory( givenPath );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_isWriteableFileName(char * x__fileName)
{
const char* fileName = (const char*)x__fileName;
bool wle_returnObject;
{
   String filename(Torque::Path::CleanSeparators(fileName));
   Con::expandScriptFilename(sgScriptFilenameBuffer, sizeof(sgScriptFilenameBuffer), filename.c_str());
   Torque::Path givenPath(Torque::Path::CompressPath(sgScriptFilenameBuffer));
   Torque::FS::FileSystemRef fs = Torque::FS::GetFileSystem(givenPath);
   Torque::Path path = fs->mapTo(givenPath);
   {wle_returnObject =!Torque::FS::IsReadOnly(path);
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_startFileChangeNotifications()
{
{
   Torque::FS::StartFileChangeNotifications();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_stopFileChangeNotifications()
{
{
   Torque::FS::StopFileChangeNotifications();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getDirectoryList(char * x__path, S32 depth,  char* retval)
{
dSprintf(retval,1024,"");
const char* path = (const char*)x__path;

String wle_returnObject;
{
   // Grab the full path.
   char fullpath[1024];
   Platform::makeFullPathName(dStrcmp(path, "/") == 0 ? "" : path, fullpath, sizeof(fullpath));
   //dSprintf(fullpath, 511, "%s/%s", Platform::getWorkingDirectory(), path);
   // Append a trailing backslash if it's not present already.
   if (fullpath[dStrlen(fullpath) - 1] != '/')
   {
      S32 pos = dStrlen(fullpath);
      fullpath[pos] = '/';
      fullpath[pos + 1] = '\0';
   }
   // Dump the directories.
   Vector<StringTableEntry> directories;
   Platform::dumpDirectories(fullpath, directories, depth, true);
   if( directories.empty() )
      {wle_returnObject ="";
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
   // Grab the required buffer length.
   S32 length = 0;
   for (S32 i = 0; i < directories.size(); i++)
      length += dStrlen(directories[i]) + 1;
   // Get a return buffer.
   char* buffer = Con::getReturnBuffer(length);
   char* p = buffer;
   // Copy the directory names to the buffer.
   for (S32 i = 0; i < directories.size(); i++)
   {
      dStrcpy(p, directories[i]);
      p += dStrlen(directories[i]);
      // Tab separated.
      p[0] = '\t';
      p++;
   }
   p--;
   p[0] = '\0';
   {wle_returnObject =buffer;
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_fileSize(char * x__fileName)
{
const char* fileName = (const char*)x__fileName;
{
   Con::expandScriptFilename(sgScriptFilenameBuffer, sizeof(sgScriptFilenameBuffer), fileName);
  return (S32)( Platform::getFileSize( sgScriptFilenameBuffer ));
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_fileModifiedTime(char * x__fileName,  char* retval)
{
dSprintf(retval,1024,"");
const char* fileName = (const char*)x__fileName;
String wle_returnObject;
{
   Con::expandScriptFilename(sgScriptFilenameBuffer, sizeof(sgScriptFilenameBuffer), fileName);
   FileTime ft = {0};
   Platform::getFileTimes( sgScriptFilenameBuffer, NULL, &ft );
   Platform::LocalTime lt = {0};
   Platform::fileToLocalTime( ft, &lt );   
   
   String fileStr = Platform::localTimeToString( lt );
   
   char *buffer = Con::getReturnBuffer( fileStr.size() );
   dStrcpy( buffer, fileStr );   
   
   {wle_returnObject =buffer;
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_fileCreatedTime(char * x__fileName,  char* retval)
{
dSprintf(retval,1024,"");
const char* fileName = (const char*)x__fileName;
String wle_returnObject;
{
   Con::expandScriptFilename( sgScriptFilenameBuffer, sizeof(sgScriptFilenameBuffer), fileName );
   FileTime ft = {0};
   Platform::getFileTimes( sgScriptFilenameBuffer, &ft, NULL );
   Platform::LocalTime lt = {0};
   Platform::fileToLocalTime( ft, &lt );   
   String fileStr = Platform::localTimeToString( lt );
   char *buffer = Con::getReturnBuffer( fileStr.size() );
   dStrcpy( buffer, fileStr );  
   {wle_returnObject =buffer;
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_fileDelete(char * x__path)
{
const char* path = (const char*)x__path;
bool wle_returnObject;
{
   static char fileName[1024];
   static char sandboxFileName[1024];
   Con::expandScriptFilename( fileName, sizeof( fileName ), path );
   Platform::makeFullPathName(fileName, sandboxFileName, sizeof(sandboxFileName));
   {wle_returnObject =dFileDelete(sandboxFileName);
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_fileExt(char * x__fileName,  char* retval)
{
dSprintf(retval,1024,"");
const char* fileName = (const char*)x__fileName;
String wle_returnObject;
{
   const char *ret = dStrrchr(fileName, '.');
   if(ret)
      {wle_returnObject =ret;
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
   {wle_returnObject ="";
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_fileBase(char * x__fileName,  char* retval)
{
dSprintf(retval,1024,"");
const char* fileName = (const char*)x__fileName;
String wle_returnObject;
{
   S32 pathLen = dStrlen( fileName );
   FrameTemp<char> szPathCopy( pathLen + 1);
   dStrcpy( szPathCopy, fileName );
   forwardslash( szPathCopy );
   const char *path = dStrrchr(szPathCopy, '/');
   if(!path)
      path = szPathCopy;
   else
      path++;
   char *ret = Con::getReturnBuffer(dStrlen(path) + 1);
   dStrcpy(ret, path);
   char *ext = dStrrchr(ret, '.');
   if(ext)
      *ext = 0;
   {wle_returnObject =ret;
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_fileName(char * x__fileName,  char* retval)
{
dSprintf(retval,1024,"");
const char* fileName = (const char*)x__fileName;
String wle_returnObject;
{
   S32 pathLen = dStrlen( fileName );
   FrameTemp<char> szPathCopy( pathLen + 1);
   dStrcpy( szPathCopy, fileName );
   forwardslash( szPathCopy );
   const char *name = dStrrchr(szPathCopy, '/');
   if(!name)
      name = szPathCopy;
   else
      name++;
   char *ret = Con::getReturnBuffer(dStrlen(name));
   dStrcpy(ret, name);
   {wle_returnObject =ret;
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_filePath(char * x__fileName,  char* retval)
{
dSprintf(retval,1024,"");
const char* fileName = (const char*)x__fileName;
String wle_returnObject;
{
   S32 pathLen = dStrlen( fileName );
   FrameTemp<char> szPathCopy( pathLen + 1);
   dStrcpy( szPathCopy, fileName );
   forwardslash( szPathCopy );
   const char *path = dStrrchr(szPathCopy, '/');
   if(!path)
      {wle_returnObject ="";
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
   U32 len = path - (char*)szPathCopy;
   char *ret = Con::getReturnBuffer(len + 1);
   dStrncpy(ret, szPathCopy, len);
   ret[len] = 0;
   {wle_returnObject =ret;
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getWorkingDirectory(char* retval)
{
dSprintf(retval,1024,"");
String wle_returnObject;
{
   {wle_returnObject =Platform::getCurrentDirectory();
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_makeFullPath(char * x__path, char * x__cwd,  char* retval)
{
dSprintf(retval,1024,"");
const char* path = (const char*)x__path;
const char* cwd = (const char*)x__cwd;
String wle_returnObject;
{
   char *buf = Con::getReturnBuffer(512);
   Platform::makeFullPathName(path, buf, 512, dStrlen(cwd) > 1 ? cwd : NULL);
   {wle_returnObject =buf;
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_makeRelativePath(char * x__path, char * x__to,  char* retval)
{
dSprintf(retval,1024,"");
const char* path = (const char*)x__path;
const char* to = (const char*)x__to;
String wle_returnObject;
{
   {wle_returnObject =Platform::makeRelativePathName( path, dStrlen(to) > 1 ? to : NULL );
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_pathConcat(char * x__path, char * x__file,  char* retval)
{
dSprintf(retval,1024,"");
const char* path = (const char*)x__path;
const char* file = (const char*)x__file;
String wle_returnObject;
{
   char *buf = Con::getReturnBuffer(1024);
   Platform::makeFullPathName(file, buf, 1024, path);
   {wle_returnObject =buf;
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getExecutableName(char* retval)
{
dSprintf(retval,1024,"");
String wle_returnObject;
{
   {wle_returnObject =Platform::getExecutableName();
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getMainDotCsDir(char* retval)
{
dSprintf(retval,1024,"");
String wle_returnObject;
{
   {wle_returnObject =Platform::getMainDotCsDir();
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_openFolder(char * x__path)
{
const char* path = (const char*)x__path;
{
   Platform::openFolder( path );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_openFile(char * x__file)
{
const char* file = (const char*)x__file;
{
   Platform::openFile( file );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_pathCopy(char * x__fromFile, char * x__toFile, bool noOverwrite)
{
const char* fromFile = (const char*)x__fromFile;
const char* toFile = (const char*)x__toFile;

bool wle_returnObject;
{
   char qualifiedFromFile[ 2048 ];
   char qualifiedToFile[ 2048 ];
   
   Platform::makeFullPathName( fromFile, qualifiedFromFile, sizeof( qualifiedFromFile ) );
   Platform::makeFullPathName( toFile, qualifiedToFile, sizeof( qualifiedToFile ) );
   {wle_returnObject =dPathCopy( qualifiedFromFile, qualifiedToFile, noOverwrite );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getCurrentDirectory(char* retval)
{
dSprintf(retval,1024,"");
String wle_returnObject;
{
   {wle_returnObject =Platform::getCurrentDirectory();
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_setCurrentDirectory(char * x__path)
{
const char* path = (const char*)x__path;
bool wle_returnObject;
{
   {wle_returnObject =Platform::setCurrentDirectory( StringTable->insert( path ) );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_createPath(char * x__path)
{
const char* path = (const char*)x__path;
bool wle_returnObject;
{
   static char pathName[1024];
   Con::expandScriptFilename( pathName, sizeof( pathName ), path );
   {wle_returnObject =Platform::createPath( pathName );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPersistenceManager_deleteObjectsFromFile(char * x__object, char * x__a2)
{
PersistenceManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   // Delete Objects.
   object->deleteObjectsFromFile( argv[2] );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPersistenceManager_setDirty(char * x__object, char * x__a2, char * x__a3)
{
PersistenceManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   SimObject *dirtyObject = NULL;
   if (argv[2][0])
   {
      if (!Sim::findObject(argv[2], dirtyObject))
      {
         Con::printf("%s(): Invalid SimObject: %s", argv[0], argv[2]);
         return;
      }
   }
   
   // Prevent ourselves from shooting us in the foot.
   
   if( dirtyObject == Sim::getRootGroup() )
   {
      Con::errorf( "%s(): Cannot save RootGroup", argv[ 0 ] );
      return;
   }
   if (dirtyObject)
   {
      if (argc == 4 && argv[3][0])
         object->setDirty(dirtyObject, argv[3]);
      else
         object->setDirty(dirtyObject);
   }
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPersistenceManager_removeDirty(char * x__object, char * x__a2)
{
PersistenceManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   SimObject *dirtyObject = NULL;
   if (argv[2][0])
   {
      if (!Sim::findObject(argv[2], dirtyObject))
      {
         Con::printf("%s(): Invalid SimObject: %s", argv[0], argv[2]);
         return;
      }
   }
   if (dirtyObject)
      object->removeDirty(dirtyObject);
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPersistenceManager_isDirty(char * x__object, char * x__a2)
{
PersistenceManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
bool wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   SimObject *dirtyObject = NULL;
   if (argv[2][0])
   {
      if (!Sim::findObject(argv[2], dirtyObject))
      {
         Con::printf("%s(): Invalid SimObject: %s", argv[0], argv[2]);
         {wle_returnObject =false;
return (S32)(wle_returnObject);}
      }
   }
   if (dirtyObject)
      {wle_returnObject =object->isDirty(dirtyObject);
return (S32)(wle_returnObject);}
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPersistenceManager_hasDirty(char * x__object)
{
PersistenceManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
{
   {wle_returnObject =object->hasDirty();
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPersistenceManager_getDirtyObjectCount(char * x__object)
{
PersistenceManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
  return (S32)( object->getDirtyList().size());
}
}
;
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPersistenceManager_getDirtyObject(char * x__object, char * x__a2)
{
PersistenceManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   const S32 index = dAtoi( argv[2] );
   if ( index < 0 || index >= object->getDirtyList().size() )
   {
      Con::warnf( "PersistenceManager::getDirtyObject() - Index (%s) out of range.", argv[2] );
     return (S32)( 0);
   }
   // Fetch Object.
   const PersistenceManager::DirtyObject& dirtyObject = object->getDirtyList()[index];
   // Return Id.
  return (S32)( ( dirtyObject.getObject() ) ? dirtyObject.getObject()->getId() : 0);
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPersistenceManager_listDirty(char * x__object)
{
PersistenceManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   const PersistenceManager::DirtyList dirtyList = object->getDirtyList();
   for(U32 i = 0; i < dirtyList.size(); i++)
   {
      const PersistenceManager::DirtyObject& dirtyObject = dirtyList[i];
      if (dirtyObject.isNull())
         continue;
      SimObject *obj = dirtyObject.getObject();
      bool isSet = dynamic_cast<SimSet *>(obj) != 0;
      const char *name = obj->getName();
      if (name)
      {
         Con::printf("   %d,\"%s\": %s %s %s", obj->getId(), name,
         obj->getClassName(), dirtyObject.fileName, isSet ? "(g)":"");
      }
      else
      {
         Con::printf("   %d: %s %s, %s", obj->getId(), obj->getClassName(),
         dirtyObject.fileName, isSet ? "(g)" : "");
      }
   }
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPersistenceManager_saveDirty(char * x__object)
{
PersistenceManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
{
   {wle_returnObject =object->saveDirty();
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPersistenceManager_saveDirtyObject(char * x__object, char * x__a2)
{
PersistenceManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
bool wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   SimObject *dirtyObject = NULL;
   if (argv[2][0])
   {
      if (!Sim::findObject(argv[2], dirtyObject))
      {
         Con::printf("%s(): Invalid SimObject: %s", argv[0], argv[2]);
         {wle_returnObject =false;
return (S32)(wle_returnObject);}
      }
   }
   if (dirtyObject)
      {wle_returnObject =object->saveDirtyObject(dirtyObject);
return (S32)(wle_returnObject);}
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPersistenceManager_clearAll(char * x__object)
{
PersistenceManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->clearAll();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPersistenceManager_removeObjectFromFile(char * x__object, char * x__a2, char * x__a3)
{
PersistenceManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   SimObject *dirtyObject = NULL;
   if (argv[2][0])
   {
      if (!Sim::findObject(argv[2], dirtyObject))
      {
         Con::printf("%s(): Invalid SimObject: %s", argv[0], argv[2]);
         return;
      }
   }
   if (dirtyObject)
   {
      if (argc == 4 && argv[3][0])
         object->removeObjectFromFile(dirtyObject, argv[3]);
      else
         object->removeObjectFromFile(dirtyObject);
   }
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPersistenceManager_removeField(char * x__object, char * x__a2, char * x__a3)
{
PersistenceManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   SimObject *dirtyObject = NULL;
   if (argv[2][0])
   {
      if (!Sim::findObject(argv[2], dirtyObject))
      {
         Con::printf("%s(): Invalid SimObject: %s", argv[0], argv[2]);
         return;
      }
   }
   if (dirtyObject)
   {
      if (argv[3][0])
         object->addRemoveField(dirtyObject, argv[3]);
   }
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__expandFilename(char * x__a1,  char* retval)
{
dSprintf(retval,4096,"");
const char* a1 = (const char*)x__a1;
const char* wle_returnObject;
{
S32 argc = 2;
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
const char** argv = &arguments[0];
{
   
   char* ret = Con::getReturnBuffer( 1024 );
   Con::expandScriptFilename(ret, 1024, argv[1]);
   {wle_returnObject =ret;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn__isObject(char * x__a1)
{
const char* a1 = (const char*)x__a1;
bool wle_returnObject;
{
S32 argc = 2;
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
const char** argv = &arguments[0];
{
   
   if (!dStrcmp(argv[1], "0") || !dStrcmp(argv[1], ""))
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   else
      {wle_returnObject =(Sim::findObject(argv[1]) != NULL);
return (S32)(wle_returnObject);}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn__spawnObject(char * x__a1, char * x__a2, char * x__a3, char * x__a4, char * x__a5)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
{
S32 argc = 6;
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
if (argc>=5)
arguments.push_back(a4);
if (argc>=6)
arguments.push_back(a5);
const char** argv = &arguments[0];
{
   String spawnClass(argv[1]);
   String spawnDataBlock;
   String spawnName;
   String spawnProperties;
   String spawnScript;
   if (argc >= 3)
      spawnDataBlock = argv[2];
   if (argc >= 4)
      spawnName = argv[3];
   if (argc >= 5)
      spawnProperties = argv[4];
   if (argc >= 6)
      spawnScript = argv[5];
   SimObject* spawnObject = Sim::spawnObject(spawnClass, spawnDataBlock, spawnName, spawnProperties, spawnScript);
   if (spawnObject)
     return (S32)( spawnObject->getId());
   else
     return (S32)( -1);
}
arguments.clear();
}
;
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn__schedule(char * x__a1, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10, char * x__a11, char * x__a12, char * x__a13, char * x__a14, char * x__a15, char * x__a16, char * x__a17, char * x__a18, char * x__a19)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* a11 = (const char*)x__a11;
const char* a12 = (const char*)x__a12;
const char* a13 = (const char*)x__a13;
const char* a14 = (const char*)x__a14;
const char* a15 = (const char*)x__a15;
const char* a16 = (const char*)x__a16;
const char* a17 = (const char*)x__a17;
const char* a18 = (const char*)x__a18;
const char* a19 = (const char*)x__a19;
{
S32 argc = 20;
if (dStrlen(a19)==0)
if (dStrlen(a18)==0)
if (dStrlen(a17)==0)
if (dStrlen(a16)==0)
if (dStrlen(a15)==0)
if (dStrlen(a14)==0)
if (dStrlen(a13)==0)
if (dStrlen(a12)==0)
if (dStrlen(a11)==0)
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
else
argc=12;
else
argc=13;
else
argc=14;
else
argc=15;
else
argc=16;
else
argc=17;
else
argc=18;
else
argc=19;
else
argc=20;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
if (argc>=5)
arguments.push_back(a4);
if (argc>=6)
arguments.push_back(a5);
if (argc>=7)
arguments.push_back(a6);
if (argc>=8)
arguments.push_back(a7);
if (argc>=9)
arguments.push_back(a8);
if (argc>=10)
arguments.push_back(a9);
if (argc>=11)
arguments.push_back(a10);
if (argc>=12)
arguments.push_back(a11);
if (argc>=13)
arguments.push_back(a12);
if (argc>=14)
arguments.push_back(a13);
if (argc>=15)
arguments.push_back(a14);
if (argc>=16)
arguments.push_back(a15);
if (argc>=17)
arguments.push_back(a16);
if (argc>=18)
arguments.push_back(a17);
if (argc>=19)
arguments.push_back(a18);
if (argc>=20)
arguments.push_back(a19);
const char** argv = &arguments[0];
{
   U32 timeDelta = U32(dAtof(argv[1]));
   SimObject *refObject = Sim::findObject(argv[2]);
   if(!refObject)
   {
      if(argv[2][0] != '0')
        return (S32)( 0);
      refObject = Sim::getRootGroup();
   }
   SimConsoleEvent *evt = new SimConsoleEvent(argc - 3, argv + 3, false);
   S32 ret = Sim::postEvent(refObject, evt, Sim::getCurrentTime() + timeDelta);
   // #ifdef DEBUG
   //    Con::printf("ref %s schedule(%s) = %d", argv[2], argv[3], ret);
   //    Con::executef( "backtrace");
   // #endif
  return (S32)( ret);
}
arguments.clear();
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__getUniqueName(char * x__a1,  char* retval)
{
dSprintf(retval,4096,"");
const char* a1 = (const char*)x__a1;
const char* wle_returnObject;
{
S32 argc = 2;
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
const char** argv = &arguments[0];
{
   String outName = Sim::getUniqueName( argv[1] );
   
   if ( outName.isEmpty() )
      {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   char *buffer = Con::getReturnBuffer( outName.size() );
   dStrcpy( buffer, outName );
   {wle_returnObject =buffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__getUniqueInternalName(char * x__a1, char * x__a2, char * x__a3,  char* retval)
{
dSprintf(retval,4096,"");
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* wle_returnObject;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   SimSet *set;
   if ( !Sim::findObject( argv[2], set ) )
   {
      Con::errorf( "getUniqueInternalName() - invalid parameter for SimSet." );
      {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   }
   String outName = Sim::getUniqueInternalName( argv[1], set, dAtob(argv[3]) );
   if ( outName.isEmpty() )
      {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   char *buffer = Con::getReturnBuffer( outName.size() );
   dStrcpy( buffer, outName );
   {wle_returnObject =buffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn__isValidObjectName(char * x__a1)
{
const char* a1 = (const char*)x__a1;
bool wle_returnObject;
{
S32 argc = 2;
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
const char** argv = &arguments[0];
{
   const char* name = argv[ 1 ];
   {wle_returnObject =Sim::isValidObjectName( name );
return (S32)(wle_returnObject);}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_SimDataBlock_reloadOnLocalClient(char * x__object)
{
SimDataBlock* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   // Make sure we're running a local client.
   GameConnection* localClient = GameConnection::getLocalClientConnection();
   if( !localClient )
      return;
   // Do an in-place pack/unpack/preload.
   if( !object->preload( true, NetConnection::getErrorBuffer() ) )
   {
      Con::errorf( NetConnection::getErrorBuffer() );
      return;
   }
   U8 buffer[ 16384 ];
   BitStream stream( buffer, 16384 );
   object->packData( &stream );
   stream.setPosition(0);
   object->unpackData( &stream );
   if( !object->preload( false, NetConnection::getErrorBuffer() ) )
   {
      Con::errorf( NetConnection::getErrorBuffer() );
      return;
   }
   // Trigger a post-apply so that change notifications respond.
   object->inspectPostApply();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_preloadClientDataBlocks()
{
{
   // we go from last to first because we cut 'n pasted the loop from deleteDataBlocks
   SimGroup *grp = Sim::getDataBlockGroup();
   String errorStr;
   for(S32 i = grp->size() - 1; i >= 0; i--)
   {
      AssertFatal(dynamic_cast<SimDataBlock*>((*grp)[i]), "Doh! non-datablock in datablock group!");
      SimDataBlock *obj = (SimDataBlock*)(*grp)[i];
      if (!obj->preload(false, errorStr))
         Con::errorf("Failed to preload client datablock, %s: %s", obj->getName(), errorStr.c_str());
   }
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_deleteDataBlocks()
{
{
   // delete from last to first:
   SimGroup *grp = Sim::getDataBlockGroup();
   grp->deleteAllObjects();
   SimDataBlock::sNextObjectId = DataBlockObjectIdFirst;
   SimDataBlock::sNextModifiedKey = 0;
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimObject_call(char * x__object, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10, char * x__a11, char * x__a12, char * x__a13, char * x__a14, char * x__a15, char * x__a16, char * x__a17, char * x__a18, char * x__a19,  char* retval)
{
dSprintf(retval,4096,"");
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* a11 = (const char*)x__a11;
const char* a12 = (const char*)x__a12;
const char* a13 = (const char*)x__a13;
const char* a14 = (const char*)x__a14;
const char* a15 = (const char*)x__a15;
const char* a16 = (const char*)x__a16;
const char* a17 = (const char*)x__a17;
const char* a18 = (const char*)x__a18;
const char* a19 = (const char*)x__a19;
const char* wle_returnObject;
{
S32 argc = 20;
if (dStrlen(a19)==0)
if (dStrlen(a18)==0)
if (dStrlen(a17)==0)
if (dStrlen(a16)==0)
if (dStrlen(a15)==0)
if (dStrlen(a14)==0)
if (dStrlen(a13)==0)
if (dStrlen(a12)==0)
if (dStrlen(a11)==0)
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
else
argc=12;
else
argc=13;
else
argc=14;
else
argc=15;
else
argc=16;
else
argc=17;
else
argc=18;
else
argc=19;
else
argc=20;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
if (argc>5)
arguments.push_back(a5);
if (argc>6)
arguments.push_back(a6);
if (argc>7)
arguments.push_back(a7);
if (argc>8)
arguments.push_back(a8);
if (argc>9)
arguments.push_back(a9);
if (argc>10)
arguments.push_back(a10);
if (argc>11)
arguments.push_back(a11);
if (argc>12)
arguments.push_back(a12);
if (argc>13)
arguments.push_back(a13);
if (argc>14)
arguments.push_back(a14);
if (argc>15)
arguments.push_back(a15);
if (argc>16)
arguments.push_back(a16);
if (argc>17)
arguments.push_back(a17);
if (argc>18)
arguments.push_back(a18);
if (argc>19)
arguments.push_back(a19);
const char** argv = &arguments[0];
{
   argv[1] = argv[2];
   {wle_returnObject =Con::execute( object, argc - 1, argv + 1 );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimObject_schedule(char * x__object, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10, char * x__a11, char * x__a12, char * x__a13, char * x__a14, char * x__a15, char * x__a16, char * x__a17, char * x__a18, char * x__a19)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* a11 = (const char*)x__a11;
const char* a12 = (const char*)x__a12;
const char* a13 = (const char*)x__a13;
const char* a14 = (const char*)x__a14;
const char* a15 = (const char*)x__a15;
const char* a16 = (const char*)x__a16;
const char* a17 = (const char*)x__a17;
const char* a18 = (const char*)x__a18;
const char* a19 = (const char*)x__a19;
{
S32 argc = 20;
if (dStrlen(a19)==0)
if (dStrlen(a18)==0)
if (dStrlen(a17)==0)
if (dStrlen(a16)==0)
if (dStrlen(a15)==0)
if (dStrlen(a14)==0)
if (dStrlen(a13)==0)
if (dStrlen(a12)==0)
if (dStrlen(a11)==0)
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
else
argc=12;
else
argc=13;
else
argc=14;
else
argc=15;
else
argc=16;
else
argc=17;
else
argc=18;
else
argc=19;
else
argc=20;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
if (argc>5)
arguments.push_back(a5);
if (argc>6)
arguments.push_back(a6);
if (argc>7)
arguments.push_back(a7);
if (argc>8)
arguments.push_back(a8);
if (argc>9)
arguments.push_back(a9);
if (argc>10)
arguments.push_back(a10);
if (argc>11)
arguments.push_back(a11);
if (argc>12)
arguments.push_back(a12);
if (argc>13)
arguments.push_back(a13);
if (argc>14)
arguments.push_back(a14);
if (argc>15)
arguments.push_back(a15);
if (argc>16)
arguments.push_back(a16);
if (argc>17)
arguments.push_back(a17);
if (argc>18)
arguments.push_back(a18);
if (argc>19)
arguments.push_back(a19);
const char** argv = &arguments[0];
{
   U32 timeDelta = U32(dAtof(argv[2]));
   argv[2] = argv[3];
   argv[3] = argv[1];
   SimConsoleEvent *evt = new SimConsoleEvent(argc - 2, argv + 2, true);
   S32 ret = Sim::postEvent(object, evt, Sim::getCurrentTime() + timeDelta);
   // #ifdef DEBUG
   //    Con::printf("obj %s schedule(%s) = %d", argv[3], argv[2], ret);
   //    Con::executef( "backtrace");
   // #endif
  return (S32)( ret);
}
}
;
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_SimObject_isMethod(char * x__object, char * x__methodName)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* methodName = (const char*)x__methodName;
bool wle_returnObject;
{
   {wle_returnObject =object->isMethod( methodName );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_SimObject_getClassNamespace(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->getClassNamespace();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_SimObject_getSuperClassNamespace(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->getSuperClassNamespace();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_SimObject_setClassNamespace(char * x__object, char * x__name)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* name = (const char*)x__name;
{
   object->setClassNamespace( name );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_SimObject_setSuperClassNamespace(char * x__object, char * x__name)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* name = (const char*)x__name;
{
   object->setSuperClassNamespace( name );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_SimObject_isExpanded(char * x__object)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isExpanded();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_SimObject_setIsExpanded(char * x__object, bool state)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setExpanded( state );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_SimObject_getFilename(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->getFilename();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_SimObject_setFilename(char * x__object, char * x__fileName)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* fileName = (const char*)x__fileName;
{
   return object->setFilename( fileName );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_SimObject_getDeclarationLine(char * x__object)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getDeclarationLine());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_SimObject_assignFieldsFrom(char * x__object, char * x__fromObject)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
SimObject* fromObject; Sim::findObject(x__fromObject, fromObject ); 
{
   if( fromObject )
      object->assignFieldsFrom( fromObject );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_SimObject_getCanSave(char * x__object)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->getCanSave();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_SimObject_setCanSave(char * x__object, bool value)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setCanSave( value );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_SimObject_dumpMethods(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
ArrayObject* wle_returnObject;
{
   Namespace *ns = object->getNamespace();
   if( !ns )
      {wle_returnObject =0;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
      
   ArrayObject* dictionary = new ArrayObject();
   dictionary->registerObject();
   
   VectorPtr<Namespace::Entry *> vec(__FILE__, __LINE__);
   ns->getEntryList(&vec);
   for(Vector< Namespace::Entry* >::iterator j = vec.begin(); j != vec.end(); j++)
   {
      Namespace::Entry* e = *j;
      if( e->mType < 0 )
         continue;
         
      StringBuilder str;
      
      str.append( String::ToString( e->mMinArgs ) );
      str.append( '\n' );
      str.append( String::ToString( e->mMaxArgs ) );
      str.append( '\n' );
      str.append( e->getPrototypeString() );
      str.append( '\n' );
      if( e->mCode && e->mCode->fullPath )
         str.append( e->mCode->fullPath );
      str.append( '\n' );
      if( e->mCode )
         str.append( String::ToString( e->mFunctionLineNumber ) );
      str.append( '\n' );
      String docs = e->getDocString();
      if( !docs.isEmpty() )
         str.append( docs );
      dictionary->push_back( e->mFunctionName, str.end() );
   }
   
   {wle_returnObject =dictionary;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_SimObject_save(char * x__object, char * x__fileName, bool selectedOnly, char * x__preAppendString)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* fileName = (const char*)x__fileName;

const char* preAppendString = (const char*)x__preAppendString;
bool wle_returnObject;
{
   {wle_returnObject =object->save( fileName, selectedOnly, preAppendString );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_SimObject_getClassName(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   const char *ret = object->getClassName();
   {wle_returnObject =ret ? ret : "";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_SimObject_isField(char * x__object, char * x__fieldName)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* fieldName = (const char*)x__fieldName;
bool wle_returnObject;
{
   {wle_returnObject =object->isField( fieldName );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_SimObject_getFieldValue(char * x__object, char * x__fieldName, S32 index,  char* retval)
{
dSprintf(retval,4096,"");
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* fieldName = (const char*)x__fieldName;

const char* wle_returnObject;
{
   char fieldNameBuffer[ 1024 ];
   char arrayIndexBuffer[ 64 ];
   
   // Parse out index if the field is given in the form of 'name[index]'.
   
   const char* arrayIndex = NULL;
   const U32 nameLen = dStrlen( fieldName );
   if( fieldName[ nameLen - 1 ] == ']' )
   {
      const char* leftBracket = dStrchr( fieldName, '[' );
      const char* rightBracket = &fieldName[ nameLen - 1 ];
      
      const U32 fieldNameLen = getMin( U32( leftBracket - fieldName ), sizeof( fieldNameBuffer ) - 1 );
      const U32 arrayIndexLen = getMin( U32( rightBracket - leftBracket - 1 ), sizeof( arrayIndexBuffer ) - 1 );
      
      dMemcpy( fieldNameBuffer, fieldName, fieldNameLen );
      dMemcpy( arrayIndexBuffer, leftBracket + 1, arrayIndexLen );
      
      fieldNameBuffer[ fieldNameLen ] = '\0';
      arrayIndexBuffer[ arrayIndexLen ] = '\0';
      
      fieldName = fieldNameBuffer;
      arrayIndex = arrayIndexBuffer;
   }
   fieldName = StringTable->insert( fieldName );
   
   if( index != -1 )
   {
      dSprintf( arrayIndexBuffer, sizeof( arrayIndexBuffer ), "%i", index );
      arrayIndex = arrayIndexBuffer;
   }
   
   {wle_returnObject =object->getDataField( fieldName, arrayIndex );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_SimObject_setFieldValue(char * x__object, char * x__fieldName, char * x__value, S32 index)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* fieldName = (const char*)x__fieldName;
const char* value = (const char*)x__value;

bool wle_returnObject;
{
   char fieldNameBuffer[ 1024 ];
   char arrayIndexBuffer[ 64 ];
   
   // Parse out index if the field is given in the form of 'name[index]'.
   
   const char* arrayIndex = NULL;
   const U32 nameLen = dStrlen( fieldName );
   if( fieldName[ nameLen - 1 ] == ']' )
   {
      const char* leftBracket = dStrchr( fieldName, '[' );
      const char* rightBracket = &fieldName[ nameLen - 1 ];
      
      const U32 fieldNameLen = getMin( U32( leftBracket - fieldName ), sizeof( fieldNameBuffer ) - 1 );
      const U32 arrayIndexLen = getMin( U32( rightBracket - leftBracket - 1 ), sizeof( arrayIndexBuffer ) - 1 );
      
      dMemcpy( fieldNameBuffer, fieldName, fieldNameLen );
      dMemcpy( arrayIndexBuffer, leftBracket + 1, arrayIndexLen );
      
      fieldNameBuffer[ fieldNameLen ] = '\0';
      arrayIndexBuffer[ arrayIndexLen ] = '\0';
      
      fieldName = fieldNameBuffer;
      arrayIndex = arrayIndexBuffer;
   }
   fieldName = StringTable->insert( fieldName );
   if( index != -1 )
   {
      dSprintf( arrayIndexBuffer, sizeof( arrayIndexBuffer ), "%i", index );
      arrayIndex = arrayIndexBuffer;
   }
   object->setDataField( fieldName, arrayIndex, value );
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_SimObject_getFieldType(char * x__object, char * x__fieldName,  char* retval)
{
dSprintf(retval,4096,"");
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* fieldName = (const char*)x__fieldName;
const char* wle_returnObject;
{
   U32 typeID = object->getDataFieldType( StringTable->insert( fieldName ), NULL );
   ConsoleBaseType* type = ConsoleBaseType::getType( typeID );
   if( type )
      {wle_returnObject =type->getTypeName();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_SimObject_setFieldType(char * x__object, char * x__fieldName, char * x__type)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* fieldName = (const char*)x__fieldName;
const char* type = (const char*)x__type;
{
   object->setDataFieldType( type, StringTable->insert( fieldName ), NULL );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_SimObject_dumpClassHierarchy(char * x__object)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->dumpClassHierarchy();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_SimObject_isMemberOfClass(char * x__object, char * x__className)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* className = (const char*)x__className;
bool wle_returnObject;
{
   AbstractClassRep* pRep = object->getClassRep();
   while(pRep)
   {
      if( !dStricmp(pRep->getClassName(), className ) )
      {
         //matches
         {wle_returnObject =true;
return (S32)(wle_returnObject);}
      }
      pRep	=	pRep->getParentClass();
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_SimObject_isInNamespaceHierarchy(char * x__object, char * x__name)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* name = (const char*)x__name;
bool wle_returnObject;
{
   Namespace* nspace = object->getNamespace();
      
   while( nspace && dStricmp( nspace->mName, name ) != 0 )
      nspace = nspace->mParent;
      
   {wle_returnObject =( nspace != NULL );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_SimObject_delete(char * x__object)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->deleteObject();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_SimObject_getDynamicFieldCount(char * x__object)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   S32 count = 0;
   SimFieldDictionary* fieldDictionary = object->getFieldDictionary();
   for (SimFieldDictionaryIterator itr(fieldDictionary); *itr; ++itr)
      count++;
  return (S32)( count);
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_SimObject_getDynamicField(char * x__object, int index,  char* retval)
{
dSprintf(retval,4096,"");
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   SimFieldDictionary* fieldDictionary = object->getFieldDictionary();
   SimFieldDictionaryIterator itr(fieldDictionary);
   for (S32 i = 0; i < index; i++)
   {
      if (!(*itr))
      {
         Con::warnf("Invalid dynamic field index passed to SimObject::getDynamicField!");
         {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
      }
      ++itr;
   }
   char* buffer = Con::getReturnBuffer(256);
   if (*itr)
   {
      SimFieldDictionary::Entry* entry = *itr;
      dSprintf(buffer, 256, "%s\t%s", entry->slotName, entry->value);
      {wle_returnObject =buffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   }
   Con::warnf("Invalid dynamic field index passed to SimObject::getDynamicField!");
   {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_SimObject_getFieldCount(char * x__object)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   const AbstractClassRep::FieldList &list = object->getFieldList();
   const AbstractClassRep::Field* f;
   U32 numDummyEntries = 0;
   for(int i = 0; i < list.size(); i++)
   {
      f = &list[i];
      // The special field types do not need to be counted.
      if ( f->type >= AbstractClassRep::ARCFirstCustomField )
         numDummyEntries++;
   }
  return (S32)( list.size() - numDummyEntries);
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_SimObject_getField(char * x__object, int index,  char* retval)
{
dSprintf(retval,4096,"");
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   const AbstractClassRep::FieldList &list = object->getFieldList();
   if( ( index < 0 ) || ( index >= list.size() ) )
      {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   const AbstractClassRep::Field* f;
   S32 currentField = 0;
   for ( U32 i = 0; i < list.size() && currentField <= index; i++ )
   {
      f = &list[i];
      // The special field types can be skipped.
      if ( f->type >= AbstractClassRep::ARCFirstCustomField )
         continue;
      if(currentField == index)
         {wle_returnObject =f->pFieldname;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
      currentField++;
   }
   // if we found nada, return nada.
   {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimObject_dumpGroupHierarchy(char * x__object)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->dumpGroupHierarchy();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimObject_isChildOfGroup(char * x__object, char * x__group)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
SimGroup* group; Sim::findObject(x__group, group ); 
bool wle_returnObject;
{
   {wle_returnObject =object->isChildOfGroup( group );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimObject_isSelected(char * x__object)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isSelected();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimObject_setIsSelected(char * x__object, bool state)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setSelected( state );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimObject_assignPersistentId(char * x__object)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->getOrCreatePersistentId();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimObject_isEditorOnly(char * x__object)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isEditorOnly();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimObject_setEditorOnly(char * x__object, bool value)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setEditorOnly( value );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimObject_isNameChangeAllowed(char * x__object)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isNameChangeAllowed();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimObject_setNameChangeAllowed(char * x__object, bool value)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setNameChangeAllowed( value );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimObject_clone(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
SimObject* wle_returnObject;
{
   {wle_returnObject =object->clone();
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimObject_deepClone(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
SimObject* wle_returnObject;
{
   {wle_returnObject =object->deepClone();
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimObject_setLocked(char * x__object, bool value)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setLocked( value );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimObject_setHidden(char * x__object, bool value)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setHidden( value );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimObject_dump(char * x__object, bool detailed)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   Con::printf( "Class: %s", object->getClassName() );
   
   const AbstractClassRep::FieldList &list = object->getFieldList();
   char expandedBuffer[4096];
   Con::printf( "Static Fields:" );
   Vector<const AbstractClassRep::Field *> flist(__FILE__, __LINE__);
   for(U32 i = 0; i < list.size(); i++)
      flist.push_back(&list[i]);
   dQsort(flist.address(),flist.size(),sizeof(AbstractClassRep::Field *),compareFields);
   for(Vector<const AbstractClassRep::Field *>::iterator itr = flist.begin(); itr != flist.end(); itr++)
   {
      const AbstractClassRep::Field* f = *itr;
      // The special field types can be skipped.
      if ( f->type >= AbstractClassRep::ARCFirstCustomField )
         continue;
      for(U32 j = 0; S32(j) < f->elementCount; j++)
      {
         // [neo, 07/05/2007 - #3000]
         // Some objects use dummy vars and projected fields so make sure we call the get functions 
         //const char *val = Con::getData(f->type, (void *) (((const char *)object) + f->offset), j, f->table, f->flag);                          
         const char *val = (*f->getDataFn)( object, Con::getData(f->type, (void *) (((const char *)object) + f->offset), j, f->table, f->flag) );// + typeSizes[fld.type] * array1));
         
         ConsoleBaseType* conType = ConsoleBaseType::getType( f->type );
         const char* conTypeName = "<unknown>";
         if( conType )
            conTypeName = conType->getTypeClassName();
         if( !val /*|| !*val*/ )
            continue;
         if( f->elementCount == 1 )
            dSprintf( expandedBuffer, sizeof( expandedBuffer ), "  %s %s = \"", conTypeName, f->pFieldname );
         else
            dSprintf( expandedBuffer, sizeof( expandedBuffer ), "  %s %s[ %d ] = \"", conTypeName, f->pFieldname, j );
         expandEscape( expandedBuffer + dStrlen(expandedBuffer), val);
         Con::printf( "%s\"", expandedBuffer );
         
         if( detailed && f->pFieldDocs && f->pFieldDocs[ 0 ] )
            Con::printf( "    %s", f->pFieldDocs );
      }
   }
   Con::printf( "Dynamic Fields:" );
   if(object->getFieldDictionary())
      object->getFieldDictionary()->printFields(object);
   Con::printf( "Methods:" );
   Namespace *ns = object->getNamespace();
   VectorPtr<Namespace::Entry *> vec(__FILE__, __LINE__);
   if(ns)
      ns->getEntryList(&vec);
   bool sawCBs = false;
   for(Vector<Namespace::Entry *>::iterator j = vec.begin(); j != vec.end(); j++)
   {
      Namespace::Entry *e = *j;
      if(e->mType == Namespace::Entry::ScriptCallbackType)
         sawCBs = true;
      if(e->mType < 0)
         continue;
         
      DocString doc( e );
      Con::printf( "  %s%s%s%s", doc.mReturnType, doc.mPadding, e->mFunctionName, doc.mPrototype.c_str() );
      if( detailed && !doc.mDescription.isEmpty() )
         Con::printf( "    %s", doc.mDescription.c_str() );
   }
   if( sawCBs )
   {
      Con::printf( "Callbacks:" );
      for(Vector<Namespace::Entry *>::iterator j = vec.begin(); j != vec.end(); j++)
      {
         Namespace::Entry *e = *j;
         if(e->mType != Namespace::Entry::ScriptCallbackType)
            continue;
         DocString doc( e );
         Con::printf( "  %s%s%s%s", doc.mReturnType, doc.mPadding, e->cb.mCallbackName, doc.mPrototype.c_str() );
         if( detailed && !doc.mDescription.isEmpty() )
            Con::printf( "    %s", doc.mDescription.c_str() );
      }
   }
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimObject_setName(char * x__object, char * x__newName)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* newName = (const char*)x__newName;
{
   object->assignName( newName );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimObject_getName(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   const char *ret = object->getName();
   {wle_returnObject =ret ? ret : "";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimObject_setInternalName(char * x__object, char * x__newInternalName)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* newInternalName = (const char*)x__newInternalName;
{
   object->setInternalName( newInternalName );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimObject_getInternalName(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->getInternalName();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimObject_getId(char * x__object)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getId());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimObject_getGroup(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
SimGroup* wle_returnObject;
{
   {wle_returnObject =object->getGroup();
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimObject_getDebugInfo(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
ArrayObject* wle_returnObject;
{
   ArrayObject* array = new ArrayObject();
   array->registerObject();
   
   array->push_back( "C++|Address", String::ToString( "0x%x", object ) );
   array->push_back( "C++|Size", String::ToString( object->getClassRep()->getSizeof() ) );
   array->push_back( "Object|Description", object->describeSelf() );
   array->push_back( "Object|FileName", object->getFilename() );
   array->push_back( "Object|DeclarationLine", String::ToString( object->getDeclarationLine() ) );
   array->push_back( "Object|CopySource", object->getCopySource() ?
      String::ToString( "%i:%s (%s)", object->getCopySource()->getId(), object->getCopySource()->getClassName(), object->getCopySource()->getName() ) : "" );
   array->push_back( "Flag|EditorOnly", object->isEditorOnly() ? "true" : "false" );
   array->push_back( "Flag|NameChangeAllowed", object->isNameChangeAllowed() ? "true" : "false" );
   array->push_back( "Flag|AutoDelete", object->isAutoDeleted() ? "true" : "false" );
   array->push_back( "Flag|Selected", object->isSelected() ? "true" : "false" );
   array->push_back( "Flag|Expanded", object->isExpanded() ? "true" : "false" );
   array->push_back( "Flag|ModStaticFields", object->canModStaticFields() ? "true" : "false" );
   array->push_back( "Flag|ModDynamicFields", object->canModDynamicFields() ? "true" : "false" );
   array->push_back( "Flag|CanSave", object->getCanSave() ? "true" : "false" );
   
   #ifndef TORQUE_DISABLE_MEMORY_MANAGER
   Memory::Info memInfo;
   Memory::getMemoryInfo( object, memInfo );
   
   array->push_back( "Memory|AllocNumber", String::ToString( memInfo.mAllocNumber ) );
   array->push_back( "Memory|AllocSize", String::ToString( memInfo.mAllocSize ) );
   array->push_back( "Memory|AllocFile", memInfo.mFileName );
   array->push_back( "Memory|AllocLine", String::ToString( memInfo.mLineNumber ) );
   array->push_back( "Memory|IsGlobal", memInfo.mIsGlobal ? "true" : "false" );
   array->push_back( "Memory|IsStatic", memInfo.mIsStatic ? "true" : "false" );
   #endif
   
   {wle_returnObject =array;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimPersistSet_resolvePersistentIds(char * x__object)
{
SimPersistSet* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->resolvePIDs();
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_saveObject(char * x__object, char * x__filename)
{
SimObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* filename = (const char*)x__filename;
bool wle_returnObject;
{
   {wle_returnObject =object && Sim::saveObject(object, filename);
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_loadObject(char * x__filename,  char* retval)
{
dSprintf(retval,1024,"");
const char* filename = (const char*)x__filename;
SimObject* wle_returnObject;
{
   {wle_returnObject =Sim::loadObjectStream(filename);
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimSet_add(char * x__object, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10, char * x__a11, char * x__a12, char * x__a13, char * x__a14, char * x__a15, char * x__a16, char * x__a17, char * x__a18, char * x__a19)
{
SimSet* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* a11 = (const char*)x__a11;
const char* a12 = (const char*)x__a12;
const char* a13 = (const char*)x__a13;
const char* a14 = (const char*)x__a14;
const char* a15 = (const char*)x__a15;
const char* a16 = (const char*)x__a16;
const char* a17 = (const char*)x__a17;
const char* a18 = (const char*)x__a18;
const char* a19 = (const char*)x__a19;
{
S32 argc = 20;
if (dStrlen(a19)==0)
if (dStrlen(a18)==0)
if (dStrlen(a17)==0)
if (dStrlen(a16)==0)
if (dStrlen(a15)==0)
if (dStrlen(a14)==0)
if (dStrlen(a13)==0)
if (dStrlen(a12)==0)
if (dStrlen(a11)==0)
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
else
argc=12;
else
argc=13;
else
argc=14;
else
argc=15;
else
argc=16;
else
argc=17;
else
argc=18;
else
argc=19;
else
argc=20;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
if (argc>5)
arguments.push_back(a5);
if (argc>6)
arguments.push_back(a6);
if (argc>7)
arguments.push_back(a7);
if (argc>8)
arguments.push_back(a8);
if (argc>9)
arguments.push_back(a9);
if (argc>10)
arguments.push_back(a10);
if (argc>11)
arguments.push_back(a11);
if (argc>12)
arguments.push_back(a12);
if (argc>13)
arguments.push_back(a13);
if (argc>14)
arguments.push_back(a14);
if (argc>15)
arguments.push_back(a15);
if (argc>16)
arguments.push_back(a16);
if (argc>17)
arguments.push_back(a17);
if (argc>18)
arguments.push_back(a18);
if (argc>19)
arguments.push_back(a19);
const char** argv = &arguments[0];
{
   for(S32 i = 2; i < argc; i++)
   {
      SimObject *obj = Sim::findObject( argv[ i ] );
      if(obj)
         object->addObject( obj );
      else
         Con::printf("Set::add: Object \"%s\" doesn't exist", argv[ i ] );
   }
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimSet_remove(char * x__object, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10, char * x__a11, char * x__a12, char * x__a13, char * x__a14, char * x__a15, char * x__a16, char * x__a17, char * x__a18, char * x__a19)
{
SimSet* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* a11 = (const char*)x__a11;
const char* a12 = (const char*)x__a12;
const char* a13 = (const char*)x__a13;
const char* a14 = (const char*)x__a14;
const char* a15 = (const char*)x__a15;
const char* a16 = (const char*)x__a16;
const char* a17 = (const char*)x__a17;
const char* a18 = (const char*)x__a18;
const char* a19 = (const char*)x__a19;
{
S32 argc = 20;
if (dStrlen(a19)==0)
if (dStrlen(a18)==0)
if (dStrlen(a17)==0)
if (dStrlen(a16)==0)
if (dStrlen(a15)==0)
if (dStrlen(a14)==0)
if (dStrlen(a13)==0)
if (dStrlen(a12)==0)
if (dStrlen(a11)==0)
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
else
argc=12;
else
argc=13;
else
argc=14;
else
argc=15;
else
argc=16;
else
argc=17;
else
argc=18;
else
argc=19;
else
argc=20;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
if (argc>5)
arguments.push_back(a5);
if (argc>6)
arguments.push_back(a6);
if (argc>7)
arguments.push_back(a7);
if (argc>8)
arguments.push_back(a8);
if (argc>9)
arguments.push_back(a9);
if (argc>10)
arguments.push_back(a10);
if (argc>11)
arguments.push_back(a11);
if (argc>12)
arguments.push_back(a12);
if (argc>13)
arguments.push_back(a13);
if (argc>14)
arguments.push_back(a14);
if (argc>15)
arguments.push_back(a15);
if (argc>16)
arguments.push_back(a16);
if (argc>17)
arguments.push_back(a17);
if (argc>18)
arguments.push_back(a18);
if (argc>19)
arguments.push_back(a19);
const char** argv = &arguments[0];
{
   for(S32 i = 2; i < argc; i++)
   {
      SimObject *obj = Sim::findObject(argv[i]);
      object->lock();
      if(obj && object->find(object->begin(),object->end(),obj) != object->end())
         object->removeObject(obj);
      else
         Con::printf("Set::remove: Object \"%s\" does not exist in set", argv[i]);
      object->unlock();
   }
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimSet_deleteAllObjects(char * x__object)
{
SimSet* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->deleteAllObjects();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimSet_callOnChildren(char * x__object, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10, char * x__a11, char * x__a12, char * x__a13, char * x__a14, char * x__a15, char * x__a16, char * x__a17, char * x__a18, char * x__a19)
{
SimSet* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* a11 = (const char*)x__a11;
const char* a12 = (const char*)x__a12;
const char* a13 = (const char*)x__a13;
const char* a14 = (const char*)x__a14;
const char* a15 = (const char*)x__a15;
const char* a16 = (const char*)x__a16;
const char* a17 = (const char*)x__a17;
const char* a18 = (const char*)x__a18;
const char* a19 = (const char*)x__a19;
{
S32 argc = 20;
if (dStrlen(a19)==0)
if (dStrlen(a18)==0)
if (dStrlen(a17)==0)
if (dStrlen(a16)==0)
if (dStrlen(a15)==0)
if (dStrlen(a14)==0)
if (dStrlen(a13)==0)
if (dStrlen(a12)==0)
if (dStrlen(a11)==0)
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
else
argc=12;
else
argc=13;
else
argc=14;
else
argc=15;
else
argc=16;
else
argc=17;
else
argc=18;
else
argc=19;
else
argc=20;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
if (argc>5)
arguments.push_back(a5);
if (argc>6)
arguments.push_back(a6);
if (argc>7)
arguments.push_back(a7);
if (argc>8)
arguments.push_back(a8);
if (argc>9)
arguments.push_back(a9);
if (argc>10)
arguments.push_back(a10);
if (argc>11)
arguments.push_back(a11);
if (argc>12)
arguments.push_back(a12);
if (argc>13)
arguments.push_back(a13);
if (argc>14)
arguments.push_back(a14);
if (argc>15)
arguments.push_back(a15);
if (argc>16)
arguments.push_back(a16);
if (argc>17)
arguments.push_back(a17);
if (argc>18)
arguments.push_back(a18);
if (argc>19)
arguments.push_back(a19);
const char** argv = &arguments[0];
{
   object->callOnChildren( argv[2], argc - 3, argv + 3 );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimSet_callOnChildrenNoRecurse(char * x__object, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10, char * x__a11, char * x__a12, char * x__a13, char * x__a14, char * x__a15, char * x__a16, char * x__a17, char * x__a18, char * x__a19)
{
SimSet* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* a11 = (const char*)x__a11;
const char* a12 = (const char*)x__a12;
const char* a13 = (const char*)x__a13;
const char* a14 = (const char*)x__a14;
const char* a15 = (const char*)x__a15;
const char* a16 = (const char*)x__a16;
const char* a17 = (const char*)x__a17;
const char* a18 = (const char*)x__a18;
const char* a19 = (const char*)x__a19;
{
S32 argc = 20;
if (dStrlen(a19)==0)
if (dStrlen(a18)==0)
if (dStrlen(a17)==0)
if (dStrlen(a16)==0)
if (dStrlen(a15)==0)
if (dStrlen(a14)==0)
if (dStrlen(a13)==0)
if (dStrlen(a12)==0)
if (dStrlen(a11)==0)
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
else
argc=12;
else
argc=13;
else
argc=14;
else
argc=15;
else
argc=16;
else
argc=17;
else
argc=18;
else
argc=19;
else
argc=20;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
if (argc>5)
arguments.push_back(a5);
if (argc>6)
arguments.push_back(a6);
if (argc>7)
arguments.push_back(a7);
if (argc>8)
arguments.push_back(a8);
if (argc>9)
arguments.push_back(a9);
if (argc>10)
arguments.push_back(a10);
if (argc>11)
arguments.push_back(a11);
if (argc>12)
arguments.push_back(a12);
if (argc>13)
arguments.push_back(a13);
if (argc>14)
arguments.push_back(a14);
if (argc>15)
arguments.push_back(a15);
if (argc>16)
arguments.push_back(a16);
if (argc>17)
arguments.push_back(a17);
if (argc>18)
arguments.push_back(a18);
if (argc>19)
arguments.push_back(a19);
const char** argv = &arguments[0];
{
   object->callOnChildren( argv[2], argc - 3, argv + 3, false );
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimSet_getFullCount(char * x__object)
{
SimSet* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
  return (S32)( object->sizeRecursive());
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimSet_sort(char * x__object, char * x__a2)
{
SimSet* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->scriptSort( argv[2] );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimSet_listObjects(char * x__object)
{
SimSet* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->lock();
   SimSet::iterator itr;
   for(itr = object->begin(); itr != object->end(); itr++)
   {
      SimObject *obj = *itr;
      bool isSet = dynamic_cast<SimSet *>(obj) != 0;
      const char *name = obj->getName();
      if(name)
         Con::printf("   %d,\"%s\": %s %s", obj->getId(), name,
         obj->getClassName(), isSet ? "(g)":"");
      else
         Con::printf("   %d: %s %s", obj->getId(), obj->getClassName(),
         isSet ? "(g)" : "");
   }
   object->unlock();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimSet_clear(char * x__object)
{
SimSet* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimSet_getRandom(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
SimSet* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
SimObject* wle_returnObject;
{
   {wle_returnObject =object->getRandom();
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimSet_reorderChild(char * x__object, char * x__child1, char * x__child2)
{
SimSet* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
SimObject* child1; Sim::findObject(x__child1, child1 ); 
SimObject* child2; Sim::findObject(x__child2, child2 ); 
{
   SimObject* pObject = child1;
   SimObject* pTarget = child2;
   if(pObject && pTarget)
   {
      object->reOrder(pObject,pTarget);
   }
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimSet_getCount(char * x__object)
{
SimSet* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->size());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimSet_getObject(char * x__object, U32 index,  char* retval)
{
dSprintf(retval,1024,"");
SimSet* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
SimObject* wle_returnObject;
{
   if( index < 0 || index >= object->size() )
   {
      Con::errorf( "Set::getObject - index out of range." );
      {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
   }
   
   {wle_returnObject =( *object )[ index ];
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimSet_getObjectIndex(char * x__object, char * x__obj)
{
SimSet* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
SimObject* obj; Sim::findObject(x__obj, obj ); 
{
   if( !obj )
     return (S32)( -1);
   object->lock();
   S32 count = 0;
   for( SimSet::iterator i = object->begin(); i != object->end(); i++)
   {
      if( *i == obj )
      {
         object->unlock();
        return (S32)( count);
      }
      ++count;
   }
   object->unlock();
  return (S32)( -1);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimSet_isMember(char * x__object, char * x__obj)
{
SimSet* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
SimObject* obj; Sim::findObject(x__obj, obj ); 
bool wle_returnObject;
{
   if( !obj )
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   {wle_returnObject =( object->find( object->begin(), object->end(), obj ) != object->end() );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimSet_findObjectByInternalName(char * x__object, char * x__internalName, bool searchChildren,  char* retval)
{
dSprintf(retval,1024,"");
SimSet* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* internalName = (const char*)x__internalName;

SimObject* wle_returnObject;
{
   StringTableEntry pcName = StringTable->insert( internalName );
   {wle_returnObject =object->findObjectByInternalName( pcName, searchChildren );
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimSet_bringToFront(char * x__object, char * x__obj)
{
SimSet* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
SimObject* obj; Sim::findObject(x__obj, obj ); 
{
   if( obj )
      object->bringObjectToFront( obj );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimSet_pushToBack(char * x__object, char * x__obj)
{
SimSet* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
SimObject* obj; Sim::findObject(x__obj, obj ); 
{
   if( obj )
      object->pushObjectToBack( obj );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimSet_acceptsAsChild(char * x__object, char * x__obj)
{
SimSet* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
SimObject* obj; Sim::findObject(x__obj, obj ); 
bool wle_returnObject;
{
   if( !obj )
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   
   {wle_returnObject =object->acceptsAsChild( obj );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnSimXMLDocument_attributeF32(char * x__object, char * x__a2)
{
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
  return (F32)( dAtof( object->attribute( argv[2] ) ));
}
}
;
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimXMLDocument_attributeS32(char * x__object, char * x__a2)
{
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
  return (S32)( dAtoi( object->attribute( argv[2] ) ));
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_reset(char * x__object)
{
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->reset();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimXMLDocument_loadFile(char * x__object, char * x__fileName)
{
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* fileName = (const char*)x__fileName;
bool wle_returnObject;
{
   {wle_returnObject =object->loadFile( fileName );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimXMLDocument_saveFile(char * x__object, char * x__fileName)
{
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* fileName = (const char*)x__fileName;
bool wle_returnObject;
{
   {wle_returnObject =object->saveFile( fileName );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_parse(char * x__object, char * x__xmlString)
{
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* xmlString = (const char*)x__xmlString;
{
   object->parse( xmlString );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_clear(char * x__object)
{
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_getErrorDesc(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->getErrorDesc();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_clearError(char * x__object)
{
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->clearError();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimXMLDocument_pushFirstChildElement(char * x__object, char * x__name)
{
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* name = (const char*)x__name;
bool wle_returnObject;
{
   {wle_returnObject =object->pushFirstChildElement( name );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimXMLDocument_pushChildElement(char * x__object, S32 index)
{
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->pushChildElement( index );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimXMLDocument_nextSiblingElement(char * x__object, char * x__name)
{
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* name = (const char*)x__name;
bool wle_returnObject;
{
   {wle_returnObject =object->nextSiblingElement( name );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_elementValue(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->elementValue();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_popElement(char * x__object)
{
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->popElement();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_attribute(char * x__object, char * x__attributeName,  char* retval)
{
dSprintf(retval,4096,"");
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* attributeName = (const char*)x__attributeName;
const char* wle_returnObject;
{
   {wle_returnObject =object->attribute( attributeName );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSimXMLDocument_attributeExists(char * x__object, char * x__attributeName)
{
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* attributeName = (const char*)x__attributeName;
bool wle_returnObject;
{
   {wle_returnObject =object->attributeExists( attributeName );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_firstAttribute(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->firstAttribute();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_lastAttribute(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->lastAttribute();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_nextAttribute(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->nextAttribute();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_prevAttribute(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->prevAttribute();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_setAttribute(char * x__object, char * x__attributeName, char * x__value)
{
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* attributeName = (const char*)x__attributeName;
const char* value = (const char*)x__value;
{
   object->setAttribute( attributeName, value );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_setObjectAttributes(char * x__object, char * x__objectID)
{
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* objectID = (const char*)x__objectID;
{
   object->setObjectAttributes( objectID );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_pushNewElement(char * x__object, char * x__name)
{
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* name = (const char*)x__name;
{
   object->pushNewElement( name );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_addNewElement(char * x__object, char * x__name)
{
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* name = (const char*)x__name;
{
   object->addNewElement( name );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_addHeader(char * x__object)
{
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->addHeader();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_addComment(char * x__object, char * x__comment)
{
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* comment = (const char*)x__comment;
{
   object->addComment( comment );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_readComment(char * x__object, S32 index,  char* retval)
{
dSprintf(retval,4096,"");
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->readComment( index );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_addText(char * x__object, char * x__text)
{
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* text = (const char*)x__text;
{
   object->addText( text );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_getText(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   const char* text = object->getText();
   if( !text )
      {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   {wle_returnObject =text;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_removeText(char * x__object)
{
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->removeText();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_addData(char * x__object, char * x__text)
{
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* text = (const char*)x__text;
{
   object->addData( text );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimXMLDocument_getData(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
SimXMLDocument* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   const char* text = object->getData();
   if( !text )
      {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   {wle_returnObject =text;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnFileObject_writeObject(char * x__object, char * x__a2, char * x__a3)
{
FileObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   SimObject* obj = Sim::findObject( argv[2] );
   if( !obj )
   {
      Con::printf("FileObject::writeObject - Invalid Object!");
      return;
   }
   char *objName = NULL;
   if( argc == 4 )
      objName = (char*)argv[3];
   object->writeObject( obj, (const U8*)objName );
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnFileObject_openForRead(char * x__object, char * x__filename)
{
FileObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* filename = (const char*)x__filename;
bool wle_returnObject;
{
	{wle_returnObject =object->readMemory(filename);
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnFileObject_openForWrite(char * x__object, char * x__filename)
{
FileObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* filename = (const char*)x__filename;
bool wle_returnObject;
{
	{wle_returnObject =object->openForWrite(filename);
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnFileObject_openForAppend(char * x__object, char * x__filename)
{
FileObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* filename = (const char*)x__filename;
bool wle_returnObject;
{
	{wle_returnObject =object->openForWrite(filename, true);
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnFileObject_isEOF(char * x__object)
{
FileObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
	{wle_returnObject =object->isEOF();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnFileObject_readLine(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
FileObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
	{wle_returnObject =(const char *) object->readLine();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnFileObject_peekLine(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
FileObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
	char *line = Con::getReturnBuffer( 512 );
	object->peekLine( (U8*)line, 512 );
	{wle_returnObject =line;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnFileObject_writeLine(char * x__object, char * x__text)
{
FileObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* text = (const char*)x__text;
{
	object->writeLine((const U8 *) text);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnFileObject_close(char * x__object)
{
FileObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->close();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_reloadResource(char * x__path)
{
const char* path = (const char*)x__path;
{
   ResourceManager::get().reloadResource( path );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnFileStreamObject_open(char * x__object, char * x__filename, char * x__openMode)
{
FileStreamObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* filename = (const char*)x__filename;
const char* openMode = (const char*)x__openMode;
bool wle_returnObject;
{
	for(S32 i = 0;gModeMap[i].strMode;++i)
   {
      if(dStricmp(gModeMap[i].strMode, openMode) == 0)
      {
         Torque::FS::File::AccessMode mode = gModeMap[i].mode;
         char buffer[1024];
         Con::expandScriptFilename(buffer, sizeof(buffer), filename);
         {wle_returnObject =object->open(buffer, mode);
return (S32)(wle_returnObject);}
      }
   }
   Con::errorf("FileStreamObject::open - Mode must be one of Read, Write, ReadWrite or WriteAppend.");
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnFileStreamObject_close(char * x__object)
{
FileStreamObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->close();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnStreamObject_getStatus(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
StreamObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
	{wle_returnObject =object->getStatus();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnStreamObject_isEOS(char * x__object)
{
StreamObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
	{wle_returnObject =object->isEOS();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnStreamObject_isEOF(char * x__object)
{
StreamObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
	{wle_returnObject =object->isEOS();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnStreamObject_getPosition(char * x__object)
{
StreamObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
	return object->getPosition();
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnStreamObject_setPosition(char * x__object, S32 newPosition)
{
StreamObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
	{wle_returnObject =object->setPosition(newPosition);
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnStreamObject_getStreamSize(char * x__object)
{
StreamObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
	return object->getStreamSize();
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnStreamObject_readLine(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
StreamObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
	const char *str = object->readLine();
	{wle_returnObject =str ? str : "";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnStreamObject_writeLine(char * x__object, char * x__line)
{
StreamObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* line = (const char*)x__line;
{
	object->writeLine((U8 *)line);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnStreamObject_readSTString(char * x__object, bool caseSensitive,  char* retval)
{
dSprintf(retval,1024,"");
StreamObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
String wle_returnObject;
{
   const char *str = object->readSTString(caseSensitive);
   {wle_returnObject =str ? str : "";
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnStreamObject_readString(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
StreamObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
String wle_returnObject;
{
   const char *str = object->readString();
   {wle_returnObject =str ? str : "";
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnStreamObject_readLongString(char * x__object, S32 maxLength,  char* retval)
{
dSprintf(retval,1024,"");
StreamObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
String wle_returnObject;
{
   const char *str = object->readLongString(maxLength);
   {wle_returnObject =str ? str : "";
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnStreamObject_writeLongString(char * x__object, S32 maxLength, char * x__string)
{
StreamObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

const char* string = (const char*)x__string;
{
   object->writeLongString(maxLength, string);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnStreamObject_writeString(char * x__object, char * x__string, S32 maxLength)
{
StreamObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* string = (const char*)x__string;

{
   object->writeString(string, maxLength);
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnStreamObject_copyFrom(char * x__object, char * x__other)
{
StreamObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
SimObject* other; Sim::findObject(x__other, other ); 
bool wle_returnObject;
{
   StreamObject *so = dynamic_cast<StreamObject *>(other);
   if(so == NULL)
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   {wle_returnObject =object->copyFrom(so);
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnZipObject_openArchive(char * x__object, char * x__filename, char * x__accessMode)
{
ZipObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* filename = (const char*)x__filename;
const char* accessMode = (const char*)x__accessMode;
bool wle_returnObject;
{
   Zip::ZipArchive::AccessMode mode = Zip::ZipArchive::Read;
   for(S32 i = 0;gModeMap[i].strMode;++i)
   {
      if(dStricmp(gModeMap[i].strMode, accessMode) == 0)
      {
         mode = zgModeMap[i].mode;
         break;
      }
   }
   char buf[512];
   Con::expandScriptFilename(buf, sizeof(buf), filename);
   {wle_returnObject =object->openArchive(buf, mode);
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnZipObject_closeArchive(char * x__object)
{
ZipObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->closeArchive();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnZipObject_openFileForRead(char * x__object, char * x__filename,  char* retval)
{
dSprintf(retval,1024,"");
ZipObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* filename = (const char*)x__filename;
SimObject* wle_returnObject;
{
   StreamObject *stream = object->openFileForRead(filename);
   {wle_returnObject =stream;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnZipObject_openFileForWrite(char * x__object, char * x__filename,  char* retval)
{
dSprintf(retval,1024,"");
ZipObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* filename = (const char*)x__filename;
SimObject* wle_returnObject;
{
   StreamObject *stream = object->openFileForWrite(filename);
   {wle_returnObject =stream;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnZipObject_closeFile(char * x__object, char * x__stream)
{
ZipObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
SimObject* stream; Sim::findObject(x__stream, stream ); 
{
   StreamObject *so = dynamic_cast<StreamObject *>(stream);
   if(so == NULL)
   {
      Con::errorf("ZipObject::closeFile - Invalid stream specified");
      return;
   }
   object->closeFile(so);
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnZipObject_addFile(char * x__object, char * x__filename, char * x__pathInZip, bool replace)
{
ZipObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* filename = (const char*)x__filename;
const char* pathInZip = (const char*)x__pathInZip;

bool wle_returnObject;
{
   // Left this line commented out as it was useful when i had a problem
   //  with the zip's i was creating. [2/21/2007 justind]
   // [tom, 2/21/2007] To is now a warnf() for better visual separation in the console
  // Con::errorf("zipAdd: %s", argv[2]);
   //Con::warnf("    To: %s", argv[3]);
   {wle_returnObject =object->addFile(filename, pathInZip, replace);
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnZipObject_extractFile(char * x__object, char * x__pathInZip, char * x__filename)
{
ZipObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* pathInZip = (const char*)x__pathInZip;
const char* filename = (const char*)x__filename;
bool wle_returnObject;
{
   {wle_returnObject =object->extractFile(pathInZip, filename);
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnZipObject_deleteFile(char * x__object, char * x__pathInZip)
{
ZipObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* pathInZip = (const char*)x__pathInZip;
bool wle_returnObject;
{
   {wle_returnObject =object->deleteFile(pathInZip);
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnZipObject_getFileEntryCount(char * x__object)
{
ZipObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getFileEntryCount());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnZipObject_getFileEntry(char * x__object, S32 index,  char* retval)
{
dSprintf(retval,1024,"");
ZipObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
String wle_returnObject;
{
   {wle_returnObject =object->getFileEntry(index);
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnDecalRoad_regenerate(char * x__object)
{
DecalRoad* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->regenerate();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnDecalRoad_postApply(char * x__object)
{
DecalRoad* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->inspectPostApply();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMeshRoad_setNodeDepth(char * x__object, S32 idx, F32 meters)
{
MeshRoad* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->setNodeDepth( idx, meters );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMeshRoad_regenerate(char * x__object)
{
MeshRoad* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->regenerate();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMeshRoad_postApply(char * x__object)
{
MeshRoad* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->inspectPostApply();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnRiver_regenerate(char * x__object)
{
River* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->regenerate();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnRiver_setMetersPerSegment(char * x__object, F32 meters)
{
River* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setMetersPerSegment( meters );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnRiver_setBatchSize(char * x__object, F32 meters)
{
River* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setBatchSize( meters );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnRiver_setNodeDepth(char * x__object, S32 idx, F32 meters)
{
River* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->setNodeDepth( idx, meters );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnRiver_setMaxDivisionSize(char * x__object, F32 meters)
{
River* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setMaxDivisionSize( meters );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnScatterSky_applyChanges(char * x__object)
{
ScatterSky* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->inspectPostApply();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSkyBox_postApply(char * x__object)
{
SkyBox* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
	object->inspectPostApply();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSun_apply(char * x__object)
{
Sun* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->inspectPostApply();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSun_animate(char * x__object, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6)
{
Sun* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
{
S32 argc = 7;
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
if (argc>5)
arguments.push_back(a5);
if (argc>6)
arguments.push_back(a6);
const char** argv = &arguments[0];
{
   F32 duration = dAtof(argv[2]);
   F32 startAzimuth = dAtof(argv[3]);
   F32 endAzimuth   = dAtof(argv[4]);
   F32 startElevation = dAtof(argv[5]);
   F32 endElevation   = dAtof(argv[6]);
   object->animate(duration, startAzimuth, endAzimuth, startElevation, endElevation);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiRoadEditorCtrl_deleteNode(char * x__object)
{
GuiRoadEditorCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->deleteSelectedNode();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiRoadEditorCtrl_getMode(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiRoadEditorCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
{
   {wle_returnObject =object->getMode();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnGuiRoadEditorCtrl_getNodeWidth(char * x__object)
{
GuiRoadEditorCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
  return (F32)( object->getNodeWidth());
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiRoadEditorCtrl_setNodeWidth(char * x__object, char * x__a2)
{
GuiRoadEditorCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->setNodeWidth( dAtof(argv[2]) );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiRoadEditorCtrl_getNodePosition(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiRoadEditorCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
{
	char* returnBuffer = Con::getReturnBuffer(256);
	dSprintf(returnBuffer, 256, "%f %f %f",
      object->getNodePosition().x, object->getNodePosition().y, object->getNodePosition().z);
	{wle_returnObject =returnBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiRoadEditorCtrl_setNodePosition(char * x__object, char * x__a2)
{
GuiRoadEditorCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	Point3F pos;
	S32 count = dSscanf( argv[2], "%f %f %f", 
		&pos.x, &pos.y, &pos.z);
	
	if ( (count != 3) )
   {
		Con::printf("Failed to parse node information \"px py pz\" from '%s'", argv[3]);
      return;
   }
   object->setNodePosition( pos );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiRoadEditorCtrl_setSelectedRoad(char * x__object, char * x__a2)
{
GuiRoadEditorCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   if ( argc == 2 )
      object->setSelectedRoad(NULL);
   else
   {
      DecalRoad *road = NULL;
      if ( Sim::findObject( argv[2], road ) )
         object->setSelectedRoad(road);
   }
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiRoadEditorCtrl_getSelectedRoad(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiRoadEditorCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
{
   DecalRoad *road = object->getSelectedRoad();
   if ( road )
      {wle_returnObject =road->getIdString();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   
   {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiRoadEditorCtrl_getSelectedNode(char * x__object)
{
GuiRoadEditorCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
  return (S32)( object->getSelectedNode());
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiRoadEditorCtrl_deleteRoad(char * x__object)
{
GuiRoadEditorCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->deleteSelectedRoad();
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnForest_saveDataFile(char * x__object, char * x__a2)
{
Forest* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
bool wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{   
   object->saveDataFile( argc == 3 ? argv[2] : NULL );
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnForest_isDirty(char * x__object)
{
Forest* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
{
   {wle_returnObject =object->getData() && object->getData()->isDirty();
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnForest_regenCells(char * x__object)
{
Forest* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->getData()->regenCells();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnForest_clear(char * x__object)
{
Forest* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->clear();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnForestWindEmitter_attachToObject(char * x__object, U32 objectID)
{
ForestWindEmitter* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	SceneObject *obj = dynamic_cast<SceneObject*>( Sim::findObject( objectID ) );
	if ( !obj )
		Con::warnf( "ForestWindEmitter::attachToObject - failed to find object with ID: %d", objectID );
	object->attachToObject( obj );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnForestBrush_containsItemData(char * x__object, char * x__a2)
{
ForestBrush* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
bool wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   ForestItemData *data = NULL;
   if ( !Sim::findObject( argv[2], data ) )
   {
      Con::warnf( "ForestBrush::containsItemData - invalid object passed" );
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =object->containsItemData( data );
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnForestBrushTool_collectElements(char * x__object)
{
ForestBrushTool* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->collectElements();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnForestEditorCtrl_updateActiveForest(char * x__object)
{
ForestEditorCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->updateActiveForest( true );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnForestEditorCtrl_setActiveTool(char * x__object, char * x__a2)
{
ForestEditorCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   ForestTool *tool = dynamic_cast<ForestTool*>( Sim::findObject( argv[2] ) );
   object->setActiveTool( tool );
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnForestEditorCtrl_getActiveTool(char * x__object)
{
ForestEditorCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
   ForestTool *tool = object->getActiveTool();
  return (S32)( tool ? tool->getId() : 0);
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnForestEditorCtrl_deleteMeshSafe(char * x__object, char * x__a2)
{
ForestEditorCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   ForestItemData *db;
   if ( !Sim::findObject( argv[2], db ) )
      return;
   object->deleteMeshSafe( db );   
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnForestEditorCtrl_isDirty(char * x__object)
{
ForestEditorCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
{
   {wle_returnObject =object->isDirty();
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnForestSelectionTool_getSelectionCount(char * x__object)
{
ForestSelectionTool* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
  return (S32)( object->getSelectionCount());
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnForestSelectionTool_deleteSelection(char * x__object)
{
ForestSelectionTool* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->deleteSelection();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnForestSelectionTool_clearSelection(char * x__object)
{
ForestSelectionTool* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->clearSelection();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnForestSelectionTool_cutSelection(char * x__object)
{
ForestSelectionTool* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->cutSelection();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnForestSelectionTool_copySelection(char * x__object)
{
ForestSelectionTool* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->copySelection();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnForestSelectionTool_pasteSelection(char * x__object)
{
ForestSelectionTool* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->pasteSelection();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_populateFontCacheString(char * x__faceName, S32 fontSize, char * x__string)
{
const char* faceName = (const char*)x__faceName;

const char* string = (const char*)x__string;
{
   Resource<GFont> f = GFont::create(faceName, fontSize, Con::getVariable("$GUI::fontCacheDirectory"));
   if(f == NULL)
   {
      Con::errorf("populateFontCacheString - could not load font '%s %d'", faceName, fontSize);
      return;
   }
   if(!f->hasPlatformFont())
   {
      Con::errorf("populateFontCacheString - font '%s %d' has no platform font. Cannot generate more characters.", faceName, fontSize);
      return;
   }
   // This has the side effect of generating character info, including the bitmaps.
   f->getStrWidthPrecise( string );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_populateFontCacheRange(char * x__faceName, S32 fontSize, U32 rangeStart, U32 rangeEnd)
{
const char* faceName = (const char*)x__faceName;


{
   Resource<GFont> f = GFont::create(faceName, fontSize, Con::getVariable("$GUI::fontCacheDirectory"));
   if(f == NULL)
   {
      Con::errorf("populateFontCacheRange - could not load font '%s %d'", faceName, fontSize);
      return;
   }
   if(rangeStart > rangeEnd)
   {
      Con::errorf("populateFontCacheRange - range start is after end");
      return;
   }
   if(!f->hasPlatformFont())
   {
      Con::errorf("populateFontCacheRange - font '%s %d' has no platform font Cannot generate more characters.", faceName, fontSize);
      return;
   }
   // This has the side effect of generating character info, including the bitmaps.
   for(U32 i=rangeStart; i<rangeEnd; i++)
   {
      if(f->isValidChar(i))
         f->getCharWidth(i);
      else
         Con::warnf("populateFontCacheRange - skipping invalid char 0x%x",  i);
   }
   // All done!
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_dumpFontCacheStatus()
{
{
   Resource<GFont>   theFont = ResourceManager::get().startResourceList( Resource<GFont>::signature() );
 
   Con::printf("--------------------------------------------------------------------------");
   Con::printf("   Font Cache Usage Report");
   while( theFont != NULL )
   {
      theFont->dumpInfo();
      theFont = ResourceManager::get().nextResource();
   }
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_writeFontCache()
{
{
   Resource<GFont>   theFont = ResourceManager::get().startResourceList( Resource<GFont>::signature() );
   Con::printf("--------------------------------------------------------------------------");
   Con::printf("   Writing font cache to disk");
   while( theFont != NULL )
   {
      const String   fileName( theFont.getPath() );
      FileStream stream;
      stream.open(fileName, Torque::FS::File::Write);
      if(stream.getStatus() == Stream::Ok) 
      {
         Con::printf("      o Writing '%s' to disk...", fileName.c_str());
         theFont->write(stream);
      }
      else
      {
         Con::errorf("      o Could not open '%s' for write", fileName.c_str());
      }
      theFont = ResourceManager::get().nextResource();
  }
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_populateAllFontCacheString(char * x__string)
{
const char* string = (const char*)x__string;
{
   Resource<GFont> theFont = ResourceManager::get().startResourceList( Resource<GFont>::signature() );
   Con::printf("Populating font cache with string '%s'", string);
   while( theFont != NULL )
   {
      if(theFont->hasPlatformFont())
      {
         // This has the side effect of generating character info, including the bitmaps.
         theFont->getStrWidthPrecise( string );
      }
      else
      {
         const String   fileName( theFont.getPath() );
         Con::errorf("populateAllFontCacheString - font '%s' has no platform font. Cannot generate more characters.", fileName.c_str());
      }
      theFont = ResourceManager::get().nextResource();
   }
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_populateAllFontCacheRange(U32 rangeStart, U32 rangeEnd)
{

{
   if(rangeStart > rangeEnd)
   {
      Con::errorf("populateAllFontCacheRange - range start is after end!");
      return;
   }
   Resource<GFont>   theFont = ResourceManager::get().startResourceList( Resource<GFont>::signature() );
   Con::printf("Populating font cache with range 0x%x to 0x%x", rangeStart, rangeEnd);
   while( theFont != NULL )
   {
      const String   fileName( theFont.getPath() );
      if(theFont->hasPlatformFont())
      {
         // This has the side effect of generating character info, including the bitmaps.
         Con::printf("   o Populating font '%s'", fileName.c_str());
         for(U32 i=rangeStart; i<rangeEnd; i++)
         {
            if(theFont->isValidChar(i))
               theFont->getCharWidth(i);
            else
               Con::warnf("populateAllFontCacheRange - skipping invalid char 0x%x",  i);
         }
      }
      else
      {
         Con::errorf("populateAllFontCacheRange - font '%s' has no platform font. Cannot generate more characters.", fileName.c_str());
      }
      theFont = ResourceManager::get().nextResource();
   }
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_exportCachedFont(char * x__faceName, S32 fontSize, char * x__fileName, S32 padding, S32 kerning)
{
const char* faceName = (const char*)x__faceName;

const char* fileName = (const char*)x__fileName;

{
   // Tell the font to export itself.
   Resource<GFont> f = GFont::create(faceName, fontSize, Con::getVariable("$GUI::fontCacheDirectory"));
   if(f == NULL)
   {
      Con::errorf("exportCachedFont - could not load font '%s %d'", faceName, fontSize);
      return;
   }
   f->exportStrip(fileName, padding, kerning);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_importCachedFont(char * x__faceName, S32 fontSize, char * x__fileName, S32 padding, S32 kerning)
{
const char* faceName = (const char*)x__faceName;

const char* fileName = (const char*)x__fileName;

{
   // Tell the font to import itself.
   Resource<GFont> f = GFont::create(faceName, fontSize, Con::getVariable("$GUI::fontCacheDirectory"));
   if(f == NULL)
   {
      Con::errorf("importCachedFont - could not load font '%s %d'", faceName, fontSize);
      return;
   }
   f->importStrip(fileName, padding, kerning);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_duplicateCachedFont(char * x__oldFontName, S32 oldFontSize, char * x__newFontName)
{
const char* oldFontName = (const char*)x__oldFontName;

const char* newFontName = (const char*)x__newFontName;
{
   String newFontFile = GFont::getFontCacheFilename(newFontName, oldFontSize);
   // Load the original font.
   Resource<GFont> font = GFont::create(oldFontName, oldFontSize, Con::getVariable("$GUI::fontCacheDirectory"));
   // Deal with inexplicably missing or failed to load fonts.
   if (font == NULL)
   {
      Con::errorf(" o Couldn't find font : %s", oldFontName);
      return;
   }
   // Ok, dump info!
   FileStream stream;
   stream.open( newFontFile, Torque::FS::File::Write );
   if(stream.getStatus() == Stream::Ok) 
   {
      Con::printf( "      o Writing duplicate font '%s' to disk...", newFontFile.c_str() );
      font->write(stream);
      stream.close();
   }
   else
   {
      Con::errorf( "      o Could not open '%s' for write", newFontFile.c_str() );
   }
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getDisplayDeviceList(char* retval)
{
dSprintf(retval,1024,"");
String wle_returnObject;
{
   Vector<GFXAdapter*> adapters;
   GFXInit::getAdapters(&adapters);
   StringBuilder str;
   for (S32 i=0; i<adapters.size(); i++)
   {
      if (i)
         str.append( '\t' );
      str.append(adapters[i]->mName);
   }
   {wle_returnObject =str.end();
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_listGFXResources(bool unflaggedOnly)
{
{
   GFX->listResources(unflaggedOnly);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_flagCurrentGFXResources()
{
{
   GFX->flagCurrentResources();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_clearGFXResourceFlags()
{
{
   GFX->clearResourceFlags();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_describeGFXResources(char * x__resourceTypes, char * x__filePath, bool unflaggedOnly)
{
const char* resourceTypes = (const char*)x__resourceTypes;
const char* filePath = (const char*)x__filePath;

{
   GFX->describeResources( resourceTypes, filePath, unflaggedOnly );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_describeGFXStateBlocks(char * x__filePath)
{
const char* filePath = (const char*)x__filePath;
{
   GFX->dumpStates( filePath );   
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_getPixelShaderVersion()
{
{
  return (F32)( GFX->getPixelShaderVersion());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_setPixelShaderVersion(float version)
{
{
   GFX->setPixelShaderVersion( version );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getDisplayDeviceInformation(char* retval)
{
dSprintf(retval,4096,"");
const char* wle_returnObject;
{
   if (!GFXDevice::devicePresent())
      {wle_returnObject ="(no device)";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   const GFXAdapter& adapter = GFX->getAdapter();
   {wle_returnObject =adapter.getName();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_getBestHDRFormat()
{
GFXFormat wle_returnObject;
{
   // TODO: Maybe expose GFX::selectSupportedFormat() so that this
   // specialized method can be moved to script.
   // Figure out the best HDR format.  This is the smallest
   // format which supports blending and filtering.
   Vector<GFXFormat> formats;
   formats.push_back( GFXFormatR10G10B10A2 );
   formats.push_back( GFXFormatR16G16B16A16F );
   formats.push_back( GFXFormatR16G16B16A16 );    
   GFXFormat format = GFX->selectSupportedFormat(  &GFXDefaultRenderTargetProfile,
                                                   formats, 
                                                   true,
                                                   true,
                                                   true );
   {wle_returnObject =format;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getDesktopResolution(char* retval)
{
dSprintf(retval,1024,"");
Point3F wle_returnObject;
{
   GFXVideoMode res = GFXInit::getDesktopResolution();
   {wle_returnObject =Point3F( res.resolution.x, res.resolution.y, res.bitDepth );
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_addGlobalShaderMacro(char * x__name, char * x__value)
{
const char* name = (const char*)x__name;
const char* value = (const char*)x__value;
{
   GFXShader::addGlobalMacro( name, value );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_removeGlobalShaderMacro(char * x__name)
{
const char* name = (const char*)x__name;
{
   GFXShader::removeGlobalMacro( name );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_flushTextureCache()
{
{
   if ( !GFX || !TEXMGR )
      return;
   TEXMGR->zombify();
   TEXMGR->resurrect();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_cleanupTexturePool()
{
{
   if ( !GFX || !TEXMGR )
      return;
   TEXMGR->cleanupPool();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_reloadTextures()
{
{
   if ( !GFX || !TEXMGR )
      return;
   TEXMGR->reloadTextures();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getTextureProfileStats(char* retval)
{
dSprintf(retval,1024,"");
String wle_returnObject;
{
   StringBuilder result;
   GFXTextureProfile *profile = GFXTextureProfile::getHead();
   while ( profile )
   {
      const GFXTextureProfileStats &stats = profile->getStats();
      F32 mb = ( stats.activeBytes / 1024.0f ) / 1024.0f;
      result.format( "%s %d %0.2f\n",
         profile->getName().c_str(),
         stats.activeCount,
         mb );
      profile = profile->getNext();
   }
   {wle_returnObject =result.end();
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_screenShot(char * x__file, char * x__format, U32 tileCount, F32 tileOverlap)
{
const char* file = (const char*)x__file;
const char* format = (const char*)x__format;

{
   if ( !gScreenShot )
   {
      Con::errorf( "Screenshot module not initialized by device" );
      return;
   }
	Torque::Path ssPath( file );
   Torque::FS::CreatePath( ssPath );
   Torque::FS::FileSystemRef fs = Torque::FS::GetFileSystem(ssPath);
   Torque::Path newPath = fs->mapTo(ssPath);
   gScreenShot->setPending(   newPath.getFullPath(), 
                              dStricmp( format, "JPEG" ) == 0,
                              tileCount, 
                              tileOverlap );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_getActiveDDSFiles()
{
{
  return (S32)( DDSFile::smActiveCopies);
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getBitmapInfo(char * x__filename,  char* retval)
{
dSprintf(retval,1024,"");
const char* filename = (const char*)x__filename;
String wle_returnObject;
{
   Resource<GBitmap> image = GBitmap::load( filename );
   if ( !image )
      {wle_returnObject =String::EmptyString;
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
   {wle_returnObject =String::ToString( "%d\t%d\t%d", image->getWidth(),                                           image->getHeight(),                                          image->getBytesPerPixel() );
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCubemapData_updateFaces(char * x__object)
{
CubemapData* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->updateFaces();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCubemapData_getFilename(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
CubemapData* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->getFilename();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnDebugDrawer_drawLine(char * x__object, char * x__a, char * x__b, char * x__color)
{
DebugDrawer* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F a = Point3F();
sscanf(x__a,"%f %f %f", &a.x,&a.y,&a.z);
Point3F b = Point3F();
sscanf(x__b,"%f %f %f", &b.x,&b.y,&b.z);
ColorF color = ColorF();
sscanf(x__color,"%f %f %f %f",&color.red,&color.green,&color.blue,&color.alpha);
{
   object->drawLine( a, b, color );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnDebugDrawer_drawBox(char * x__object, char * x__a, char * x__b, char * x__color)
{
DebugDrawer* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F a = Point3F();
sscanf(x__a,"%f %f %f", &a.x,&a.y,&a.z);
Point3F b = Point3F();
sscanf(x__b,"%f %f %f", &b.x,&b.y,&b.z);
ColorF color = ColorF();
sscanf(x__color,"%f %f %f %f",&color.red,&color.green,&color.blue,&color.alpha);
{
   object->drawBox( a, b, color );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnDebugDrawer_setLastTTL(char * x__object, U32 ms)
{
DebugDrawer* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setLastTTL( ms );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnDebugDrawer_setLastZTest(char * x__object, bool enabled)
{
DebugDrawer* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setLastZTest( enabled );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnDebugDrawer_toggleFreeze(char * x__object)
{
DebugDrawer* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->toggleFreeze();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnDebugDrawer_toggleDrawing(char * x__object)
{
DebugDrawer* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->toggleDrawing();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_startVideoCapture(char * x__canvas, char * x__filename, char * x__encoder, F32 framerate, char * x__resolution)
{
GuiCanvas* canvas; Sim::findObject(x__canvas, canvas ); 
const char* filename = (const char*)x__filename;
const char* encoder = (const char*)x__encoder;

Point2I resolution = Point2I();
sscanf(x__resolution,"%i %i",&resolution.x,&resolution.y);
{
   if ( !canvas )
   {
      Con::errorf("startVideoCapture -Please specify a GuiCanvas object to record from!");
      return;
   }
   VIDCAP->setFilename( filename );   
   VIDCAP->setEncoderName( encoder );   
   VIDCAP->setFramerate( framerate );
   
   if ( !resolution.isZero() )
      VIDCAP->setResolution(resolution);
   VIDCAP->begin(canvas);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_stopVideoCapture()
{
{
   VIDCAP->end();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_playJournalToVideo(char * x__journalFile, char * x__videoFile, char * x__encoder, F32 framerate, char * x__resolution)
{
const char* journalFile = (const char*)x__journalFile;
const char* videoFile = (const char*)x__videoFile;
const char* encoder = (const char*)x__encoder;

Point2I resolution = Point2I();
sscanf(x__resolution,"%i %i",&resolution.x,&resolution.y);
{
   if ( !videoFile )
      videoFile = journalFile;
   VIDCAP->setFilename( Torque::Path( videoFile ).getFileName() );   
   VIDCAP->setEncoderName( encoder );   
   VIDCAP->setFramerate( framerate );
   if ( !resolution.isZero() )
      VIDCAP->setResolution(resolution);
   VIDCAP->waitForCanvas();
   Journal::Play( journalFile );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTSCtrl_unproject(char * x__object, char * x__screenPosition,  char* retval)
{
dSprintf(retval,1024,"");
GuiTSCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F screenPosition = Point3F();
sscanf(x__screenPosition,"%f %f %f", &screenPosition.x,&screenPosition.y,&screenPosition.z);
Point3F wle_returnObject;
{
   Point3F worldPos;
   object->unproject( screenPosition, &worldPos );
   {wle_returnObject =worldPos;
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTSCtrl_project(char * x__object, char * x__worldPosition,  char* retval)
{
dSprintf(retval,1024,"");
GuiTSCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F worldPosition = Point3F();
sscanf(x__worldPosition,"%f %f %f", &worldPosition.x,&worldPosition.y,&worldPosition.z);
Point3F wle_returnObject;
{
   Point3F screenPos;
   object->project( worldPosition, &screenPos );
   {wle_returnObject =screenPos;
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTSCtrl_getWorldToScreenScale(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
GuiTSCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point2F wle_returnObject;
{
   {wle_returnObject =object->getWorldToScreenScale();
dSprintf(retval,1024,"%f %f ",wle_returnObject.x,wle_returnObject.y);
return;
}
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnGuiTSCtrl_calculateViewDistance(char * x__object, float radius)
{
GuiTSCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (float)( object->calculateViewDistance( radius ));
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiBitmapButtonCtrl_setBitmap(char * x__object, char * x__path)
{
GuiBitmapButtonCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* path = (const char*)x__path;
{
   object->setBitmap( path );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiButtonBaseCtrl_performClick(char * x__object)
{
GuiButtonBaseCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->onAction();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiButtonBaseCtrl_setText(char * x__object, char * x__text)
{
GuiButtonBaseCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* text = (const char*)x__text;
{
   object->setText( text );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiButtonBaseCtrl_setTextID(char * x__object, char * x__id)
{
GuiButtonBaseCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* id = (const char*)x__id;
{
	object->setTextID( id );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiButtonBaseCtrl_getText(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiButtonBaseCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->getText( );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiButtonBaseCtrl_setStateOn(char * x__object, bool isOn)
{
GuiButtonBaseCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setStateOn( isOn );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiButtonBaseCtrl_resetState(char * x__object)
{
GuiButtonBaseCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->resetState();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCheckBoxCtrl_setStateOn(char * x__object, bool newState)
{
GuiCheckBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setStateOn( newState );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiCheckBoxCtrl_isStateOn(char * x__object)
{
GuiCheckBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->getStateOn();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiIconButtonCtrl_setBitmap(char * x__object, char * x__buttonFilename)
{
GuiIconButtonCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* buttonFilename = (const char*)x__buttonFilename;
{
   char* argBuffer = Con::getArgBuffer( 512 );
   Platform::makeFullPathName( buttonFilename, argBuffer, 512 );
   object->setBitmap( argBuffer );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiSwatchButtonCtrl_setColor(char * x__object, char * x__newColor)
{
GuiSwatchButtonCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* newColor = (const char*)x__newColor;
{
   object->setField( "color", newColor );
   object->execAltConsoleCallback();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiToolboxButtonCtrl_setNormalBitmap(char * x__object, char * x__a2)
{
GuiToolboxButtonCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->setNormalBitmap(argv[2]);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiToolboxButtonCtrl_setLoweredBitmap(char * x__object, char * x__a2)
{
GuiToolboxButtonCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->setLoweredBitmap(argv[2]);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiToolboxButtonCtrl_setHoverBitmap(char * x__object, char * x__a2)
{
GuiToolboxButtonCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->setHoverBitmap(argv[2]);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiAutoScrollCtrl_reset(char * x__object)
{
GuiAutoScrollCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->reset();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiDynamicCtrlArrayControl_refresh(char * x__object)
{
GuiDynamicCtrlArrayControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->refresh();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiFormCtrl_setCaption(char * x__object, char * x__caption)
{
GuiFormCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* caption = (const char*)x__caption;
{
   object->setCaption( caption );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiFrameSetCtrl_frameBorder(char * x__object, S32 index, char * x__state)
{
GuiFrameSetCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

const char* state = (const char*)x__state;
{
   object->frameBorderEnable( index, state );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiFrameSetCtrl_frameMovable(char * x__object, S32 index, char * x__state)
{
GuiFrameSetCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

const char* state = (const char*)x__state;
{
   object->frameBorderMovable( index, state );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiFrameSetCtrl_frameMinExtent(char * x__object, S32 index, S32 width, S32 height)
{
GuiFrameSetCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   Point2I extent( getMax( 0, width ), getMax( 0, height ) );
   object->frameMinExtent( index, extent);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiFrameSetCtrl_framePadding(char * x__object, S32 index, char * x__padding)
{
GuiFrameSetCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

RectSpacingI padding = RectSpacingI();
sscanf(x__padding, "%i %i %i %i", &padding.top, &padding.bottom, &padding.left, &padding.right);
{
   object->framePadding( index, padding);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiFrameSetCtrl_getFramePadding(char * x__object, S32 index,  char* retval)
{
dSprintf(retval,1024,"");
GuiFrameSetCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
RectSpacingI wle_returnObject;
{
   {wle_returnObject =object->getFramePadding( index );
dSprintf(retval,1024,"%i %i %i %i ",wle_returnObject.top,wle_returnObject.bottom,wle_returnObject.left,wle_returnObject.right);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiFrameSetCtrl_addColumn(char * x__object)
{
GuiFrameSetCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   Vector<S32> * columns = object->columnOffsets();
   columns->push_back(0);
   object->balanceFrames();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiFrameSetCtrl_addRow(char * x__object)
{
GuiFrameSetCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   Vector<S32> * rows = object->rowOffsets();
   rows->push_back(0);
   object->balanceFrames();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiFrameSetCtrl_removeColumn(char * x__object)
{
GuiFrameSetCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   Vector<S32> * columns = object->columnOffsets();
   if(columns->size() > 0)
   {
      columns->setSize(columns->size() - 1);
      object->balanceFrames();
   }
   else
      Con::errorf(ConsoleLogEntry::General, "No columns exist to remove");
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiFrameSetCtrl_removeRow(char * x__object)
{
GuiFrameSetCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   Vector<S32> * rows = object->rowOffsets();
   if(rows->size() > 0)
   {
      rows->setSize(rows->size() - 1);
      object->balanceFrames();
   }
   else
      Con::errorf(ConsoleLogEntry::General, "No rows exist to remove");
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiFrameSetCtrl_getColumnCount(char * x__object)
{
GuiFrameSetCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)((object->columnOffsets()->size()));
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiFrameSetCtrl_getRowCount(char * x__object)
{
GuiFrameSetCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)((object->rowOffsets()->size()));
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiFrameSetCtrl_getColumnOffset(char * x__object, S32 index)
{
GuiFrameSetCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   if(index < 0 || index > object->columnOffsets()->size())
   {
      Con::errorf(ConsoleLogEntry::General, "Column index out of range");
     return (S32)((0));
   }
  return (S32)(((*object->columnOffsets())[index]));
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiFrameSetCtrl_getRowOffset(char * x__object, S32 index)
{
GuiFrameSetCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   if(index < 0 || index > object->rowOffsets()->size())
   {
      Con::errorf(ConsoleLogEntry::General, "Row index out of range");
     return (S32)((0));
   }
  return (S32)(((*object->rowOffsets())[index]));
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiFrameSetCtrl_setColumnOffset(char * x__object, S32 index, S32 offset)
{
GuiFrameSetCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   Vector<S32> & columns = *(object->columnOffsets());
   if(index < 0 || index > columns.size())
   {
      Con::errorf(ConsoleLogEntry::General, "Column index out of range");
      return;
   }
   // check the offset
   if(((index > 0) && (offset < columns[index-1])) ||
      ((index < (columns.size() - 1)) && (offset > columns[index+1])))
   {
      Con::errorf(ConsoleLogEntry::General, "Invalid column offset");
      return;
   }
   columns[index] = offset;
   object->updateSizes();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiFrameSetCtrl_setRowOffset(char * x__object, S32 index, S32 offset)
{
GuiFrameSetCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   Vector<S32> & rows = *(object->rowOffsets());
   if(index < 0 || index > rows.size())
   {
      Con::errorf(ConsoleLogEntry::General, "Row index out of range");
      return;
   }
   // check the offset
   if(((index > 0) && (offset < rows[index-1])) ||
      ((index < (rows.size() - 1)) && (offset > rows[index+1])))
   {
      Con::errorf(ConsoleLogEntry::General, "Invalid row offset");
      return;
   }
   rows[index] = offset;
   object->updateSizes();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiFrameSetCtrl_updateSizes(char * x__object)
{
GuiFrameSetCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->updateSizes();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPaneControl_setCollapsed(char * x__object, bool collapse)
{
GuiPaneControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setCollapsed( collapse );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiRolloutCtrl_isExpanded(char * x__object)
{
GuiRolloutCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isExpanded();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiRolloutCtrl_collapse(char * x__object)
{
GuiRolloutCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->collapse();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiRolloutCtrl_expand(char * x__object)
{
GuiRolloutCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->expand();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiRolloutCtrl_toggleCollapse(char * x__object)
{
GuiRolloutCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   if( object->isExpanded() )
      object->collapse();
   else
	  object->expand();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiRolloutCtrl_toggleExpanded(char * x__object, bool instantly)
{
GuiRolloutCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->toggleExpanded( instantly );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiRolloutCtrl_instantCollapse(char * x__object)
{
GuiRolloutCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->instantCollapse();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiRolloutCtrl_instantExpand(char * x__object)
{
GuiRolloutCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->instantExpand();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiRolloutCtrl_sizeToContents(char * x__object)
{
GuiRolloutCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->sizeToContents();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiScrollCtrl_scrollToTop(char * x__object)
{
GuiScrollCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->scrollTo( 0, 0 );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiScrollCtrl_scrollToBottom(char * x__object)
{
GuiScrollCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->scrollTo( 0, 0x7FFFFFFF );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiScrollCtrl_setScrollPosition(char * x__object, S32 x, S32 y)
{
GuiScrollCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->scrollTo( x, y );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiScrollCtrl_scrollToObject(char * x__object, char * x__control)
{
GuiScrollCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
GuiControl* control; Sim::findObject(x__control, control ); 
{
   if( control )
      object->scrollToObject( control );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiScrollCtrl_getScrollPosition(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
GuiScrollCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point2I wle_returnObject;
{
   {wle_returnObject =object->getChildRelPos();
dSprintf(retval,1024,"%i %i ",wle_returnObject.x,wle_returnObject.y);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiScrollCtrl_getScrollPositionX(char * x__object)
{
GuiScrollCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getChildRelPos().x);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiScrollCtrl_getScrollPositionY(char * x__object)
{
GuiScrollCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getChildRelPos().y);
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiScrollCtrl_computeSizes(char * x__object)
{
GuiScrollCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->computeSizes();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiStackControl_isFrozen(char * x__object)
{
GuiStackControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isFrozen();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiStackControl_freeze(char * x__object, bool freeze)
{
GuiStackControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->freeze( freeze );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiStackControl_updateStack(char * x__object)
{
GuiStackControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->updatePanes();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTabBookCtrl_addPage(char * x__object, char * x__title)
{
GuiTabBookCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* title = (const char*)x__title;
{
   object->addNewPage( title );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTabBookCtrl_selectPage(char * x__object, S32 index)
{
GuiTabBookCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->selectPage( index );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTabBookCtrl_getSelectedPage(char * x__object)
{
GuiTabBookCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getSelectedPageNum());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiBitmapCtrl_setBitmap(char * x__object, char * x__a2, char * x__a3)
{
GuiBitmapCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   char filename[1024];
   Con::expandScriptFilename(filename, sizeof(filename), argv[2]);
   object->setBitmap(filename, argc > 3 ? dAtob( argv[3] ) : false );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiBitmapCtrl_setValue(char * x__object, S32 x, S32 y)
{
GuiBitmapCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->setValue(x, y);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiColorPickerCtrl_getSelectorPos(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiColorPickerCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
{
   char *temp = Con::getReturnBuffer(256);
   Point2I pos;
   pos = object->getSelectorPos();
   dSprintf(temp,256,"%d %d",pos.x, pos.y); 
   {wle_returnObject =temp;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiColorPickerCtrl_setSelectorPos(char * x__object, char * x__a2)
{
GuiColorPickerCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   Point2I newPos;
   dSscanf(argv[2], "%d %d", &newPos.x, &newPos.y);
   object->setSelectorPos(newPos);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiColorPickerCtrl_updateColor(char * x__object)
{
GuiColorPickerCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
	object->updateColor();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiDirectoryFileListCtrl_setFilter(char * x__object, char * x__filter)
{
GuiDirectoryFileListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* filter = (const char*)x__filter;
{
   object->setCurrentFilter( filter );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiDirectoryFileListCtrl_reload(char * x__object)
{
GuiDirectoryFileListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->update();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiDirectoryFileListCtrl_setPath(char * x__object, char * x__path, char * x__filter)
{
GuiDirectoryFileListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* path = (const char*)x__path;
const char* filter = (const char*)x__filter;
bool wle_returnObject;
{
   {wle_returnObject =object->setCurrentPath( path, filter );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiDirectoryFileListCtrl_getSelectedFiles(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiDirectoryFileListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   Vector<S32> ItemVector;
   object->getSelectedItems( ItemVector );
   if( ItemVector.empty() )
      {wle_returnObject =StringTable->insert( "" );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   // Get an adequate buffer
   char itemBuffer[256];
   dMemset( itemBuffer, 0, 256 );
   char* returnBuffer = Con::getReturnBuffer( ItemVector.size() * 64 );
   dMemset( returnBuffer, 0, ItemVector.size() * 64 );
   // Fetch the first entry
   StringTableEntry itemText = object->getItemText( ItemVector[0] );
   if( !itemText )
      {wle_returnObject =StringTable->lookup("");
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   dSprintf( returnBuffer, ItemVector.size() * 64, "%s", itemText );
   // If only one entry, return it.
   if( ItemVector.size() == 1 )
      {wle_returnObject =returnBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   // Fetch the remaining entries
   for( S32 i = 1; i < ItemVector.size(); i++ )
   {
      StringTableEntry itemText = object->getItemText( ItemVector[i] );
      if( !itemText )
         continue;
      dMemset( itemBuffer, 0, 256 );
      dSprintf( itemBuffer, 256, " %s", itemText );
      dStrcat( returnBuffer, itemBuffer );
   }
   {wle_returnObject =returnBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiDirectoryFileListCtrl_getSelectedFile(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiDirectoryFileListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->getSelectedFileName();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiFileTreeCtrl_getSelectedPath(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiFileTreeCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
{
   const String& path = object->getSelectedPath();
   {wle_returnObject =Con::getStringArg( path );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiFileTreeCtrl_setSelectedPath(char * x__object, char * x__a2)
{
GuiFileTreeCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
bool wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   {wle_returnObject =object->setSelectedPath( argv[ 2 ] );
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiFileTreeCtrl_reload(char * x__object)
{
GuiFileTreeCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->updateTree();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiGameListMenuCtrl_addRow(char * x__object, char * x__label, char * x__callback, S32 icon, S32 yPad, bool useHighlightIcon, bool enabled)
{
GuiGameListMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* label = (const char*)x__label;
const char* callback = (const char*)x__callback;


{
   object->addRow( label, callback, icon, yPad, useHighlightIcon, enabled );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiGameListMenuCtrl_isRowEnabled(char * x__object, S32 row)
{
GuiGameListMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isRowEnabled( row );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiGameListMenuCtrl_setRowEnabled(char * x__object, S32 row, bool enabled)
{
GuiGameListMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->setRowEnabled( row, enabled );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiGameListMenuCtrl_activateRow(char * x__object)
{
GuiGameListMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->activateRow();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiGameListMenuCtrl_getRowCount(char * x__object)
{
GuiGameListMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getRowCount());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiGameListMenuCtrl_getRowLabel(char * x__object, S32 row,  char* retval)
{
dSprintf(retval,4096,"");
GuiGameListMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char * wle_returnObject;
{
   {wle_returnObject =object->getRowLabel( row );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiGameListMenuCtrl_setRowLabel(char * x__object, S32 row, char * x__label)
{
GuiGameListMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

const char* label = (const char*)x__label;
{
   object->setRowLabel( row, label );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiGameListMenuCtrl_setSelected(char * x__object, S32 row)
{
GuiGameListMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setSelected( row );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiGameListMenuCtrl_getSelectedRow(char * x__object)
{
GuiGameListMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getSelected());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiGameListOptionsCtrl_addRow(char * x__object, char * x__label, char * x__options, bool wrapOptions, char * x__callback, S32 icon, S32 yPad, bool enabled)
{
GuiGameListOptionsCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* label = (const char*)x__label;
const char* options = (const char*)x__options;

const char* callback = (const char*)x__callback;


{
   object->addRow( label, options, wrapOptions, callback, icon, yPad, enabled );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiGameListOptionsCtrl_getCurrentOption(char * x__object, S32 row,  char* retval)
{
dSprintf(retval,4096,"");
GuiGameListOptionsCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char * wle_returnObject;
{
   {wle_returnObject =object->getCurrentOption( row );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiGameListOptionsCtrl_selectOption(char * x__object, S32 row, char * x__option)
{
GuiGameListOptionsCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

const char* option = (const char*)x__option;
bool wle_returnObject;
{
   {wle_returnObject =object->selectOption( row, option );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiGameListOptionsCtrl_setOptions(char * x__object, S32 row, char * x__optionsList)
{
GuiGameListOptionsCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

const char* optionsList = (const char*)x__optionsList;
{
   object->setOptions( row, optionsList );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiGradientCtrl_getColorCount(char * x__object)
{
GuiGradientCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
	if( object->getDisplayMode() == GuiGradientCtrl::pHorizColorRange )
		return object->mColorRange.size();
	else if( object->getDisplayMode() == GuiGradientCtrl::pHorizColorRange )
		return object->mColorRange.size();
	
	return 0;
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiGradientCtrl_getColor(char * x__object, char * x__a2,  char* retval)
{
dSprintf(retval,4096,"");
GuiGradientCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	S32 idx = dAtoi(argv[2]);
	if( object->getDisplayMode() == GuiGradientCtrl::pHorizColorRange )
	{
		if ( idx >= 0 && idx < object->mColorRange.size() )
		{
			char* rColor = Con::getReturnBuffer(256);
			rColor[0] = 0;
			dSprintf(rColor, 256, "%f %f %f %f",
				object->mColorRange[idx].swatch->getColor().red,
				object->mColorRange[idx].swatch->getColor().green,
				object->mColorRange[idx].swatch->getColor().blue,
				object->mColorRange[idx].swatch->getColor().alpha);
			{wle_returnObject =rColor;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
		}
	}
	else if( object->getDisplayMode() == GuiGradientCtrl::pHorizColorRange )
	{
		if ( idx >= 0 && idx < object->mAlphaRange.size() )
		{
			char* rColor = Con::getReturnBuffer(256);
			rColor[0] = 0;
			dSprintf(rColor, 256, "%f %f %f %f",
				object->mAlphaRange[idx].swatch->getColor().red,
				object->mAlphaRange[idx].swatch->getColor().green,
				object->mAlphaRange[idx].swatch->getColor().blue,
				object->mAlphaRange[idx].swatch->getColor().alpha);
			{wle_returnObject =rColor;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
		}
	}
	{wle_returnObject ="1 1 1 1";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiListBoxCtrl_setMultipleSelection(char * x__object, bool allowMultSelections)
{
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setMultipleSelection( allowMultSelections );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiListBoxCtrl_clearItems(char * x__object)
{
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->clearItems();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiListBoxCtrl_clearSelection(char * x__object)
{
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->clearSelection();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiListBoxCtrl_setSelected(char * x__object, S32 index, bool setSelected)
{
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   if( setSelected == true )
      object->addSelection( index );
   else
      object->removeSelection( index );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiListBoxCtrl_getItemCount(char * x__object)
{
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getItemCount());
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiListBoxCtrl_getSelCount(char * x__object)
{
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getSelCount());
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiListBoxCtrl_getSelectedItem(char * x__object)
{
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getSelectedItem());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiListBoxCtrl_getSelectedItems(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   S32 selCount = object->getSelCount();
   if( selCount == -1 || selCount == 0 )
      {wle_returnObject =StringTable->lookup("-1");
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   else if( selCount == 1 )
      {wle_returnObject =Con::getIntArg(object->getSelectedItem());
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   Vector<S32> selItems;
   object->getSelectedItems( selItems );
   if( selItems.empty() )
      {wle_returnObject =StringTable->lookup("-1");
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   UTF8 *retBuffer = Con::getReturnBuffer( selItems.size() * 4 );
   dMemset( retBuffer, 0, selItems.size() * 4 );
   Vector<S32>::iterator i = selItems.begin();
   for( ; i != selItems.end(); i++ )
   {
      UTF8 retFormat[12];
      dSprintf( retFormat, 12, "%d ", (*i) );
      dStrcat( retBuffer, retFormat );
   }
   {wle_returnObject =retBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiListBoxCtrl_findItemText(char * x__object, char * x__findText, bool bCaseSensitive)
{
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* findText = (const char*)x__findText;

{
  return (S32)( object->findItemText( findText, bCaseSensitive ));
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiListBoxCtrl_setCurSel(char * x__object, S32 indexId)
{
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setCurSel( indexId );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiListBoxCtrl_setCurSelRange(char * x__object, S32 indexStart, S32 indexStop)
{
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->setCurSelRange( indexStart , indexStop );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiListBoxCtrl_addItem(char * x__object, char * x__newItem, char * x__color)
{
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* newItem = (const char*)x__newItem;
const char* color = (const char*)x__color;
{
   if(dStricmp(color,"") == 0)
   {
     return (S32)( object->addItem( newItem ));
   }
   else
   {
      U32 elementCount = GuiListBoxCtrl::getStringElementCount(color);
     if(elementCount == 3)
     {
         F32 red, green, blue;
         red = dAtof(GuiListBoxCtrl::getStringElement( color, 0 ));
         green = dAtof(GuiListBoxCtrl::getStringElement( color, 1 ));
         blue = dAtof(GuiListBoxCtrl::getStringElement( color, 2 ));
        return (S32)( object->addItemWithColor( newItem, ColorF(red, green, blue) ));
     }
     else if(elementCount == 1)
     {
         U32 objId = dAtoi( color );
        return (S32)( object->addItem( newItem, (void*)objId ));
     }
     else
     {
         Con::warnf("GuiListBoxCtrl::addItem() - Invalid number of parameters for the color!");
        return (S32)( -1);
     }
   }
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiListBoxCtrl_setItemColor(char * x__object, S32 index, char * x__color)
{
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

ColorF color = ColorF();
sscanf(x__color,"%f %f %f %f",&color.red,&color.green,&color.blue,&color.alpha);
{
   object->setItemColor( index, color );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiListBoxCtrl_clearItemColor(char * x__object, S32 index)
{
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->clearItemColor(index);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiListBoxCtrl_insertItem(char * x__object, char * x__text, S32 index)
{
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* text = (const char*)x__text;

{
   object->insertItem( index, text );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiListBoxCtrl_deleteItem(char * x__object, S32 itemIndex)
{
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->deleteItem( itemIndex );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiListBoxCtrl_getItemText(char * x__object, S32 index,  char* retval)
{
dSprintf(retval,4096,"");
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->getItemText( index );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiListBoxCtrl_getItemObject(char * x__object, S32 index,  char* retval)
{
dSprintf(retval,4096,"");
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   SimObject *outObj = object->getItemObject( index );
   if ( !outObj )
      {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   {wle_returnObject =outObj->getIdString();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiListBoxCtrl_setItemText(char * x__object, S32 index, char * x__newtext)
{
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

const char* newtext = (const char*)x__newtext;
{
   object->setItemText(index, newtext );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiListBoxCtrl_setItemTooltip(char * x__object, S32 index, char * x__text)
{
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

const char* text = (const char*)x__text;
{
   if( index > object->mItems.size() || index < 0 )
   {
      Con::errorf( "GuiListBoxCtrl::setItemTooltip - index '%i' out of range", index );
      return;
   }
   
   object->mItems[ index ]->itemTooltip = text;
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiListBoxCtrl_getLastClickItem(char * x__object)
{
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   GuiListBoxCtrl::LBItem *lastItem = object->mLastClickItem;
   if ( !lastItem )
     return (S32)( -1);
  return (S32)( object->getItemIndex( lastItem ));
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiListBoxCtrl_doMirror(char * x__object)
{
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->_mirror();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiListBoxCtrl_addFilteredItem(char * x__object, char * x__newItem)
{
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* newItem = (const char*)x__newItem;
{
	String item(newItem);
	if( item == String::EmptyString )
		return;
	object->addFilteredItem( item );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiListBoxCtrl_removeFilteredItem(char * x__object, char * x__itemName)
{
GuiListBoxCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* itemName = (const char*)x__itemName;
{
	String item(itemName);
	if( item == String::EmptyString )
		return;
	object->removeFilteredItem( item );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiMaterialCtrl_setMaterial(char * x__object, char * x__a2)
{
GuiMaterialCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
bool wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   {wle_returnObject =object->setMaterial( argv[2] );
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_StripMLControlChars(char * x__inString,  char* retval)
{
dSprintf(retval,4096,"");
const char* inString = (const char*)x__inString;
const char* wle_returnObject;
{
   {wle_returnObject =GuiMLTextCtrl::stripControlChars(inString);
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMLTextCtrl_setText(char * x__object, char * x__text)
{
GuiMLTextCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* text = (const char*)x__text;
{
   object->setText(text, dStrlen(text));
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMLTextCtrl_getText(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiMLTextCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =( object->getTextContent() );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMLTextCtrl_addText(char * x__object, char * x__text, bool reformat)
{
GuiMLTextCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* text = (const char*)x__text;

{
   object->addText(text, dStrlen(text), reformat);
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiMLTextCtrl_setCursorPosition(char * x__object, int newPos)
{
GuiMLTextCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->setCursorPosition(newPos);
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMLTextCtrl_scrollToTag(char * x__object, int tagID)
{
GuiMLTextCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->scrollToTag( tagID );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMLTextCtrl_scrollToTop(char * x__object, S32 param1, S32 param2)
{
GuiMLTextCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->scrollToTop();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMLTextCtrl_scrollToBottom(char * x__object)
{
GuiMLTextCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->scrollToBottom();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMLTextCtrl_forceReflow(char * x__object)
{
GuiMLTextCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   if(!object->isAwake())
      Con::errorf("GuiMLTextCtrl::forceReflow can only be called on visible controls.");
   else
      object->reflow();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMLTextCtrl_setAlpha(char * x__object, F32 alphaVal)
{
GuiMLTextCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setAlpha(alphaVal);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrl_add(char * x__object, char * x__a2, char * x__a3, char * x__a4)
{
GuiPopUpMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
{
S32 argc = 5;
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
const char** argv = &arguments[0];
{
	if ( argc == 4 )
		object->addEntry(argv[2],dAtoi(argv[3]));
   if ( argc == 5 )
      object->addEntry(argv[2],dAtoi(argv[3]),dAtoi(argv[4]));
   else
      object->addEntry(argv[2]);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrl_addScheme(char * x__object, char * x__a2, char * x__a3, char * x__a4, char * x__a5)
{
GuiPopUpMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
{
S32 argc = 6;
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
if (argc>5)
arguments.push_back(a5);
const char** argv = &arguments[0];
{
   ColorI fontColor, fontColorHL, fontColorSEL;
   U32 r, g, b;
   char buf[64];
   dStrcpy( buf, argv[3] );
   char* temp = dStrtok( buf, " \0" );
   r = temp ? dAtoi( temp ) : 0;
   temp = dStrtok( NULL, " \0" );
   g = temp ? dAtoi( temp ) : 0;
   temp = dStrtok( NULL, " \0" );
   b = temp ? dAtoi( temp ) : 0;
   fontColor.set( r, g, b );
   dStrcpy( buf, argv[4] );
   temp = dStrtok( buf, " \0" );
   r = temp ? dAtoi( temp ) : 0;
   temp = dStrtok( NULL, " \0" );
   g = temp ? dAtoi( temp ) : 0;
   temp = dStrtok( NULL, " \0" );
   b = temp ? dAtoi( temp ) : 0;
   fontColorHL.set( r, g, b );
   dStrcpy( buf, argv[5] );
   temp = dStrtok( buf, " \0" );
   r = temp ? dAtoi( temp ) : 0;
   temp = dStrtok( NULL, " \0" );
   g = temp ? dAtoi( temp ) : 0;
   temp = dStrtok( NULL, " \0" );
   b = temp ? dAtoi( temp ) : 0;
   fontColorSEL.set( r, g, b );
   object->addScheme( dAtoi( argv[2] ), fontColor, fontColorHL, fontColorSEL );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrl_getText(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiPopUpMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
{
   {wle_returnObject =object->getText();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrl_clear(char * x__object)
{
GuiPopUpMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->clear();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrl_sort(char * x__object)
{
GuiPopUpMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->sort();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrl_sortID(char * x__object)
{
GuiPopUpMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->sortID();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrl_forceOnAction(char * x__object)
{
GuiPopUpMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->onAction();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrl_forceClose(char * x__object)
{
GuiPopUpMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->closePopUp();
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiPopUpMenuCtrl_getSelected(char * x__object)
{
GuiPopUpMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
  return (S32)( object->getSelected());
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrl_setSelected(char * x__object, char * x__a2, char * x__a3)
{
GuiPopUpMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   if( argc > 3 )
      object->setSelected( dAtoi( argv[2] ), dAtob( argv[3] ) );
   else
      object->setSelected( dAtoi( argv[2] ) );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrl_setFirstSelected(char * x__object, char * x__a2)
{
GuiPopUpMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	if( argc > 2 )
      object->setFirstSelected( dAtob( argv[2] ) );
   else
      object->setFirstSelected();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrl_setNoneSelected(char * x__object)
{
GuiPopUpMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->setNoneSelected();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrl_getTextById(char * x__object, char * x__a2,  char* retval)
{
dSprintf(retval,4096,"");
GuiPopUpMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   {wle_returnObject =(object->getTextById(dAtoi(argv[2])));
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrl_changeTextById(char * x__object, char * x__a2, char * x__a3)
{
GuiPopUpMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   object->setEntryText( dAtoi( argv[ 2 ] ), argv[ 3 ] );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrl_setEnumContent(char * x__object, char * x__a2, char * x__a3)
{
GuiPopUpMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   AbstractClassRep * classRep = AbstractClassRep::getClassList();
   // walk the class list to get our class
   while(classRep)
   {
      if(!dStricmp(classRep->getClassName(), argv[2]))
         break;
      classRep = classRep->getNextClass();
   }
   // get it?
   if(!classRep)
   {
      Con::warnf(ConsoleLogEntry::General, "failed to locate class rep for '%s'", argv[2]);
      return;
   }
   // walk the fields to check for this one (findField checks StringTableEntry ptrs...)
   U32 i;
   for(i = 0; i < classRep->mFieldList.size(); i++)
      if(!dStricmp(classRep->mFieldList[i].pFieldname, argv[3]))
         break;
   // found it?   
   if(i == classRep->mFieldList.size())
   {   
      Con::warnf(ConsoleLogEntry::General, "failed to locate field '%s' for class '%s'", argv[3], argv[2]);
      return;
   }
   const AbstractClassRep::Field & field = classRep->mFieldList[i];
   ConsoleBaseType* conType = ConsoleBaseType::getType( field.type );
   // check the type
   if( !conType->getEnumTable() )
   {
      Con::warnf(ConsoleLogEntry::General, "field '%s' is not an enumeration for class '%s'", argv[3], argv[2]);
      return;
   }
   // fill it
   const EngineEnumTable& table = *( conType->getEnumTable() );
   const U32 numValues = table.getNumValues();
   
   for(i = 0; i < numValues; i++)
      object->addEntry( table[i].getName(), table[i] );
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiPopUpMenuCtrl_findText(char * x__object, char * x__a2)
{
GuiPopUpMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
  return (S32)(( object->findText( argv[2] ) ));   
}
}
;
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiPopUpMenuCtrl_size(char * x__object)
{
GuiPopUpMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
  return (S32)(( object->getNumEntries() )); 
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrl_replaceText(char * x__object, char * x__a2)
{
GuiPopUpMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->replaceText(dAtoi(argv[2]));  
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrl_clearEntry(char * x__object, char * x__a2)
{
GuiPopUpMenuCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->clearEntry(dAtoi(argv[2]));  
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrlEx_add(char * x__object, char * x__a2, char * x__a3, char * x__a4)
{
GuiPopUpMenuCtrlEx* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
{
S32 argc = 5;
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
const char** argv = &arguments[0];
{
	if ( argc == 4 )
		object->addEntry(argv[2],dAtoi(argv[3]));
   if ( argc == 5 )
      object->addEntry(argv[2],dAtoi(argv[3]),dAtoi(argv[4]));
   else
      object->addEntry(argv[2]);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrlEx_setSelected(char * x__object, char * x__a2, char * x__a3)
{
GuiPopUpMenuCtrlEx* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   if( argc > 3 )
      object->setSelected( dAtoi( argv[2] ), dAtob( argv[3] ) );
   else
      object->setSelected( dAtoi( argv[2] ) );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrlEx_setFirstSelected(char * x__object, char * x__a2)
{
GuiPopUpMenuCtrlEx* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   if( argc > 2 )
      object->setFirstSelected( dAtob( argv[2] ) );
   else
      object->setFirstSelected();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrlEx_getColorById(char * x__object, char * x__a2,  char* retval)
{
dSprintf(retval,4096,"");
GuiPopUpMenuCtrlEx* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   ColorI color;
   object->getColoredBox(color, dAtoi(argv[2]));
   char *strBuffer = Con::getReturnBuffer(512);
   dSprintf(strBuffer, 512, "%d %d %d %d", color.red, color.green, color.blue, color.alpha);
   {wle_returnObject =strBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrlEx_setEnumContent(char * x__object, char * x__a2, char * x__a3)
{
GuiPopUpMenuCtrlEx* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   AbstractClassRep * classRep = AbstractClassRep::getClassList();
   // walk the class list to get our class
   while(classRep)
   {
      if(!dStricmp(classRep->getClassName(), argv[2]))
         break;
      classRep = classRep->getNextClass();
   }
   // get it?
   if(!classRep)
   {
      Con::warnf(ConsoleLogEntry::General, "failed to locate class rep for '%s'", argv[2]);
      return;
   }
   // walk the fields to check for this one (findField checks StringTableEntry ptrs...)
   U32 i;
   for(i = 0; i < classRep->mFieldList.size(); i++)
      if(!dStricmp(classRep->mFieldList[i].pFieldname, argv[3]))
         break;
   // found it?   
   if(i == classRep->mFieldList.size())
   {   
      Con::warnf(ConsoleLogEntry::General, "failed to locate field '%s' for class '%s'", argv[3], argv[2]);
      return;
   }
   const AbstractClassRep::Field & field = classRep->mFieldList[i];
   ConsoleBaseType* conType = ConsoleBaseType::getType( field.type );
   // check the type
   if( !conType->getEnumTable() )
   {
      Con::warnf(ConsoleLogEntry::General, "field '%s' is not an enumeration for class '%s'", argv[3], argv[2]);
      return;
   }
   // fill it
   const EngineEnumTable& table = *( conType->getEnumTable() );
   const U32 numValues = table.getNumValues();
   
   for(i = 0; i < numValues; i++)
      object->addEntry( table[i].getName(), table[i] );
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiPopUpMenuCtrlEx_findText(char * x__object, char * x__a2)
{
GuiPopUpMenuCtrlEx* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
  return (S32)(( object->findText( argv[2] ) ));   
}
}
;
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiPopUpMenuCtrlEx_size(char * x__object)
{
GuiPopUpMenuCtrlEx* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
  return (S32)(( object->getNumEntries() )); 
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrlEx_replaceText(char * x__object, char * x__a2)
{
GuiPopUpMenuCtrlEx* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->replaceText(dAtoi(argv[2]));  
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrlEx_clearEntry(char * x__object, char * x__a2)
{
GuiPopUpMenuCtrlEx* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->clearEntry(dAtoi(argv[2]));  
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrlEx_addCategory(char * x__object, char * x__text)
{
GuiPopUpMenuCtrlEx* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* text = (const char*)x__text;
{
	object->addEntry(text, -1, 0);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrlEx_addScheme(char * x__object, S32 id, char * x__fontColor, char * x__fontColorHL, char * x__fontColorSEL)
{
GuiPopUpMenuCtrlEx* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

ColorI fontColor = ColorI();
sscanf(x__fontColor,"%i %i %i %i",&fontColor.red,&fontColor.green,&fontColor.blue,&fontColor.alpha);
ColorI fontColorHL = ColorI();
sscanf(x__fontColorHL,"%i %i %i %i",&fontColorHL.red,&fontColorHL.green,&fontColorHL.blue,&fontColorHL.alpha);
ColorI fontColorSEL = ColorI();
sscanf(x__fontColorSEL,"%i %i %i %i",&fontColorSEL.red,&fontColorSEL.green,&fontColorSEL.blue,&fontColorSEL.alpha);
{
	/*ColorI fontColor, fontColorHL, fontColorSEL;
   U32 r, g, b;
   char buf[64];
   dStrcpy( buf, argv[3] );
   char* temp = dStrtok( buf, " \0" );
   r = temp ? dAtoi( temp ) : 0;
   temp = dStrtok( NULL, " \0" );
   g = temp ? dAtoi( temp ) : 0;
   temp = dStrtok( NULL, " \0" );
   b = temp ? dAtoi( temp ) : 0;
   fontColor.set( r, g, b );
   dStrcpy( buf, argv[4] );
   temp = dStrtok( buf, " \0" );
   r = temp ? dAtoi( temp ) : 0;
   temp = dStrtok( NULL, " \0" );
   g = temp ? dAtoi( temp ) : 0;
   temp = dStrtok( NULL, " \0" );
   b = temp ? dAtoi( temp ) : 0;
   fontColorHL.set( r, g, b );
   dStrcpy( buf, argv[5] );
   temp = dStrtok( buf, " \0" );
   r = temp ? dAtoi( temp ) : 0;
   temp = dStrtok( NULL, " \0" );
   g = temp ? dAtoi( temp ) : 0;
   temp = dStrtok( NULL, " \0" );
   b = temp ? dAtoi( temp ) : 0;
   fontColorSEL.set( r, g, b );*/
   object->addScheme( id, fontColor, fontColorHL, fontColorSEL );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrlEx_setText(char * x__object, char * x__text)
{
GuiPopUpMenuCtrlEx* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* text = (const char*)x__text;
{
	object->setText(text);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrlEx_getText(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiPopUpMenuCtrlEx* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
	{wle_returnObject =object->getText();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrlEx_clear(char * x__object)
{
GuiPopUpMenuCtrlEx* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrlEx_sort(char * x__object)
{
GuiPopUpMenuCtrlEx* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->sort();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrlEx_sortID(char * x__object)
{
GuiPopUpMenuCtrlEx* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->sortID();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrlEx_forceOnAction(char * x__object)
{
GuiPopUpMenuCtrlEx* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->onAction();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrlEx_forceClose(char * x__object)
{
GuiPopUpMenuCtrlEx* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->closePopUp();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiPopUpMenuCtrlEx_getSelected(char * x__object)
{
GuiPopUpMenuCtrlEx* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
	return object->getSelected();
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrlEx_setNoneSelected(char * x__object, S32 param)
{
GuiPopUpMenuCtrlEx* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->setNoneSelected();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiPopUpMenuCtrlEx_getTextById(char * x__object, S32 id,  char* retval)
{
dSprintf(retval,4096,"");
GuiPopUpMenuCtrlEx* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
	{wle_returnObject =(object->getTextById(id));
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnGuiSliderCtrl_getValue(char * x__object)
{
GuiSliderCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getValue());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiSliderCtrl_setValue(char * x__object, F32 pos, bool doCallback)
{
GuiSliderCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->setValue( pos, doCallback );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiSliderCtrl_isThumbBeingDragged(char * x__object)
{
GuiSliderCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isThumbBeingDragged();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTabPageCtrl_select(char * x__object)
{
GuiTabPageCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   GuiTabBookCtrl* book = dynamic_cast< GuiTabBookCtrl* >( object->getParent() );
   if( !book )
      return;
   book->selectPage( object );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTextCtrl_setText(char * x__object, char * x__text)
{
GuiTextCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* text = (const char*)x__text;
{
   object->setText( text );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTextCtrl_setTextID(char * x__object, char * x__textID)
{
GuiTextCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* textID = (const char*)x__textID;
{
	object->setTextID( textID );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTextEditCtrl_getText(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiTextEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   if( !object->hasText() )
      {wle_returnObject =StringTable->insert("");
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   char *retBuffer = Con::getReturnBuffer( GuiTextEditCtrl::MAX_STRING_LENGTH );
   object->getText( retBuffer );
   {wle_returnObject =retBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTextEditCtrl_setText(char * x__object, char * x__text)
{
GuiTextEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* text = (const char*)x__text;
{
   object->setText( text );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTextEditCtrl_getCursorPos(char * x__object)
{
GuiTextEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)(( object->getCursorPos() ));
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTextEditCtrl_setCursorPos(char * x__object, int position)
{
GuiTextEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setCursorPos( position );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTextEditCtrl_isAllTextSelected(char * x__object)
{
GuiTextEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isAllTextSelected();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTextEditCtrl_selectAllText(char * x__object)
{
GuiTextEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->selectAllText();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTextEditCtrl_clearSelectedText(char * x__object)
{
GuiTextEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->clearSelectedText();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTextEditCtrl_forceValidateText(char * x__object)
{
GuiTextEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->forceValidateText();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTextListCtrl_getSelectedId(char * x__object)
{
GuiTextListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getSelectedId());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTextListCtrl_setSelectedById(char * x__object, int id)
{
GuiTextListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   S32 index = object->findEntryById(id);
   if(index < 0)
      return ;
   object->setSelectedCell(Point2I(0, index));
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTextListCtrl_setSelectedRow(char * x__object, int rowNum)
{
GuiTextListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setSelectedCell( Point2I( 0, rowNum ) );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTextListCtrl_getSelectedRow(char * x__object)
{
GuiTextListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getSelectedRow());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTextListCtrl_clearSelection(char * x__object)
{
GuiTextListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setSelectedCell(Point2I(-1, -1));
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTextListCtrl_addRow(char * x__object, int id, char * x__text, int index)
{
GuiTextListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

const char* text = (const char*)x__text;

{
   S32 ret = object->mList.size();
   if(index == -1)
      object->addEntry(id, text);
   else
      object->insertEntry(id, text, index);
  return (S32)( ret);
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTextListCtrl_setRowById(char * x__object, int id, char * x__text)
{
GuiTextListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

const char* text = (const char*)x__text;
{
   object->setEntry(id, text);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTextListCtrl_sort(char * x__object, int columnId, bool increasing)
{
GuiTextListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
     object->sort( columnId, increasing );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTextListCtrl_sortNumerical(char * x__object, int columnID, bool increasing)
{
GuiTextListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
     object->sortNumerical( columnID, increasing );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTextListCtrl_clear(char * x__object)
{
GuiTextListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->clear();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTextListCtrl_rowCount(char * x__object)
{
GuiTextListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getNumEntries());
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTextListCtrl_getRowId(char * x__object, int index)
{
GuiTextListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   if(index >= object->getNumEntries())
     return (S32)( -1);
  return (S32)( object->mList[index].id);
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTextListCtrl_getRowTextById(char * x__object, int id,  char* retval)
{
dSprintf(retval,4096,"");
GuiTextListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   S32 index = object->findEntryById(id);
   if(index < 0)
      {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   {wle_returnObject =object->mList[index].text;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTextListCtrl_getRowNumById(char * x__object, int id)
{
GuiTextListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   S32 index = object->findEntryById(id);
   if(index < 0)
     return (S32)( -1);
  return (S32)( index);
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTextListCtrl_getRowText(char * x__object, int index,  char* retval)
{
dSprintf(retval,4096,"");
GuiTextListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   if(index < 0 || index >= object->mList.size())
      {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   {wle_returnObject =object->mList[index].text;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTextListCtrl_removeRowById(char * x__object, int id)
{
GuiTextListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->removeEntry(id);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTextListCtrl_removeRow(char * x__object, int index)
{
GuiTextListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->removeEntryByIndex(index);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTextListCtrl_scrollVisible(char * x__object, int rowNum)
{
GuiTextListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->scrollCellVisible(Point2I(0, rowNum));
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTextListCtrl_findTextIndex(char * x__object, char * x__needle)
{
GuiTextListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* needle = (const char*)x__needle;
{
  return (S32)(( object->findEntryByText(needle) ));
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTextListCtrl_setRowActive(char * x__object, int rowNum, bool active)
{
GuiTextListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->setEntryActive( U32( rowNum ), active );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTextListCtrl_isRowActive(char * x__object, int rowNum)
{
GuiTextListCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =( object->isEntryActive( U32( rowNum ) ) );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_addChildSelectionByValue(char * x__object, char * x__a2, char * x__a3)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   S32 id = dAtoi(argv[2]);
   GuiTreeViewCtrl::Item* parentItem = object->getItem(id);
   GuiTreeViewCtrl::Item* child = parentItem->findChildByValue(argv[3]);
   object->addSelection(child->getID());
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_removeSelection(char * x__object, char * x__a2)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   S32 id = dAtoi(argv[2]);
   object->removeSelection(id);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_removeChildSelectionByValue(char * x__object, char * x__a2, char * x__a3)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   S32 id = dAtoi(argv[2]);
   GuiTreeViewCtrl::Item* parentItem = object->getItem(id);
   if(parentItem)
   {
      GuiTreeViewCtrl::Item* child = parentItem->findChildByValue(argv[3]);
	  if(child)
	  {
         object->removeSelection(child->getID());
	  }
   }
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_selectItem(char * x__object, char * x__a2, char * x__a3)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
bool wle_returnObject;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   S32 id = dAtoi(argv[2]);
   bool select = true;
   if(argc == 4)
      select = dAtob(argv[3]);
   {wle_returnObject =(object->setItemSelected(id, select));
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_expandItem(char * x__object, char * x__a2, char * x__a3)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
bool wle_returnObject;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   S32 id = dAtoi(argv[2]);
   bool expand = true;
   if(argc == 4)
      expand = dAtob(argv[3]);
   {wle_returnObject =(object->setItemExpanded(id, expand));
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_markItem(char * x__object, char * x__a2, char * x__a3)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
bool wle_returnObject;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   S32 id = dAtoi(argv[2]);
   bool mark = true;
   if(argc == 4)
      mark = dAtob(argv[3]);
   {wle_returnObject =object->markItem(id, mark);
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_scrollVisible(char * x__object, char * x__a2)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->scrollVisible(dAtoi(argv[2]));
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_buildIconTable(char * x__object, char * x__a2)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
bool wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{   
   const char * icons = argv[2];
   {wle_returnObject =object->buildIconTable(icons);
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_open(char * x__object, char * x__a2, char * x__a3)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   SimSet *treeRoot = NULL;
   SimObject* target = Sim::findObject(argv[2]);
   bool okToEdit = true;
   if (argc == 4)
      okToEdit = dAtob(argv[3]);
   if (target)
      treeRoot = dynamic_cast<SimSet*>(target);
   if (! treeRoot)
      Sim::findObject(RootGroupId, treeRoot);
   object->inspectObject(treeRoot,okToEdit);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_setItemTooltip(char * x__object, char * x__a2, char * x__a3)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   int id = dAtoi( argv[ 2 ] );
   
   GuiTreeViewCtrl::Item* item = object->getItem( id );
   if( !item )
   {
      Con::errorf( "GuiTreeViewCtrl::setTooltip() - invalid item id '%i'", id );
      return;
   }
   
   item->mTooltip = argv[ 3 ];
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_setItemImages(char * x__object, char * x__a2, char * x__a3, char * x__a4)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
{
S32 argc = 5;
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
const char** argv = &arguments[0];
{
   int id = dAtoi( argv[ 2 ] );
   GuiTreeViewCtrl::Item* item = object->getItem( id );
   if( !item )
   {
      Con::errorf( "GuiTreeViewCtrl::setItemImages() - invalid item id '%i'", id );
      return;
   }
   item->setNormalImage((S8)dAtoi(argv[3]));
   item->setExpandedImage((S8)dAtoi(argv[4]));
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_isParentItem(char * x__object, char * x__a2)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
bool wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   int id = dAtoi( argv[ 2 ] );
   if( !id && object->getItemCount() )
      {wle_returnObject =true;
return (S32)(wle_returnObject);}
   
   GuiTreeViewCtrl::Item* item = object->getItem( id );
   if( !item )
   {
      Con::errorf( "GuiTreeViewCtrl::isParentItem - invalid item id '%i'", id );
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   }
   
   {wle_returnObject =item->isParent();
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_getItemText(char * x__object, char * x__a2,  char* retval)
{
dSprintf(retval,4096,"");
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char * wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   {wle_returnObject =(object->getItemText(dAtoi(argv[2])));
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_getItemValue(char * x__object, char * x__a2,  char* retval)
{
dSprintf(retval,4096,"");
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char * wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   {wle_returnObject =(object->getItemValue(dAtoi(argv[2])));
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_editItem(char * x__object, char * x__a2, char * x__a3, char * x__a4)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
bool wle_returnObject;
{
S32 argc = 5;
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
const char** argv = &arguments[0];
{
   {wle_returnObject =(object->editItem(dAtoi(argv[2]), argv[3], argv[4]));
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_removeItem(char * x__object, char * x__a2)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
bool wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   {wle_returnObject =(object->removeItem(dAtoi(argv[2])));
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_removeAllChildren(char * x__object, char * x__a2)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->removeAllChildren(dAtoi(argv[2]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_clear(char * x__object)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->removeItem(0);
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_getFirstRootItem(char * x__object)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
  return (S32)((object->getFirstRootItem()));
}
}
;
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_getChild(char * x__object, char * x__a2)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
  return (S32)((object->getChildItem(dAtoi(argv[2]))));
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_buildVisibleTree(char * x__object, char * x__a2)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   bool forceFullUpdate = false;
   if( argc > 2 )
      forceFullUpdate = dAtob( argv[ 2 ] );
      
   object->buildVisibleTree( forceFullUpdate );
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_getParent(char * x__object, char * x__a2)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
  return (S32)((object->getParentItem(dAtoi(argv[2]))));
}
}
;
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_getNextSibling(char * x__object, char * x__a2)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
  return (S32)((object->getNextSiblingItem(dAtoi(argv[2]))));
}
}
;
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_getPrevSibling(char * x__object, char * x__a2)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
  return (S32)((object->getPrevSiblingItem(dAtoi(argv[2]))));
}
}
;
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_getItemCount(char * x__object)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
  return (S32)((object->getItemCount()));
}
}
;
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_getSelectedItem(char * x__object, char * x__a2)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   S32 index = 0;
   if( argc > 2 )
      index = dAtoi( argv[ 2 ] );
      
  return (S32)( ( object->getSelectedItem( index ) ));
}
}
;
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_getSelectedObject(char * x__object, char * x__a2)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   S32 index = 0;
   if( argc > 2 )
      index = dAtoi( argv[ 2 ] );
   GuiTreeViewCtrl::Item *item = object->getItem( object->getSelectedItem( index ) );
   if( item != NULL && item->isInspectorData() )
   {
      SimObject *obj = item->getObject();
      if( obj != NULL )
        return (S32)( obj->getId());
   }
  return (S32)( -1);
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_getSelectedObjectList(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
{
   char* buff = Con::getReturnBuffer(1024);
   dSprintf(buff,1024,"");
   const Vector< GuiTreeViewCtrl::Item* > selectedItems = object->getSelectedItems();
   for(int i = 0; i < selectedItems.size(); i++)
   {
      GuiTreeViewCtrl::Item *item = selectedItems[i];
      if ( item->isInspectorData() && item->getObject() )
      {      
         S32 id  = item->getObject()->getId();
         //get the current length of the buffer
         U32	len = dStrlen(buff);
         //the start of the buffer where we want to write
         char* buffPart = buff+len;
         //the size of the remaining buffer (-1 cause dStrlen doesn't count the \0)
         S32 size	=	1024-len-1;
         //write it:
         if(size < 1)
         {
            Con::errorf("GuiTreeViewCtrl::getSelectedItemList - Not enough room to return our object list");
            {wle_returnObject =buff;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
         }
         dSprintf(buffPart,size,"%d ", id);
      }
   }
   {wle_returnObject =buff;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_moveItemUp(char * x__object, char * x__a2)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->moveItemUp( dAtoi( argv[2] ) );
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_getSelectedItemsCount(char * x__object)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
  return (S32)( ( object->getSelectedItemsCount() ));
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_moveItemDown(char * x__object, char * x__a2)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->moveItemDown( dAtoi( argv[2] ) );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_getTextToRoot(char * x__object, char * x__a2, char * x__a3,  char* retval)
{
dSprintf(retval,4096,"");
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* wle_returnObject;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   if ( argc < 4 )
   {
      Con::warnf("GuiTreeViewCtrl::getTextToRoot - Invalid number of arguments!");
      {wle_returnObject =("");
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   }
   S32 itemId = dAtoi( argv[2] );
   StringTableEntry delimiter = argv[3];
   {wle_returnObject =object->getTextToRoot( itemId, delimiter );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_getSelectedItemList(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
{
	char* buff = Con::getReturnBuffer(1024);
	dSprintf(buff,1024,"");
   const Vector< S32 >& selected = object->getSelected();
	for(int i = 0; i < selected.size(); i++)
	{
		S32 id  = selected[i];
		//get the current length of the buffer
		U32	len = dStrlen(buff);
		//the start of the buffer where we want to write
		char* buffPart = buff+len;
		//the size of the remaining buffer (-1 cause dStrlen doesn't count the \0)
		S32 size	=	1024-len-1;
		//write it:
		if(size < 1)
		{
			Con::errorf("GuiTreeViewCtrl::getSelectedItemList - Not enough room to return our object list");
			{wle_returnObject =buff;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
		}
		dSprintf(buffPart,size,"%d ", id);
	}
//mSelected
	{wle_returnObject =buff;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_findItemByObjectId(char * x__object, char * x__a2)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
  return (S32)((object->findItemByObjectId(dAtoi(argv[2]))));
}
}
;
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_scrollVisibleByObjectId(char * x__object, char * x__a2)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
  return (S32)((object->scrollVisibleByObjectId(dAtoi(argv[2]))));
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_sort(char * x__object, char * x__a2, char * x__a3, char * x__a4, char * x__a5)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
{
S32 argc = 6;
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
if (argc>5)
arguments.push_back(a5);
const char** argv = &arguments[0];
{
   S32 parent = 0;
   if( argc >= 3 )
      parent = dAtoi( argv[ 2 ] );
   bool traverseHierarchy = false;
   bool parentsFirst = false;
   bool caseSensitive = true;
   
   if( argc >= 4 )
      traverseHierarchy = dAtob( argv[ 3 ] );
   if( argc >= 5 )
      parentsFirst = dAtob( argv[ 4 ] );
   if( argc >= 6 )
      caseSensitive = dAtob( argv[ 5 ] );
      
   if( !parent )
      object->sortTree( caseSensitive, traverseHierarchy, parentsFirst );
   else
   {
      GuiTreeViewCtrl::Item* item = object->getItem( parent );
      if( !item )
      {
         Con::errorf( "GuiTreeViewCtrl::sort - no item '%i' in tree", parent );
         return;
      }
      
      item->sort( caseSensitive, traverseHierarchy, parentsFirst );
   }
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_cancelRename(char * x__object)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->cancelRename();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_onRenameValidate(char * x__object)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->onRenameValidate();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_showItemRenameCtrl(char * x__object, char * x__a2)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   S32 id = dAtoi( argv[ 2 ] );
   GuiTreeViewCtrl::Item* item = object->getItem( id );
   if( !item )
   {
      Con::errorf( "GuiTreeViewCtrl::showItemRenameCtrl - invalid item id '%i'", id );
      return;
   }
   
   object->showItemRenameCtrl( item );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_setDebug(char * x__object, char * x__a2)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   bool value = true;
   if( argc > 2 )
      value = dAtob( argv[ 2 ] );
      
   object->setDebug( value );
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_findItemByName(char * x__object, char * x__text)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* text = (const char*)x__text;
{
  return (S32)( object->findItemByName( text ));
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_findItemByValue(char * x__object, char * x__value)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* value = (const char*)x__value;
{
  return (S32)( object->findItemByValue( value ));
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_findChildItemByName(char * x__object, S32 parentId, char * x__childName)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

const char* childName = (const char*)x__childName;
{
   if( parentId == 0 )
   {
      if( !object->getRootItem() )
        return (S32)( 0);
         
      GuiTreeViewCtrl::Item* root = object->getRootItem();
      while( root )
      {
         if( dStricmp( root->getText(), childName ) == 0 )
           return (S32)( root->getID());
            
         root = root->mNext;
      }
      
     return (S32)( 0);
   }
   else
   {
      GuiTreeViewCtrl::Item* item = object->getItem( parentId );
      
      if( !item )
      {
         Con::errorf( "GuiTreeViewCtrl.findChildItemByName - invalid parent ID '%i'", parentId );
        return (S32)( 0);
      }
      
      GuiTreeViewCtrl::Item* child = item->findChildByName( childName );
      if( !child )
        return (S32)( 0);
      
     return (S32)( child->mId);
   }
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_insertItem(char * x__object, S32 parentId, char * x__text, char * x__value, char * x__icon, S32 normalImage, S32 expandedImage)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

const char* text = (const char*)x__text;
const char* value = (const char*)x__value;
const char* icon = (const char*)x__icon;

{
  return (S32)( object->insertItem( parentId, text, value, icon, normalImage, expandedImage ));
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_lockSelection(char * x__object, bool lock)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->lockSelection( lock );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_hideSelection(char * x__object, bool state)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->hideSelection( state );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_toggleLockSelection(char * x__object)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->toggleLockSelection();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_toggleHideSelection(char * x__object)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->toggleHideSelection();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_clearSelection(char * x__object)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->clearSelection();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_deleteSelection(char * x__object)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->deleteSelection();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_addSelection(char * x__object, S32 id, bool isLastSelection)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->addSelection( id, isLastSelection, isLastSelection );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTreeViewCtrl_isItemSelected(char * x__object, S32 id)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   const Vector< GuiTreeViewCtrl::Item* >& selectedItems = object->getSelectedItems();
	for( S32 i = 0; i < selectedItems.size(); ++ i )
      if( selectedItems[ i ]->mId == id )
         {wle_returnObject =true;
return (S32)(wle_returnObject);}
         
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_getFilterText(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->getFilterText();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_setFilterText(char * x__object, char * x__pattern)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* pattern = (const char*)x__pattern;
{
   object->setFilterText( pattern );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTreeViewCtrl_clearFilterText(char * x__object)
{
GuiTreeViewCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->clearFilterText();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_pushDialog(char * x__object, char * x__a2, char * x__a3, char * x__a4)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
{
S32 argc = 5;
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
const char** argv = &arguments[0];
{
   GuiControl *gui;
   if (!	Sim::findObject(argv[2], gui))
   {
      Con::printf("%s(): Invalid control: %s", argv[0], argv[2]);
      return;
   }
   //find the layer
   S32 layer = 0;
   if( argc > 3 )
      layer = dAtoi( argv[ 3 ] );
      
   bool center = false;
   if( argc > 4 )
      center = dAtob( argv[ 4 ] );
   //set the new content control
   object->pushDialogControl(gui, layer, center);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_popDialog(char * x__object, char * x__a2)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   GuiControl *gui = NULL;
   if (argc == 3)
   {
      if (!Sim::findObject(argv[2], gui))
      {
         Con::printf("%s(): Invalid control: %s", argv[0], argv[2]);
         return;
      }
   }
   if (gui)
      object->popDialogControl(gui);
   else
      object->popDialogControl();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_popLayer(char * x__object, char * x__a2)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   S32 layer = 0;
   if (argc == 3)
      layer = dAtoi(argv[2]);
   object->popDialogControl(layer);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_setCursorPos(char * x__object, char * x__a2, char * x__a3)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   Point2I pos(0,0);
   if(argc == 4)
      pos.set(dAtoi(argv[2]), dAtoi(argv[3]));
   else
      dSscanf(argv[2], "%d %d", &pos.x, &pos.y);
   object->setCursorPos(pos);
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiCanvas_isFullscreen(char * x__object)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
{
   if (Platform::getWebDeployment())
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   if (!object->getPlatformWindow())
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   {wle_returnObject =object->getPlatformWindow()->getVideoMode().fullScreen;
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_minimizeWindow(char * x__object)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   PlatformWindow* window = object->getPlatformWindow();
   if ( window )
      window->minimize();
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiCanvas_isMinimized(char * x__object)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
{
   PlatformWindow* window = object->getPlatformWindow();
   if ( window )
      {wle_returnObject =window->isMinimized();
return (S32)(wle_returnObject);}
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiCanvas_isMaximized(char * x__object)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
{
   PlatformWindow* window = object->getPlatformWindow();
   if ( window )
      {wle_returnObject =window->isMaximized();
return (S32)(wle_returnObject);}
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_maximizeWindow(char * x__object)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   PlatformWindow* window = object->getPlatformWindow();
   if ( window )
      window->maximize();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_restoreWindow(char * x__object)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   PlatformWindow* window = object->getPlatformWindow();
   if( window )
      window->restore();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_setFocus(char * x__object)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   PlatformWindow* window = object->getPlatformWindow();
   if( window )
      window->setFocus();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_setVideoMode(char * x__object, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
{
S32 argc = 8;
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
if (argc>5)
arguments.push_back(a5);
if (argc>6)
arguments.push_back(a6);
if (argc>7)
arguments.push_back(a7);
const char** argv = &arguments[0];
{
   if (!object->getPlatformWindow())
      return;
   
   if (Journal::IsRecording() || Journal::IsPlaying())   
      return;
   // Update the video mode and tell the window to reset.
   GFXVideoMode vm = object->getPlatformWindow()->getVideoMode();
   U32 width = dAtoi(argv[2]);
   U32 height = dAtoi(argv[3]);
   bool changed = false;
   if (width == 0 && height > 0)
   {
      // Our width is 0 but our height isn't...
      // Try to find a matching width
      for(S32 i=0; i<object->getPlatformWindow()->getGFXDevice()->getVideoModeList()->size(); i++)
      {
         const GFXVideoMode &newVm = (*(object->getPlatformWindow()->getGFXDevice()->getVideoModeList()))[i];
         if(newVm.resolution.y == height)
         {
            width = newVm.resolution.x;
            changed = true;
            break;
         }
      }
   }
   else if (height == 0 && width > 0)
   {
      // Our height is 0 but our width isn't...
      // Try to find a matching height
      for(S32 i=0; i<object->getPlatformWindow()->getGFXDevice()->getVideoModeList()->size(); i++)
      {
         const GFXVideoMode &newVm = (*(object->getPlatformWindow()->getGFXDevice()->getVideoModeList()))[i];
         if(newVm.resolution.x == width)
         {
            height = newVm.resolution.y;
            changed = true;
            break;
         }
      }
   }
   if (width == 0 || height == 0)
   {
      // Got a bad size for both of our dimensions or one of our dimensions and
      // didn't get a match for the other default back to our current resolution
      width  = vm.resolution.x;
      height = vm.resolution.y;
      changed = true;
   }
   if (changed)
      Con::errorf("GuiCanvas::setVideoMode(): Error - Invalid resolution of (%d, %d) - attempting (%d, %d)", dAtoi(argv[2]), dAtoi(argv[3]), width, height);
   vm.resolution  = Point2I(width, height);
   vm.fullScreen  = dAtob(argv[4]);
   if (Platform::getWebDeployment())
      vm.fullScreen  = false;
   // These optional params are set to default at construction of vm. If they
   // aren't specified, just leave them at whatever they were set to.
   if ((argc > 5) && (dStrlen(argv[5]) > 0))
   {
      vm.bitDepth = dAtoi(argv[5]);
   }
   if ((argc > 6) && (dStrlen(argv[6]) > 0))
   {
      vm.refreshRate = dAtoi(argv[6]);
   }
   if ((argc > 7) && (dStrlen(argv[7]) > 0))
   {
      vm.antialiasLevel = dAtoi(argv[7]);
   }
   object->getPlatformWindow()->setVideoMode(vm);
   // Store the new mode into a pref.
   Con::setVariable( "$pref::Video::mode", vm.toString() );
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_excludeOtherInstance(char * x__appIdentifer)
{
const char* appIdentifer = (const char*)x__appIdentifer;
bool wle_returnObject;
{
	   // mac/360 can only run one instance in general.
#if !defined(TORQUE_OS_MAC) && !defined(TORQUE_OS_XENON) && !defined(TORQUE_DEBUG)
   {wle_returnObject =Platform::excludeOtherInstances(appIdentifer);
return (S32)(wle_returnObject);}
#else
   // We can just return true if we get here.
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
#endif
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiCanvas_getContent(char * x__object)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
	GuiControl *ctrl = object->getContentControl();
   if(ctrl)
     return (S32)( ctrl->getId());
  return (S32)( -1);
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_setContent(char * x__object, char * x__ctrl)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
GuiControl* ctrl; Sim::findObject(x__ctrl, ctrl ); 
{
	// Not using old error reporting until we modify the engineAPI - mperry
	//GuiControl *gui = NULL;
 //  if(argv[2][0])
 //  {
 //     if (!Sim::findObject(argv[2], gui))
 //     {
 //        Con::printf("%s(): Invalid control: %s", argv[0], argv[2]);
 //        return;
 //     }
 //  }
	if(!ctrl)
	{
		Con::errorf("GuiCanvas::setContent - Invalid control specified')");
		return;
	}
   //set the new content control
   object->setContentControl(ctrl);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_cursorOn(char * x__object)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->setCursorON(true);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_cursorOff(char * x__object)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->setCursorON(false);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_setCursor(char * x__object, char * x__cursor)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
GuiCursor* cursor; Sim::findObject(x__cursor, cursor ); 
{
	if(!cursor)
	{
		Con::errorf("GuiCanvas::setCursor - Invalid GuiCursor name or ID");
		return;
	}
	object->setCursor(cursor);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_renderFront(char * x__object, bool enable)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->setRenderFront(enable);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_showCursor(char * x__object)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->showCursor(true);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_hideCursor(char * x__object)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->showCursor(false);
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiCanvas_isCursorOn(char * x__object)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
	{wle_returnObject =object->isCursorON();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiCanvas_isCursorShown(char * x__object)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
	{wle_returnObject =object->isCursorShown();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_repaint(char * x__object, S32 elapsedMS)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->repaint(elapsedMS < 0 ? 0 : elapsedMS);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_reset(char * x__object)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->resetUpdateRegions();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_getCursorPos(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point2I wle_returnObject;
{
	{wle_returnObject =object->getCursorPos();
dSprintf(retval,1024,"%i %i ",wle_returnObject.x,wle_returnObject.y);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiCanvas_getMouseControl(char * x__object)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
	GuiControl* control = object->getMouseControl();
   if (control)
     return (S32)( control->getId());
   
  return (S32)( NULL);
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_getExtent(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point2I wle_returnObject;
{
	{wle_returnObject =object->getExtent();
dSprintf(retval,1024,"%i %i ",wle_returnObject.x,wle_returnObject.y);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_setWindowTitle(char * x__object, char * x__newTitle)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* newTitle = (const char*)x__newTitle;
{
	object->setWindowTitle(newTitle);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_getVideoMode(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
	// Grab the video mode.
   if (!object->getPlatformWindow())
      {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   GFXVideoMode vm = object->getPlatformWindow()->getVideoMode();
   char* buf = Con::getReturnBuffer(vm.toString());
   {wle_returnObject =buf;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiCanvas_getModeCount(char * x__object)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
	if (!object->getPlatformWindow())
     return (S32)( 0);
   // Grab the available mode list from the device.
   const Vector<GFXVideoMode>* const modeList = 
      object->getPlatformWindow()->getGFXDevice()->getVideoModeList();
   // Return the number of resolutions.
  return (S32)( modeList->size());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_getMode(char * x__object, S32 modeId,  char* retval)
{
dSprintf(retval,4096,"");
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
	if (!object->getPlatformWindow())
      {wle_returnObject =0;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   // Grab the available mode list from the device.
   const Vector<GFXVideoMode>* const modeList = 
      object->getPlatformWindow()->getGFXDevice()->getVideoModeList();
   // Get the desired index and confirm it's valid.
   S32 idx = modeId;
   if((idx < 0) || (idx >= modeList->size()))
   {
      Con::errorf("GuiCanvas::getResolution - You requested an out of range index of %d. Please specify an index in the range [0, %d).", idx, modeList->size());
      {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   }
   // Great - we got something valid, so convert the videomode into a 
   // string and return to the user.
   GFXVideoMode vm = (*modeList)[idx];
   char *retString = Con::getReturnBuffer(vm.toString());
   {wle_returnObject =retString;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_toggleFullscreen(char * x__object)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	if (Platform::getWebDeployment())
      return;
   if (!object->getPlatformWindow())
      return;
   if (Journal::IsRecording() || Journal::IsPlaying())   
      return;
   // Get the window's video mode.
   GFXVideoMode origMode = object->getPlatformWindow()->getVideoMode();
   
   // And grab the device its using.
   GFXDevice *device = object->getPlatformWindow()->getGFXDevice();
   // Toggle the fullscreen bit.
   GFXVideoMode newMode = origMode;
   newMode.fullScreen = !origMode.fullScreen;
   
   // CodeReview Toggling might be better served by reading the fullscreen
   //            or windowed video mode pref and setting that instead [bjg 5/2/07]
   if(newMode.fullScreen == true)
   {
      // Are we going to fullscreen? If so find the first matching resolution that
      // is equal to or bigger in size, and has same BPP - windows
      // are often strangely sized and will need to be adjusted to a viable
      // fullscreen res.
      for(S32 i=0; i<device->getVideoModeList()->size(); i++)
      {
         const GFXVideoMode &newVm = (*(device->getVideoModeList()))[i];
         if(newMode.resolution.x > newVm.resolution.x)
            continue;
         if(newMode.resolution.y > newVm.resolution.y)
            continue;
         if(newMode.bitDepth != newVm.bitDepth)
            continue;
         // Great - got a match.
         newMode = newVm;
         newMode.fullScreen = true;
         break;
      }
   }
   // Ok, we have new video mode. Set it!
   object->getPlatformWindow()->setVideoMode(newMode);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_clientToScreen(char * x__object, char * x__coordinate,  char* retval)
{
dSprintf(retval,1024,"");
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point2I coordinate = Point2I();
sscanf(x__coordinate,"%i %i",&coordinate.x,&coordinate.y);
Point2I wle_returnObject;
{
   if( !object->getPlatformWindow() )
      {wle_returnObject =coordinate;
dSprintf(retval,1024,"%i %i ",wle_returnObject.x,wle_returnObject.y);
return;
}
      
   {wle_returnObject =object->getPlatformWindow()->clientToScreen( coordinate );
dSprintf(retval,1024,"%i %i ",wle_returnObject.x,wle_returnObject.y);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_screenToClient(char * x__object, char * x__coordinate,  char* retval)
{
dSprintf(retval,1024,"");
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point2I coordinate = Point2I();
sscanf(x__coordinate,"%i %i",&coordinate.x,&coordinate.y);
Point2I wle_returnObject;
{
   if( !object->getPlatformWindow() )
      {wle_returnObject =coordinate;
dSprintf(retval,1024,"%i %i ",wle_returnObject.x,wle_returnObject.y);
return;
}
      
   {wle_returnObject =object->getPlatformWindow()->screenToClient( coordinate );
dSprintf(retval,1024,"%i %i ",wle_returnObject.x,wle_returnObject.y);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_getWindowPosition(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point2I wle_returnObject;
{
   if( !object->getPlatformWindow() )
      {wle_returnObject =Point2I( 0, 0 );
dSprintf(retval,1024,"%i %i ",wle_returnObject.x,wle_returnObject.y);
return;
}
      
   {wle_returnObject =object->getPlatformWindow()->getPosition();
dSprintf(retval,1024,"%i %i ",wle_returnObject.x,wle_returnObject.y);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiCanvas_setWindowPosition(char * x__object, char * x__position)
{
GuiCanvas* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point2I position = Point2I();
sscanf(x__position,"%i %i",&position.x,&position.y);
{
   if( !object->getPlatformWindow() )
      return;
      
   object->getPlatformWindow()->setPosition( position );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_getValue(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
{
   {wle_returnObject =object->getScriptValue();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_makeFirstResponder(char * x__object, char * x__a2)
{
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->makeFirstResponder(dAtob(argv[2]));
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiControl_isActive(char * x__object)
{
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
{
   {wle_returnObject =object->isActive();
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_setExtent(char * x__object, char * x__a2, char * x__a3)
{
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   if ( argc == 3 )
   {
      // We scan for floats because its possible that math 
      // done on the extent can result in fractional values.
      Point2F ext;
      if ( dSscanf( argv[2], "%g %g", &ext.x, &ext.y ) == 2 )
         object->setExtent( (S32)ext.x, (S32)ext.y );
      else
         Con::errorf( "GuiControl::setExtent, not enough parameters!" );
   }
   else if ( argc == 4 )
      object->setExtent( dAtoi(argv[2]), dAtoi(argv[3]) );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_findHitControl(char * x__object, S32 x, S32 y,  char* retval)
{
dSprintf(retval,1024,"");
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

GuiControl* wle_returnObject;
{
   {wle_returnObject =object->findHitControl( Point2I( x, y ) );
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_findHitControls(char * x__object, S32 x, S32 y, S32 width, S32 height,  char* retval)
{
dSprintf(retval,4096,"");
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;


const char* wle_returnObject;
{
   // Find hit controls.
   
   RectI bounds( x, y, width, height );
   Vector< GuiControl* > controls;
   
   if( !object->findHitControls( bounds, controls ) )
      {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
      
   // Create vector string.
   bool isFirst = true;
   StringBuilder str;
   for( U32 i = 0, num = controls.size(); i < num; ++ i )
   {
      if( !isFirst )
         str.append( ' ' );
         
      str.append( controls[ i ]->getIdString() );
      isFirst = false;
   }
   String s = str.end();
   
   // Return result.
   if ( s.compare( object->getIdString() ) == 0 )
      {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   
   char* buffer = Con::getReturnBuffer( s.size() );
   dStrcpy( buffer, s.c_str() );
   
   {wle_returnObject =buffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiControl_controlIsChild(char * x__object, char * x__control)
{
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
GuiControl* control; Sim::findObject(x__control, control ); 
bool wle_returnObject;
{
   if( !control )
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
      
   {wle_returnObject =object->controlIsChild( control );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiControl_isFirstResponder(char * x__object)
{
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isFirstResponder();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_setFirstResponder(char * x__object)
{
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setFirstResponder();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_getFirstResponder(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
GuiControl* wle_returnObject;
{
   {wle_returnObject =object->getFirstResponder();
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_clearFirstResponder(char * x__object, bool ignored)
{
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->clearFirstResponder();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiControl_pointInControl(char * x__object, S32 x, S32 y)
{
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

bool wle_returnObject;
{
   {wle_returnObject =object->pointInControl( Point2I( x, y ) );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_addGuiControl(char * x__object, char * x__control)
{
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
GuiControl* control; Sim::findObject(x__control, control ); 
{
   if( control )
      object->addObject( control );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_getRoot(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
GuiCanvas* wle_returnObject;
{
   {wle_returnObject =object->getRoot();
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_getParent(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
GuiControl* wle_returnObject;
{
   {wle_returnObject =object->getParent();
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiControl_isMouseLocked(char * x__object)
{
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isMouseLocked();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_setValue(char * x__object, char * x__value)
{
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* value = (const char*)x__value;
{
   object->setScriptValue( value );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_setActive(char * x__object, bool state)
{
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setActive( state );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiControl_isVisible(char * x__object)
{
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isVisible();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_setVisible(char * x__object, bool state)
{
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setVisible( state );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiControl_isAwake(char * x__object)
{
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isAwake();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_setProfile(char * x__object, char * x__profile)
{
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
GuiControlProfile* profile; Sim::findObject(x__profile, profile ); 
{
   if( !profile )
      return;
      
   object->setControlProfile( profile );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_resize(char * x__object, S32 x, S32 y, S32 width, S32 height)
{
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;


{
   Point2I newPos( x, y );
   Point2I newExt( width, height );
   object->resize(newPos, newExt);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_getPosition(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point2I wle_returnObject;
{
   {wle_returnObject =object->getPosition();
dSprintf(retval,1024,"%i %i ",wle_returnObject.x,wle_returnObject.y);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_getCenter(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point2I wle_returnObject;
{
   const Point2I pos = object->getPosition();
   const Point2I ext = object->getExtent();
   Point2I center( pos.x + ext.x / 2, pos.y + ext.y / 2 );
   
   {wle_returnObject =center;
dSprintf(retval,1024,"%i %i ",wle_returnObject.x,wle_returnObject.y);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_setCenter(char * x__object, S32 x, S32 y)
{
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   const Point2I ext = object->getExtent();
   Point2I newpos( x - ext.x / 2, y - ext.y / 2 );
   object->setPosition( newpos );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_getGlobalCenter(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point2I wle_returnObject;
{
   const Point2I tl( 0, 0 );
   Point2I pos = object->localToGlobalCoord( tl );
   const Point2I ext = object->getExtent();
   Point2I center( pos.x + ext.x / 2, pos.y + ext.y / 2 );
   
   {wle_returnObject =center;
dSprintf(retval,1024,"%i %i ",wle_returnObject.x,wle_returnObject.y);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_getGlobalPosition(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point2I wle_returnObject;
{
   const Point2I pos(0,0);
   {wle_returnObject =object->localToGlobalCoord(pos);
dSprintf(retval,1024,"%i %i ",wle_returnObject.x,wle_returnObject.y);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_setPositionGlobal(char * x__object, S32 x, S32 y)
{
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   //see if we can turn the x/y into ints directly, 
   Point2I lPosOffset	=	object->globalToLocalCoord( Point2I( x, y ) );
   
   lPosOffset += object->getPosition();
   
   object->setPosition( lPosOffset );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_setPosition(char * x__object, S32 x, S32 y)
{
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->setPosition( Point2I( x, y ) );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_getExtent(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point2I wle_returnObject;
{
   {wle_returnObject =object->getExtent();
dSprintf(retval,1024,"%i %i ",wle_returnObject.x,wle_returnObject.y);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiControl_getMinExtent(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point2I wle_returnObject;
{
   {wle_returnObject =object->getMinExtent();
dSprintf(retval,1024,"%i %i ",wle_returnObject.x,wle_returnObject.y);
return;
}
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnGuiControl_getAspect(char * x__object)
{
GuiControl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   const Point2I &ext = object->getExtent();
  return (F32)( (F32)ext.x / (F32)ext.y);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiControlProfile_getStringWidth(char * x__object, char * x__a2)
{
GuiControlProfile* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   return (S32)( object->mFont->getStrNWidth( argv[2], dStrlen( argv[2] ) ));
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnDbgFileView_setCurrentLine(char * x__object, char * x__a2, char * x__a3)
{
DbgFileView* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   object->setCurrentLine(dAtoi(argv[2]), dAtob(argv[3]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnDbgFileView_getCurrentLine(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
DbgFileView* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char * wle_returnObject;
{
{
	S32 lineNum;
   const char *file = object->getCurrentLine(lineNum);
   char* ret = Con::getReturnBuffer(256);
	dSprintf(ret, sizeof(ret), "%s\t%d", file, lineNum);
	{wle_returnObject =ret;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnDbgFileView_open(char * x__object, char * x__a2)
{
DbgFileView* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
bool wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   {wle_returnObject =object->openFile(argv[2]);
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnDbgFileView_clearBreakPositions(char * x__object)
{
DbgFileView* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->clearBreakPositions();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnDbgFileView_setBreakPosition(char * x__object, char * x__a2)
{
DbgFileView* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->setBreakPosition(dAtoi(argv[2]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnDbgFileView_setBreak(char * x__object, char * x__a2)
{
DbgFileView* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->setBreakPointStatus(dAtoi(argv[2]), true);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnDbgFileView_removeBreak(char * x__object, char * x__a2)
{
DbgFileView* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->setBreakPointStatus(dAtoi(argv[2]), false);
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnDbgFileView_findString(char * x__object, char * x__a2)
{
DbgFileView* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
bool wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   {wle_returnObject =object->findString(argv[2]);
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiEditCtrl_getContentControl(char * x__object)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
   GuiControl* ctrl = object->getContentControl();
   if( ctrl )
     return (S32)( ctrl->getId());
   else
     return (S32)( 0);
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_setContentControl(char * x__object, char * x__a2)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   GuiControl *ctrl;
   if(!Sim::findObject(argv[2], ctrl))
      return;
   object->setContentControl(ctrl);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_addNewCtrl(char * x__object, char * x__a2)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   GuiControl *ctrl;
   if(!Sim::findObject(argv[2], ctrl))
      return;
   object->addNewControl(ctrl);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_addSelection(char * x__object, char * x__a2)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   S32 id = dAtoi(argv[2]);
   object->addSelection(id);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_removeSelection(char * x__object, char * x__a2)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   S32 id = dAtoi(argv[2]);
   object->removeSelection(id);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_clearSelection(char * x__object)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->clearSelection();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_select(char * x__object, char * x__a2)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   GuiControl *ctrl;
   if(!Sim::findObject(argv[2], ctrl))
      return;
   object->setSelection(ctrl, false);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_setCurrentAddSet(char * x__object, char * x__a2)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   GuiControl *addSet;
   if (!Sim::findObject(argv[2], addSet))
   {
      Con::printf("%s(): Invalid control: %s", argv[0], argv[2]);
      return;
   }
   object->setCurrentAddSet(addSet);
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiEditCtrl_getCurrentAddSet(char * x__object)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
   const GuiControl* add = object->getCurrentAddSet();
  return (S32)( add ? add->getId() : 0);
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_toggle(char * x__object)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->setEditMode( !object->isActive() );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_justify(char * x__object, char * x__a2)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->justifySelection((GuiEditCtrl::Justification)dAtoi(argv[2]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_bringToFront(char * x__object)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->bringToFront();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_pushToBack(char * x__object)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->pushToBack();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_deleteSelection(char * x__object)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->deleteSelection();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_moveSelection(char * x__object, char * x__a2, char * x__a3)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   object->moveAndSnapSelection(Point2I(dAtoi(argv[2]), dAtoi(argv[3])));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_saveSelection(char * x__object, char * x__a2)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   const char* filename = NULL;
   if( argc > 2 )
      filename = argv[ 2 ];
      
   object->saveSelection( filename );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_loadSelection(char * x__object, char * x__a2)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   const char* filename = NULL;
   if( argc > 2 )
      filename = argv[ 2 ];
   object->loadSelection( filename );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_selectAll(char * x__object)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->selectAll();
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiEditCtrl_getNumSelected(char * x__object)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
  return (S32)( object->getNumSelected());
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_getSelectionGlobalBounds(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
{
   RectI bounds = object->getSelectionGlobalBounds();
   String str = String::ToString( "%i %i %i %i", bounds.point.x, bounds.point.y, bounds.extent.x, bounds.extent.y );
   
   char* buffer = Con::getReturnBuffer( str.length() );
   dStrcpy( buffer, str.c_str() );
   
   {wle_returnObject =buffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_selectParents(char * x__object, char * x__a2)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   bool addToSelection = false;
   if( argc > 2 )
      addToSelection = dAtob( argv[ 2 ] );
      
   object->selectParents( addToSelection );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_selectChildren(char * x__object, char * x__a2)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   bool addToSelection = false;
   if( argc > 2 )
      addToSelection = dAtob( argv[ 2 ] );
      
   object->selectChildren( addToSelection );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_setSnapToGrid(char * x__object, char * x__a2)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   U32 gridsize = dAtoi(argv[2]);
   object->setSnapToGrid(gridsize);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_readGuides(char * x__object, char * x__a2, char * x__a3)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   // Find the control.
   
   GuiControl* ctrl;
   if( !Sim::findObject( argv[ 2 ], ctrl ) )
   {
      Con::errorf( "GuiEditCtrl::readGuides - no control '%s'", argv[ 2 ] );
      return;
   }
   
   // Read the guides.
   
   if( argc > 3 )
   {
      S32 axis = dAtoi( argv[ 3 ] );
      if( axis < 0 || axis > 1 )
      {
         Con::errorf( "GuiEditCtrl::readGuides - invalid axis '%s'", argv[ 3 ] );
         return;
      }
      
      object->readGuides( ( GuiEditCtrl::guideAxis ) axis, ctrl );
   }
   else
   {
      object->readGuides( GuiEditCtrl::GuideHorizontal, ctrl );
      object->readGuides( GuiEditCtrl::GuideVertical, ctrl );
   }
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_writeGuides(char * x__object, char * x__a2, char * x__a3)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   // Find the control.
   
   GuiControl* ctrl;
   if( !Sim::findObject( argv[ 2 ], ctrl ) )
   {
      Con::errorf( "GuiEditCtrl::writeGuides - no control '%i'", argv[ 2 ] );
      return;
   }
   
   // Write the guides.
   
   if( argc > 3 )
   {
      S32 axis = dAtoi( argv[ 3 ] );
      if( axis < 0 || axis > 1 )
      {
         Con::errorf( "GuiEditCtrl::writeGuides - invalid axis '%s'", argv[ 3 ] );
         return;
      }
      
      object->writeGuides( ( GuiEditCtrl::guideAxis ) axis, ctrl );
   }
   else
   {
      object->writeGuides( GuiEditCtrl::GuideHorizontal, ctrl );
      object->writeGuides( GuiEditCtrl::GuideVertical, ctrl );
   }
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_clearGuides(char * x__object, char * x__a2)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   if( argc > 2 )
   {
      S32 axis = dAtoi( argv[ 2 ] );
      if( axis < 0 || axis > 1 )
      {
         Con::errorf( "GuiEditCtrl::clearGuides - invalid axis '%i'", axis );
         return;
      }
      
      object->clearGuides( ( GuiEditCtrl::guideAxis ) axis );
   }
   else
   {
      object->clearGuides( GuiEditCtrl::GuideHorizontal );
      object->clearGuides( GuiEditCtrl::GuideVertical );
   }
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_fitIntoParents(char * x__object, char * x__a2, char * x__a3)
{
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   bool width = true;
   bool height = true;
   
   if( argc > 2 )
      width = dAtob( argv[ 2 ] );
   if( argc > 3 )
      height = dAtob( argv[ 3 ] );
      
   object->fitIntoParents( width, height );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_getMouseMode(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
{
   switch( object->getMouseMode() )
   {
      case GuiEditCtrl::Selecting:
         {wle_returnObject ="Selecting";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
      
      case GuiEditCtrl::DragSelecting:
         {wle_returnObject ="DragSelecting";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
      case GuiEditCtrl::MovingSelection:
         {wle_returnObject ="MovingSelection";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
      
      case GuiEditCtrl::SizingSelection:
         {wle_returnObject ="SizingSelection";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
            
      case GuiEditCtrl::DragGuide:
         {wle_returnObject ="DragGuide";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
         
      case GuiEditCtrl::DragClone:
         {wle_returnObject ="DragClone";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
         
      default:
         {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   }
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_getSelection(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
SimSet* wle_returnObject;
{
   {wle_returnObject =object->getSelectedSet();
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiEditCtrl_getTrash(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
GuiEditCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
SimGroup* wle_returnObject;
{
   {wle_returnObject =object->getTrash();
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiFilterCtrl_getValue(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiFilterCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
{
   
   static char buffer[512];
   const Filter *filter = object->get();
   *buffer = 0;
   for (U32 i=0; i < filter->size(); i++)
   {
      char value[32];
      dSprintf(value, 31, "%1.5f ", *(filter->begin()+i) );
      dStrcat(buffer, value);
   }
   {wle_returnObject =buffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiFilterCtrl_setValue(char * x__object, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10, char * x__a11, char * x__a12, char * x__a13, char * x__a14, char * x__a15, char * x__a16, char * x__a17, char * x__a18, char * x__a19)
{
GuiFilterCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* a11 = (const char*)x__a11;
const char* a12 = (const char*)x__a12;
const char* a13 = (const char*)x__a13;
const char* a14 = (const char*)x__a14;
const char* a15 = (const char*)x__a15;
const char* a16 = (const char*)x__a16;
const char* a17 = (const char*)x__a17;
const char* a18 = (const char*)x__a18;
const char* a19 = (const char*)x__a19;
{
S32 argc = 20;
if (dStrlen(a19)==0)
if (dStrlen(a18)==0)
if (dStrlen(a17)==0)
if (dStrlen(a16)==0)
if (dStrlen(a15)==0)
if (dStrlen(a14)==0)
if (dStrlen(a13)==0)
if (dStrlen(a12)==0)
if (dStrlen(a11)==0)
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
else
argc=12;
else
argc=13;
else
argc=14;
else
argc=15;
else
argc=16;
else
argc=17;
else
argc=18;
else
argc=19;
else
argc=20;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
if (argc>5)
arguments.push_back(a5);
if (argc>6)
arguments.push_back(a6);
if (argc>7)
arguments.push_back(a7);
if (argc>8)
arguments.push_back(a8);
if (argc>9)
arguments.push_back(a9);
if (argc>10)
arguments.push_back(a10);
if (argc>11)
arguments.push_back(a11);
if (argc>12)
arguments.push_back(a12);
if (argc>13)
arguments.push_back(a13);
if (argc>14)
arguments.push_back(a14);
if (argc>15)
arguments.push_back(a15);
if (argc>16)
arguments.push_back(a16);
if (argc>17)
arguments.push_back(a17);
if (argc>18)
arguments.push_back(a18);
if (argc>19)
arguments.push_back(a19);
const char** argv = &arguments[0];
{
   Filter filter;
   argc -= 2;
   argv += 2;
   filter.set(argc, argv);
	object->set(filter);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiFilterCtrl_identity(char * x__object)
{
GuiFilterCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->identity();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiGraphCtrl_addDatum(char * x__object, S32 plotId, F32 value)
{
GuiGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   if( plotId > object->MaxPlots )
   {
	   Con::errorf( "GuiGraphCtrl::addDatum - 'plotId' out of range: %i", plotId );
	   return;
   }
   
   object->addDatum( plotId, value );
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnGuiGraphCtrl_getDatum(char * x__object, S32 plotId, S32 index)
{
GuiGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

{
   if( plotId > object->MaxPlots )
   {
	   Con::errorf( "GuiGraphCtrl::getDatum - 'plotId' out of range: %i", plotId );
	  return (F32)( -1.f);
   }
   
   if( index > object->MaxDataPoints)
   {
	   Con::errorf( "GuiGraphCtrl::getDatum - Data point index out of range: %i", index );
	  return (F32)( -1.f);
   }
  return (F32)( object->getDatum( plotId, index ));
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiGraphCtrl_addAutoPlot(char * x__object, S32 plotId, char * x__variable, S32 updateFrequency)
{
GuiGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

const char* variable = (const char*)x__variable;

{
   if( plotId > object->MaxPlots )
   {
	   Con::errorf( "GuiGraphCtrl::removeAutoPlot - 'plotId' out of range: %i", plotId );
	   return;
   }
   object->addAutoPlot( plotId, variable, updateFrequency );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiGraphCtrl_removeAutoPlot(char * x__object, S32 plotId)
{
GuiGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   if( plotId > object->MaxPlots )
   {
	   Con::errorf( "GuiGraphCtrl::removeAutoPlot - 'plotId' out of range: %i", plotId );
	   return;
   }
   object->removeAutoPlot( plotId );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiGraphCtrl_setGraphType(char * x__object, S32 plotId, S32 x__graphType)
{
GuiGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

GuiGraphType graphType = (GuiGraphType)x__graphType;
{
	if( plotId > object->MaxPlots )
	{
	   Con::errorf( "GuiGraphCtrl::setGraphType - 'plotId' out of range: %i", plotId );
		return;
	}
	object->setGraphType( plotId, graphType );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiImageList_getImage(char * x__object, int index,  char* retval)
{
dSprintf(retval,4096,"");
GuiImageList* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
  {wle_returnObject =object->GetTexturePath(index);
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiImageList_clear(char * x__object)
{
GuiImageList* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
  {wle_returnObject =object->Clear();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiImageList_count(char * x__object)
{
GuiImageList* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
 return (S32)( object->Count());
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiImageList_remove(char * x__object, int index)
{
GuiImageList* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
  {wle_returnObject =object->FreeTextureEntry( index );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiImageList_getIndex(char * x__object, char * x__imagePath)
{
GuiImageList* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* imagePath = (const char*)x__imagePath;
{
 return (S32)( object->IndexFromPath( imagePath ));
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiImageList_insert(char * x__object, char * x__imagePath)
{
GuiImageList* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* imagePath = (const char*)x__imagePath;
{
 return (S32)( object->Insert( imagePath ));
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiInspector_inspect(char * x__object, char * x__a2)
{
GuiInspector* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   SimObject * target = Sim::findObject(argv[2]);
   if(!target)
   {
      if(dAtoi(argv[2]) > 0)
         Con::warnf("%s::inspect(): invalid object: %s", argv[0], argv[2]);
      object->clearInspectObjects();
      return;
   }
   object->inspectObject(target);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiInspector_addInspect(char * x__object, char * x__a2, char * x__a3)
{
GuiInspector* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   SimObject* obj;
   if( !Sim::findObject( argv[ 2 ], obj ) )
   {
      Con::errorf( "%s::addInspect(): invalid object: %s", argv[ 0 ], argv[ 2 ] );
      return;
   }
   if( argc > 3 )
		object->addInspectObject( obj, false );
	else
		object->addInspectObject( obj );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiInspector_removeInspect(char * x__object, char * x__a2)
{
GuiInspector* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   SimObject* obj;
   if( !Sim::findObject( argv[ 2 ], obj ) )
   {
      Con::errorf( "%s::removeInspect(): invalid object: %s", argv[ 0 ], argv[ 2 ] );
      return;
   }
   
   object->removeInspectObject( obj );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiInspector_refresh(char * x__object)
{
GuiInspector* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   if ( object->getNumInspectObjects() == 0 )
      return;
   SimObject *target = object->getInspectObject();
   if ( target )
      object->inspectObject( target );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiInspector_getInspectObject(char * x__object, char * x__a2,  char* retval)
{
dSprintf(retval,4096,"");
GuiInspector* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   U32 index = 0;
   if( argc > 2 )
      index = dAtoi( argv[ 2 ] );
      
   if( index >= object->getNumInspectObjects() )
   {
      Con::errorf( "GuiInspector::getInspectObject() - index out of range: %i", index );
      {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   }
   
   {wle_returnObject =object->getInspectObject( index )->getIdString();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiInspector_getNumInspectObjects(char * x__object)
{
GuiInspector* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
  return (S32)( object->getNumInspectObjects());
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiInspector_setName(char * x__object, char * x__a2)
{
GuiInspector* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->setName(argv[2]);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiInspector_apply(char * x__object)
{
GuiInspector* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->sendInspectPostApply();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiInspector_setObjectField(char * x__object, char * x__a2, char * x__a3)
{
GuiInspector* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   object->setObjectField( argv[2], argv[3] );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiInspectorTypeFileName_apply(char * x__object, char * x__a2)
{
GuiInspectorTypeFileName* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   String path( argv[2] );
   if ( path.isNotEmpty() )
      path = Platform::makeRelativePathName( path, Platform::getMainDotCsDir() );
      
   object->setData( path.c_str() );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiInspectorTypeBitMask32_applyBit(char * x__object)
{
GuiInspectorTypeBitMask32* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->updateData();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMenuBar_clearMenus(char * x__object, S32 param1, S32 param2)
{
GuiMenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->clearMenus();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMenuBar_setMenuMargins(char * x__object, S32 horizontalMargin, S32 verticalMargin, S32 bitmapToTextSpacing)
{
GuiMenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->mHorizontalMargin = horizontalMargin;
   object->mVerticalMargin = verticalMargin;
   object->mBitmapMargin = bitmapToTextSpacing;
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMenuBar_addMenu(char * x__object, char * x__menuText, int menuId)
{
GuiMenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* menuText = (const char*)x__menuText;

{
   if(dIsdigit(menuText[0]))
   {
      Con::errorf("Cannot add menu %s (id = %s).  First character of a menu's text cannot be a digit.", menuText, menuId);
      return;
   }
   object->addMenu(menuText, menuId);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMenuBar_addMenuItem(char * x__object, char * x__targetMenu, char * x__menuItemText, int menuItemId, char * x__accelerator, int checkGroup)
{
GuiMenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* targetMenu = (const char*)x__targetMenu;
const char* menuItemText = (const char*)x__menuItemText;

const char* accelerator = (const char*)x__accelerator;

{
   if(dIsdigit(menuItemText[0]))
   {
      Con::errorf("Cannot add menu item %s (id = %s).  First character of a menu item's text cannot be a digit.", menuItemText, menuItemId);
      return;
   }
   GuiMenuBar::Menu *menu = object->findMenu(targetMenu);
   if(!menu)
   {
      Con::errorf("Cannot find menu %s for addMenuItem.", targetMenu);
      return;
   }
   object->addMenuItem(menu, menuItemText, menuItemId, accelerator != NULL ? accelerator : "", checkGroup == -1 ? -1 : checkGroup);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMenuBar_setMenuItemEnable(char * x__object, char * x__menuTarget, char * x__menuItemTarget, bool enabled)
{
GuiMenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* menuTarget = (const char*)x__menuTarget;
const char* menuItemTarget = (const char*)x__menuItemTarget;

{
   GuiMenuBar::Menu *menu = object->findMenu(menuTarget);
   if(!menu)
   {
      Con::errorf("Cannot find menu %s for setMenuItemEnable.", menuTarget);
      return;
   }
   GuiMenuBar::MenuItem *menuItem = object->findMenuItem(menu, menuItemTarget);
   if(!menuItem)
   {
      Con::errorf("Cannot find menu item %s for setMenuItemEnable.", menuItemTarget);
      return;
   }
   menuItem->enabled = enabled;
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMenuBar_setCheckmarkBitmapIndex(char * x__object, S32 bitmapindex)
{
GuiMenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->mCheckmarkBitmapIndex = bitmapindex;
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMenuBar_setMenuItemChecked(char * x__object, char * x__menuTarget, char * x__menuItemTarget, bool checked)
{
GuiMenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* menuTarget = (const char*)x__menuTarget;
const char* menuItemTarget = (const char*)x__menuItemTarget;

{
   GuiMenuBar::Menu *menu = object->findMenu(menuTarget);
   if(!menu)
   {
      Con::errorf("Cannot find menu %s for setMenuItemChecked.", menuTarget);
      return;
   }
   GuiMenuBar::MenuItem *menuItem = object->findMenuItem(menu, menuItemTarget);
   if(!menuItem)
   {
      Con::errorf("Cannot find menu item %s for setMenuItemChecked.", menuItemTarget);
      return;
   }
   if(checked && menuItem->checkGroup != -1)
   {
      // first, uncheck everything in the group:
      for(GuiMenuBar::MenuItem *itemWalk = menu->firstMenuItem; itemWalk; itemWalk = itemWalk->nextMenuItem)
         if(itemWalk->checkGroup == menuItem->checkGroup && itemWalk->bitmapIndex == object->mCheckmarkBitmapIndex)
            itemWalk->bitmapIndex = -1;
   }
   menuItem->bitmapIndex = checked ? object->mCheckmarkBitmapIndex : -1;
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMenuBar_setMenuText(char * x__object, char * x__menuTarget, char * x__newMenuText)
{
GuiMenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* menuTarget = (const char*)x__menuTarget;
const char* newMenuText = (const char*)x__newMenuText;
{
   if(dIsdigit(menuTarget[0]))
   {
      Con::errorf("Cannot name menu %s to %s.  First character of a menu's text cannot be a digit.", menuTarget, newMenuText);
      return;
   }
   GuiMenuBar::Menu *menu = object->findMenu(menuTarget);
   if(!menu)
   {
      Con::errorf("Cannot find menu %s for setMenuText.", menuTarget);
      return;
   }
   dFree(menu->text);
   menu->text = dStrdup(newMenuText);
   object->menuBarDirty = true;
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMenuBar_setMenuBitmapIndex(char * x__object, char * x__menuTarget, S32 bitmapindex, bool bitmaponly, bool drawborder)
{
GuiMenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* menuTarget = (const char*)x__menuTarget;


{
   GuiMenuBar::Menu *menu = object->findMenu(menuTarget);
   if(!menu)
   {
      Con::errorf("Cannot find menu %s for setMenuBitmapIndex.", menuTarget);
      return;
   }
   menu->bitmapIndex = bitmapindex;
   menu->drawBitmapOnly = bitmaponly;
   menu->drawBorder = drawborder;
   object->menuBarDirty = true;
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMenuBar_setMenuVisible(char * x__object, char * x__menuTarget, bool visible)
{
GuiMenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* menuTarget = (const char*)x__menuTarget;

{
   GuiMenuBar::Menu *menu = object->findMenu(menuTarget);
   if(!menu)
   {
      Con::errorf("Cannot find menu %s for setMenuVisible.", menuTarget);
      return;
   }
   menu->visible = visible;
   object->menuBarDirty = true;
   object->setUpdate();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMenuBar_setMenuItemText(char * x__object, char * x__menuTarget, char * x__menuItemTarget, char * x__newMenuItemText)
{
GuiMenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* menuTarget = (const char*)x__menuTarget;
const char* menuItemTarget = (const char*)x__menuItemTarget;
const char* newMenuItemText = (const char*)x__newMenuItemText;
{
   if(dIsdigit(newMenuItemText[0]))
   {
      Con::errorf("Cannot name menu item %s to %s.  First character of a menu item's text cannot be a digit.", menuItemTarget, newMenuItemText);
      return;
   }
   GuiMenuBar::Menu *menu = object->findMenu(menuTarget);
   if(!menu)
   {
      Con::errorf("Cannot find menu %s for setMenuItemText.", menuTarget);
      return;
   }
   GuiMenuBar::MenuItem *menuItem = object->findMenuItem(menu, menuItemTarget);
   if(!menuItem)
   {
      Con::errorf("Cannot find menu item %s for setMenuItemText.", menuItemTarget);
      return;
   }
   dFree(menuItem->text);
   menuItem->text = dStrdup(newMenuItemText);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMenuBar_setMenuItemVisible(char * x__object, char * x__menuTarget, char * x__menuItemTarget, bool isVisible)
{
GuiMenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* menuTarget = (const char*)x__menuTarget;
const char* menuItemTarget = (const char*)x__menuItemTarget;

{
   GuiMenuBar::Menu *menu = object->findMenu(menuTarget);
   if(!menu)
   {
      Con::errorf("Cannot find menu %s for setMenuItemVisible.", menuTarget);
      return;
   }
   GuiMenuBar::MenuItem *menuItem = object->findMenuItem(menu, menuItemTarget);
   if(!menuItem)
   {
      Con::errorf("Cannot find menu item %s for setMenuItemVisible.", menuItemTarget);
      return;
   }
   menuItem->visible = isVisible;
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMenuBar_setMenuItemBitmap(char * x__object, char * x__menuTarget, char * x__menuItemTarget, int bitmapIndex)
{
GuiMenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* menuTarget = (const char*)x__menuTarget;
const char* menuItemTarget = (const char*)x__menuItemTarget;

{
   GuiMenuBar::Menu *menu = object->findMenu(menuTarget);
   if(!menu)
   {
      Con::errorf("Cannot find menu %s for setMenuItemBitmap.", menuTarget);
      return;
   }
   GuiMenuBar::MenuItem *menuItem = object->findMenuItem(menu, menuItemTarget);
   if(!menuItem)
   {
      Con::errorf("Cannot find menu item %s for setMenuItemBitmap.", menuItemTarget);
      return;
   }
   menuItem->bitmapIndex = bitmapIndex;
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMenuBar_removeMenuItem(char * x__object, char * x__menuTarget, char * x__menuItemTarget)
{
GuiMenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* menuTarget = (const char*)x__menuTarget;
const char* menuItemTarget = (const char*)x__menuItemTarget;
{
   GuiMenuBar::Menu *menu = object->findMenu(menuTarget);
   if(!menu)
   {
      Con::errorf("Cannot find menu %s for removeMenuItem.", menuTarget);
      return;
   }
   GuiMenuBar::MenuItem *menuItem = object->findMenuItem(menu, menuItemTarget);
   if(!menuItem)
   {
      Con::errorf("Cannot find menu item %s for removeMenuItem.", menuItemTarget);
      return;
   }
   object->removeMenuItem(menu, menuItem);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMenuBar_clearMenuItems(char * x__object, char * x__menuTarget)
{
GuiMenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* menuTarget = (const char*)x__menuTarget;
{
   GuiMenuBar::Menu *menu = object->findMenu(menuTarget);
   if(!menu)
   {
      //Con::errorf("Cannot find menu %s for clearMenuItems.", menuTarget);
      return;
   }
   object->clearMenuItems(menu);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMenuBar_removeMenu(char * x__object, char * x__menuTarget)
{
GuiMenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* menuTarget = (const char*)x__menuTarget;
{
   GuiMenuBar::Menu *menu = object->findMenu(menuTarget);
   if(!menu)
   {
      //Con::errorf("Cannot find menu %s for removeMenu.", menuTarget);
      return;
   }
   object->clearMenuItems(menu);
   object->menuBarDirty = true;
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMenuBar_setMenuItemSubmenuState(char * x__object, char * x__menuTarget, char * x__menuItem, bool isSubmenu)
{
GuiMenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* menuTarget = (const char*)x__menuTarget;
const char* menuItem = (const char*)x__menuItem;

{
   GuiMenuBar::Menu *menu = object->findMenu(menuTarget);
   if(!menu)
   {
      Con::errorf("Cannot find menu %s for setMenuItemSubmenuState.", menuTarget);
      return;
   }
   GuiMenuBar::MenuItem *menuitem = object->findMenuItem(menu, menuItem);
   if(!menuitem)
   {
      Con::errorf("Cannot find menuitem %s for setMenuItemSubmenuState.", menuItem);
      return;
   }
   menuitem->isSubmenu = isSubmenu;
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMenuBar_addSubmenuItem(char * x__object, char * x__menuTarget, char * x__menuItem, char * x__submenuItemText, int submenuItemId, char * x__accelerator, int checkGroup)
{
GuiMenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* menuTarget = (const char*)x__menuTarget;
const char* menuItem = (const char*)x__menuItem;
const char* submenuItemText = (const char*)x__submenuItemText;

const char* accelerator = (const char*)x__accelerator;

{
   if(dIsdigit(submenuItemText[0]))
   {
      Con::errorf("Cannot add submenu item %s (id = %s).  First character of a menu item's text cannot be a digit.", submenuItemText, submenuItemId);
      return;
   }
   GuiMenuBar::Menu *menu = object->findMenu(menuTarget);
   if(!menu)
   {
      Con::errorf("Cannot find menu %s for addMenuItem.", menuTarget);
      return;
   }
   GuiMenuBar::MenuItem *menuitem = object->findMenuItem(menu, menuItem);
   if(!menuitem)
   {
      Con::errorf("Cannot find menuitem %s for addSubmenuItem.", menuItem);
      return;
   }
   object->addSubmenuItem(menu, menuitem, submenuItemText, submenuItemId, !accelerator ? "" : accelerator, checkGroup == -1 ? -1 : checkGroup);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMenuBar_clearSubmenuItems(char * x__object, char * x__menuTarget, char * x__menuItem)
{
GuiMenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* menuTarget = (const char*)x__menuTarget;
const char* menuItem = (const char*)x__menuItem;
{
   GuiMenuBar::Menu *menu = object->findMenu(menuTarget);
   if(!menu)
   {
      Con::errorf("Cannot find menu %s for clearSubmenuItems.", menuTarget);
      return;
   }
   GuiMenuBar::MenuItem *menuitem = object->findMenuItem(menu, menuItem);
   if(!menuitem)
   {
      Con::errorf("Cannot find menuitem %s for clearSubmenuItems.", menuItem);
      return;
   }
   object->clearSubmenuItems(menuitem);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMenuBar_setSubmenuItemChecked(char * x__object, char * x__menuTarget, char * x__menuItemTarget, char * x__submenuItemText, bool checked)
{
GuiMenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* menuTarget = (const char*)x__menuTarget;
const char* menuItemTarget = (const char*)x__menuItemTarget;
const char* submenuItemText = (const char*)x__submenuItemText;

{
   // Find the parent menu
   GuiMenuBar::Menu *menu = object->findMenu(menuTarget);
   if(!menu)
   {
      Con::errorf("Cannot find menu %s for setSubmenuItemChecked.", menuTarget);
      return;
   }
   // Find the parent menu item
   GuiMenuBar::MenuItem *menuItem = object->findMenuItem(menu, menuItemTarget);
   if(!menuItem)
   {
      Con::errorf("Cannot find menu item %s for setSubmenuItemChecked.", menuItemTarget);
      return;
   }
   // Find the submenu item
   GuiMenuBar::MenuItem *submenuItem = object->findSubmenuItem(menu, menuItemTarget, submenuItemText);
   if(!submenuItem)
   {
      Con::errorf("Cannot find submenu item %s for setSubmenuItemChecked.", submenuItemText);
      return;
   }
   if(checked && submenuItem->checkGroup != -1)
   {
      // first, uncheck everything in the group:
      for(GuiMenuBar::MenuItem *itemWalk = menuItem->firstSubmenuItem; itemWalk; itemWalk = itemWalk->nextMenuItem)
         if(itemWalk->checkGroup == submenuItem->checkGroup && itemWalk->bitmapIndex == object->mCheckmarkBitmapIndex)
            itemWalk->bitmapIndex = -1;
   }
   submenuItem->bitmapIndex = checked ? object->mCheckmarkBitmapIndex : -1;
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_setSelectedPoint(char * x__object, char * x__a2)
{
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   S32 point = dAtoi(argv[2]);
   if(point >= object->mPlots[object->mSelectedPlot].mGraphData.size() || point < 0)
   {
	   Con::errorf("Invalid point to select.");
	   return;
   }
   object->setSelectedPoint( point );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_setSelectedPlot(char * x__object, char * x__a2)
{
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   S32 plotID = dAtoi(argv[2]);
   if(plotID > object->MaxPlots)
   {
	   Con::errorf("Invalid plotID.");
	   return;
   }
   object->setSelectedPlot( plotID );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_clearGraph(char * x__object, char * x__a2)
{
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   S32 plotID = dAtoi(argv[2]);
   if(plotID > object->MaxPlots)
   {
	   Con::errorf("Invalid plotID.");
	   return;
   }
   object->clearGraph( plotID );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_clearAllGraphs(char * x__object)
{
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->clearAllGraphs();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_addPlotPoint(char * x__object, char * x__a2, char * x__a3, char * x__a4, char * x__a5,  char* retval)
{
dSprintf(retval,4096,"");
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* wle_returnObject;
{
S32 argc = 6;
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
if (argc>5)
arguments.push_back(a5);
const char** argv = &arguments[0];
{
   S32 plotID = dAtoi(argv[2]);
   S32 pointAdded = 0;
   char *retBuffer = Con::getReturnBuffer(32);
   if(plotID > object->MaxPlots)
   {
	   Con::errorf("Invalid plotID.");
	   dSprintf(retBuffer, 32, "%d", -2);
      {wle_returnObject =retBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   }
   if(argc == 5)
   {
      pointAdded = object->addPlotPoint( plotID, Point2F(dAtof(argv[3]), dAtof(argv[4])));
   } else if(argc == 6)
   {
      pointAdded = object->addPlotPoint( plotID, Point2F(dAtof(argv[3]), dAtof(argv[4])), dAtob(argv[5]));
   }
   
   dSprintf(retBuffer, 32, "%d", pointAdded);
   {wle_returnObject =retBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_insertPlotPoint(char * x__object, char * x__a2, char * x__a3, char * x__a4, char * x__a5)
{
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
{
S32 argc = 6;
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
if (argc>5)
arguments.push_back(a5);
const char** argv = &arguments[0];
{
   S32 plotID = dAtoi(argv[2]);
   if(plotID > object->MaxPlots)
   {
	   Con::errorf("Invalid plotID.");
	   return;
   }
   object->insertPlotPoint( plotID, dAtoi(argv[3]), Point2F(dAtof(argv[4]), dAtof(argv[5])));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_changePlotPoint(char * x__object, char * x__a2, char * x__a3, char * x__a4, char * x__a5,  char* retval)
{
dSprintf(retval,4096,"");
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* wle_returnObject;
{
S32 argc = 6;
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
if (argc>5)
arguments.push_back(a5);
const char** argv = &arguments[0];
{
   S32 plotID = dAtoi(argv[2]);
   if(plotID > object->MaxPlots)
   {
	   Con::errorf("Invalid plotID.");
      char *retBuffer = Con::getReturnBuffer(64);
      const S32 index = -1;
      dSprintf(retBuffer, 64, "%d", index);
      {wle_returnObject =retBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   }
   char *retBuffer = Con::getReturnBuffer(64);
   const S32 index = object->changePlotPoint( plotID, dAtoi(argv[3]), Point2F(dAtof(argv[4]), dAtof(argv[5])));
   dSprintf(retBuffer, 64, "%d", index);
   {wle_returnObject =retBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_getSelectedPlot(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
{
   char *retBuffer = Con::getReturnBuffer(32);
   const S32 plot = object->getSelectedPlot();
   dSprintf(retBuffer, 32, "%d", plot);
   {wle_returnObject =retBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_getSelectedPoint(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
{
   char *retBuffer = Con::getReturnBuffer(32);
   const S32 point = object->getSelectedPoint();
   dSprintf(retBuffer, 32, "%d", point);
   {wle_returnObject =retBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_isExistingPoint(char * x__object, char * x__a2, char * x__a3,  char* retval)
{
dSprintf(retval,4096,"");
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* wle_returnObject;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   S32 plotID = dAtoi(argv[2]);
   S32 samples = dAtoi(argv[3]);
   if(plotID > object->MaxPlots)
   {
	   Con::errorf("Invalid plotID.");
   }
   if(samples > object->MaxDataPoints)
   {
	   Con::errorf("Invalid sample.");
   }
   char *retBuffer = Con::getReturnBuffer(32);
   const bool isPoint = object->isExistingPoint(plotID, samples);
   dSprintf(retBuffer, 32, "%d", isPoint);
   {wle_returnObject =retBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_getPlotPoint(char * x__object, char * x__a2, char * x__a3,  char* retval)
{
dSprintf(retval,4096,"");
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* wle_returnObject;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   S32 plotID = dAtoi(argv[2]);
   S32 samples = dAtoi(argv[3]);
   if(plotID > object->MaxPlots)
   {
	   Con::errorf("Invalid plotID.");
   }
   if(samples > object->MaxDataPoints)
   {
	   Con::errorf("Invalid sample.");
   }
   char *retBuffer = Con::getReturnBuffer(64);
   const Point2F &pos = object->getPlotPoint(plotID, samples);
   dSprintf(retBuffer, 64, "%f %f", pos.x, pos.y);
   {wle_returnObject =retBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_getPlotIndex(char * x__object, char * x__a2, char * x__a3, char * x__a4,  char* retval)
{
dSprintf(retval,4096,"");
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* wle_returnObject;
{
S32 argc = 5;
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
const char** argv = &arguments[0];
{
   S32 plotID = dAtoi(argv[2]);
   F32 x = dAtof(argv[3]);
   F32 y = dAtof(argv[4]);
   if(plotID > object->MaxPlots)
   {
	   Con::errorf("Invalid plotID.");
   }
   char *retBuffer = Con::getReturnBuffer(32);
   const S32 &index = object->getPlotIndex(plotID, x, y);
   dSprintf(retBuffer, 32, "%d", index);
   {wle_returnObject =retBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_getGraphColor(char * x__object, char * x__a2,  char* retval)
{
dSprintf(retval,4096,"");
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   S32 plotID = dAtoi(argv[2]);
   if(plotID > object->MaxPlots)
   {
	   Con::errorf("Invalid plotID.");
   }
   char *retBuffer = Con::getReturnBuffer(64);
   const ColorF &color = object->getGraphColor(plotID);
   dSprintf(retBuffer, 64, "%f %f %f", color.red, color.green, color.blue);
   {wle_returnObject =retBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_getGraphMin(char * x__object, char * x__a2,  char* retval)
{
dSprintf(retval,4096,"");
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   S32 plotID = dAtoi(argv[2]);
   if(plotID > object->MaxPlots)
   {
	   Con::errorf("Invalid plotID.");
   }
   char *retBuffer = Con::getReturnBuffer(64);
   const Point2F graphMin = object->getGraphMin(plotID);
   dSprintf(retBuffer, 64, "%f %f", graphMin.x, graphMin.y);
   {wle_returnObject =retBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_getGraphMax(char * x__object, char * x__a2,  char* retval)
{
dSprintf(retval,4096,"");
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   S32 plotID = dAtoi(argv[2]);
   if(plotID > object->MaxPlots)
   {
	   Con::errorf("Invalid plotID.");
   }
   char *retBuffer = Con::getReturnBuffer(64);
   const Point2F graphMax = object->getGraphMax(plotID);
   dSprintf(retBuffer, 64, "%f %f", graphMax.x, graphMax.y);
   {wle_returnObject =retBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_getGraphName(char * x__object, char * x__a2,  char* retval)
{
dSprintf(retval,4096,"");
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   S32 plotID = dAtoi(argv[2]);
   if(plotID > object->MaxPlots)
   {
	   Con::errorf("Invalid plotID.");
   }
   char *retBuffer = Con::getReturnBuffer(64);
   const StringTableEntry graphName = object->getGraphName(plotID);
   dSprintf(retBuffer, 64, "%s", graphName);
   {wle_returnObject =retBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_setGraphMin(char * x__object, char * x__a2, char * x__a3, char * x__a4)
{
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
{
S32 argc = 5;
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
const char** argv = &arguments[0];
{
	S32 plotID = dAtoi(argv[2]);
	if(plotID > object->MaxPlots)
	{
		Con::errorf("Invalid plotID.");
		return;
	}
	object->setGraphMin(dAtoi(argv[2]), Point2F(dAtof(argv[3]), dAtof(argv[4])));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_setGraphMinX(char * x__object, char * x__a2, char * x__a3)
{
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
	S32 plotID = dAtoi(argv[2]);
	if(plotID > object->MaxPlots)
	{
		Con::errorf("Invalid plotID.");
		return;
	}
	object->setGraphMinX(dAtoi(argv[2]), dAtof(argv[3]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_setGraphMinY(char * x__object, char * x__a2, char * x__a3)
{
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
	S32 plotID = dAtoi(argv[2]);
	if(plotID > object->MaxPlots)
	{
		Con::errorf("Invalid plotID.");
		return;
	}
	object->setGraphMinY(dAtoi(argv[2]), dAtof(argv[3]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_setGraphMax(char * x__object, char * x__a2, char * x__a3, char * x__a4)
{
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
{
S32 argc = 5;
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
const char** argv = &arguments[0];
{
	S32 plotID = dAtoi(argv[2]);
	if(plotID > object->MaxPlots)
	{
		Con::errorf("Invalid plotID.");
		return;
	}
	object->setGraphMax(dAtoi(argv[2]), Point2F(dAtof(argv[3]), dAtof(argv[4])));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_setGraphMaxX(char * x__object, char * x__a2, char * x__a3)
{
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
	S32 plotID = dAtoi(argv[2]);
	if(plotID > object->MaxPlots)
	{
		Con::errorf("Invalid plotID.");
		return;
	}
	object->setGraphMaxX(dAtoi(argv[2]), dAtof(argv[3]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_setGraphMaxY(char * x__object, char * x__a2, char * x__a3)
{
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
	S32 plotID = dAtoi(argv[2]);
	if(plotID > object->MaxPlots)
	{
		Con::errorf("Invalid plotID.");
		return;
	}
	object->setGraphMaxY(dAtoi(argv[2]), dAtof(argv[3]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_setGraphHidden(char * x__object, char * x__a2, char * x__a3)
{
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
	S32 plotID = dAtoi(argv[2]);
	if(plotID > object->MaxPlots)
	{
		Con::errorf("Invalid plotID.");
		return;
	}
	object->setGraphHidden(dAtoi(argv[2]), dAtob(argv[3]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_setAutoGraphMax(char * x__object, char * x__a2)
{
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	object->setAutoGraphMax(dAtob(argv[2]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_setAutoRemove(char * x__object, char * x__a2)
{
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	object->setAutoRemove(dAtob(argv[2]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_setRenderAll(char * x__object, char * x__a2)
{
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	object->setRenderAll(dAtob(argv[2]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_setPointXMovementClamped(char * x__object, char * x__a2)
{
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	object->setPointXMovementClamped(dAtob(argv[2]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_setRenderGraphTooltip(char * x__object, char * x__a2)
{
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	object->setRenderGraphTooltip(dAtob(argv[2]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_setGraphName(char * x__object, char * x__a2, char * x__a3)
{
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
	S32 plotID = dAtoi(argv[2]);
	if(plotID > object->MaxPlots)
	{
		Con::errorf("Invalid plotID.");
		return;
	}
	object->setGraphName(dAtoi(argv[2]), argv[3]);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiParticleGraphCtrl_resetSelectedPoint(char * x__object)
{
GuiParticleGraphCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
	object->resetSelectedPoint();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiShapeEdPreview_setOrbitPos(char * x__object, char * x__pos)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F pos = Point3F();
sscanf(x__pos,"%f %f %f", &pos.x,&pos.y,&pos.z);
{
   object->setOrbitPos( pos );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiShapeEdPreview_setModel(char * x__object, char * x__shapePath)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* shapePath = (const char*)x__shapePath;
bool wle_returnObject;
{
   {wle_returnObject =object->setObjectModel( shapePath );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiShapeEdPreview_fitToShape(char * x__object)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->fitToShape();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiShapeEdPreview_refreshShape(char * x__object)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->refreshShape();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiShapeEdPreview_updateNodeTransforms(char * x__object)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->updateNodeTransforms();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiShapeEdPreview_computeShapeBounds(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Box3F wle_returnObject;
{
   Box3F bounds;
   object->computeSceneBounds(bounds);
   {wle_returnObject =bounds;
dSprintf(retval,1024,"%f %f %f %f %f %f ",wle_returnObject.minExtents.x,wle_returnObject.minExtents.y,wle_returnObject.minExtents.z,wle_returnObject.maxExtents.x,wle_returnObject.maxExtents.y,wle_returnObject.maxExtents.z);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiShapeEdPreview_getMeshHidden(char * x__object, char * x__name)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* name = (const char*)x__name;
bool wle_returnObject;
{
   {wle_returnObject =object->getMeshHidden( name );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiShapeEdPreview_setMeshHidden(char * x__object, char * x__name, bool hidden)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* name = (const char*)x__name;

{
   object->setMeshHidden( name, hidden );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiShapeEdPreview_setAllMeshesHidden(char * x__object, bool hidden)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setAllMeshesHidden( hidden );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiShapeEdPreview_exportToCollada(char * x__object, char * x__path)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* path = (const char*)x__path;
{
   object->exportToCollada( path );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiShapeEdPreview_addThread(char * x__object)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->addThread();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiShapeEdPreview_removeThread(char * x__object, S32 slot)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->removeThread( slot );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiShapeEdPreview_getThreadCount(char * x__object)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getThreadCount());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiShapeEdPreview_setTimeScale(char * x__object, F32 scale)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setTimeScale( scale );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiShapeEdPreview_setThreadSequence(char * x__object, char * x__name, F32 duration, F32 pos, bool play)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* name = (const char*)x__name;


{
   object->setActiveThreadSequence( name, duration, pos, play );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiShapeEdPreview_getThreadSequence(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->getThreadSequence();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiShapeEdPreview_refreshThreadSequences(char * x__object)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->refreshThreadSequences();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiShapeEdPreview_mountShape(char * x__object, char * x__shapePath, char * x__nodeName, char * x__type, S32 slot)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* shapePath = (const char*)x__shapePath;
const char* nodeName = (const char*)x__nodeName;
const char* type = (const char*)x__type;

bool wle_returnObject;
{
   {wle_returnObject =object->mountShape( shapePath, nodeName, type, slot );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiShapeEdPreview_setMountNode(char * x__object, S32 slot, char * x__nodeName)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

const char* nodeName = (const char*)x__nodeName;
{
   object->setMountNode( slot, nodeName );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiShapeEdPreview_getMountThreadSequence(char * x__object, S32 slot,  char* retval)
{
dSprintf(retval,4096,"");
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->getMountThreadSequence( slot );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiShapeEdPreview_setMountThreadSequence(char * x__object, S32 slot, char * x__name)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

const char* name = (const char*)x__name;
{
   object->setMountThreadSequence( slot, name );
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnGuiShapeEdPreview_getMountThreadPos(char * x__object, S32 slot)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getMountThreadPos( slot ));
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiShapeEdPreview_setMountThreadPos(char * x__object, S32 slot, F32 pos)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->setMountThreadPos( slot, pos );
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnGuiShapeEdPreview_getMountThreadDir(char * x__object, S32 slot)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getMountThreadDir( slot ));
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiShapeEdPreview_setMountThreadDir(char * x__object, S32 slot, F32 dir)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->setMountThreadDir( slot, dir );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiShapeEdPreview_unmountShape(char * x__object, S32 slot)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   return object->unmountShape( slot );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiShapeEdPreview_unmountAll(char * x__object)
{
GuiShapeEdPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   return object->unmountAll();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiInspectorDynamicField_renameField(char * x__object, char * x__a2)
{
GuiInspectorDynamicField* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->renameField( argv[ 2 ] );
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiInspectorDynamicGroup_inspectGroup(char * x__object)
{
GuiInspectorDynamicGroup* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
{
   {wle_returnObject =object->inspectGroup();
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiInspectorDynamicGroup_addDynamicField(char * x__object)
{
GuiInspectorDynamicGroup* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->addDynamicField();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiInspectorDynamicGroup_removeDynamicField(char * x__object, char * x__a2)
{
GuiInspectorDynamicGroup* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
{
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiInspectorField_getInspector(char * x__object)
{
GuiInspectorField* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
  return (S32)( object->getInspector()->getId());
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiInspectorField_getInspectedFieldName(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiInspectorField* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
{
   {wle_returnObject =object->getFieldName();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiInspectorField_getInspectedFieldType(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiInspectorField* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
{
   {wle_returnObject =object->getFieldType();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiInspectorField_apply(char * x__object, char * x__a2, char * x__a3)
{
GuiInspectorField* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   bool callbacks = true;
   if( argc > 3 )
      callbacks = dAtob( argv[ 3 ] );
      
   object->setData( argv[ 2 ], callbacks );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiInspectorField_applyWithoutUndo(char * x__object, char * x__a2)
{
GuiInspectorField* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->setData( argv[ 2 ], false );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiInspectorField_getData(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiInspectorField* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
{
   {wle_returnObject =object->getData();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiInspectorField_reset(char * x__object)
{
GuiInspectorField* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->resetData();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiVariableInspector_loadVars(char * x__object, char * x__a2)
{
GuiVariableInspector* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->loadVars( argv[2] );
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiMessageVectorCtrl_attach(char * x__object, char * x__item)
{
GuiMessageVectorCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
MessageVector* item; Sim::findObject(x__item, item ); 
bool wle_returnObject;
{
	if (item == NULL)
	{
		Con::errorf(ConsoleLogEntry::General, "Could not find MessageVector: %s", item);
		{wle_returnObject =false;
return (S32)(wle_returnObject);}
	}
	
	{wle_returnObject =object->attach(item);
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMessageVectorCtrl_detach(char * x__object)
{
GuiMessageVectorCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	if (object->isAttached() == false)
	{
		Con::warnf(ConsoleLogEntry::General, "GuiMessageVectorCtrl: double detach");
		return;
	}
	object->detach();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiProgressBitmapCtrl_setBitmap(char * x__object, char * x__filename)
{
GuiProgressBitmapCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* filename = (const char*)x__filename;
{
   object->setBitmap( filename );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTickCtrl_setProcessTicks(char * x__object, char * x__a2)
{
GuiTickCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   if( argc == 3 )
      object->setProcessTicks( dAtob( argv[2] ) );
   else
      object->setProcessTicks();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTheoraCtrl_setFile(char * x__object, char * x__filename)
{
GuiTheoraCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* filename = (const char*)x__filename;
{
	object->setFile( filename );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTheoraCtrl_play(char * x__object)
{
GuiTheoraCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->play();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTheoraCtrl_pause(char * x__object)
{
GuiTheoraCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->pause();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiTheoraCtrl_stop(char * x__object)
{
GuiTheoraCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->stop();
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnGuiTheoraCtrl_getCurrentTime(char * x__object)
{
GuiTheoraCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getCurrentTime());
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGuiTheoraCtrl_isPlaybackDone(char * x__object)
{
GuiTheoraCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isPlaybackDone();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMessageVector_dump(char * x__object, char * x__a2, char * x__a3)
{
MessageVector* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   if ( argc == 4 )
      object->dump( argv[2], argv[3] );
   else
      object->dump( argv[2] );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMessageVector_clear(char * x__object)
{
MessageVector* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMessageVector_pushBackLine(char * x__object, char * x__msg, S32 tag)
{
MessageVector* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* msg = (const char*)x__msg;

{
   object->pushBackLine(msg, tag);
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnMessageVector_popBackLine(char * x__object)
{
MessageVector* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   if (object->getNumLines() == 0) {
      Con::errorf(ConsoleLogEntry::General, "MessageVector::popBackLine(): underflow");
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   }
   object->popBackLine();
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMessageVector_pushFrontLine(char * x__object, char * x__msg, S32 tag)
{
MessageVector* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* msg = (const char*)x__msg;

{
   object->pushFrontLine(msg, tag);
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnMessageVector_popFrontLine(char * x__object)
{
MessageVector* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   if (object->getNumLines() == 0) {
      Con::errorf(ConsoleLogEntry::General, "MessageVector::popFrontLine(): underflow");
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   }
   object->popFrontLine();
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnMessageVector_insertLine(char * x__object, S32 insertPos, char * x__msg, S32 tag)
{
MessageVector* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

const char* msg = (const char*)x__msg;

bool wle_returnObject;
{
   if (insertPos > object->getNumLines())
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   object->insertLine(insertPos, msg, tag);
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnMessageVector_deleteLine(char * x__object, S32 deletePos)
{
MessageVector* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   if (deletePos >= object->getNumLines())
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   object->deleteLine(deletePos);
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnMessageVector_getNumLines(char * x__object)
{
MessageVector* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getNumLines());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMessageVector_getLineTextByTag(char * x__object, S32 tag,  char* retval)
{
dSprintf(retval,4096,"");
MessageVector* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   for(U32 i = 0; i < object->getNumLines(); i++)
      if(object->getLine(i).messageTag == tag)
         {wle_returnObject =object->getLine(i).message;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnMessageVector_getLineIndexByTag(char * x__object, S32 tag)
{
MessageVector* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   for(U32 i = 0; i < object->getNumLines(); i++)
      if(object->getLine(i).messageTag == tag)
        return (S32)( i);
  return (S32)( -1);
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMessageVector_getLineText(char * x__object, S32 pos,  char* retval)
{
dSprintf(retval,4096,"");
MessageVector* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   if (pos >= object->getNumLines()) {
      Con::errorf(ConsoleLogEntry::General, "MessageVector::getLineText(con): out of bounds line");
      {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   }
   {wle_returnObject =object->getLine(pos).message;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnMessageVector_getLineTag(char * x__object, S32 pos)
{
MessageVector* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   if (pos >= object->getNumLines()) {
      Con::errorf(ConsoleLogEntry::General, "MessageVector::getLineTag(con): out of bounds line");
     return (S32)( 0);
   }
  return (S32)( object->getLine(pos).messageTag);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnEditTSCtrl_getDisplayType(char * x__object)
{
EditTSCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getDisplayType());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnEditTSCtrl_setDisplayType(char * x__object, S32 displayType)
{
EditTSCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setDisplayType( displayType );
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnEditTSCtrl_getOrthoFOV(char * x__object)
{
EditTSCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getOrthoFOV());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnEditTSCtrl_setOrthoFOV(char * x__object, F32 fov)
{
EditTSCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setOrthoFOV( fov );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnEditTSCtrl_renderBox(char * x__object, char * x__pos, char * x__size)
{
EditTSCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F pos = Point3F();
sscanf(x__pos,"%f %f %f", &pos.x,&pos.y,&pos.z);
Point3F size = Point3F();
sscanf(x__size,"%f %f %f", &size.x,&size.y,&size.z);
{
   if( !object->mConsoleRendering || !object->mConsoleFillColor.alpha )
      return;
   GFXStateBlockDesc desc;
   desc.setBlend( true );
   Box3F box;
   box.set( size );
   box.setCenter( pos );
   MatrixF camera = GFX->getWorldMatrix();
   camera.inverse();
   if( box.isContained( camera.getPosition() ) )
      desc.setCullMode( GFXCullNone );
   GFX->getDrawUtil()->drawCube( desc, size, pos, object->mConsoleFillColor );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnEditTSCtrl_renderSphere(char * x__object, char * x__pos, F32 radius, S32 sphereLevel)
{
EditTSCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F pos = Point3F();
sscanf(x__pos,"%f %f %f", &pos.x,&pos.y,&pos.z);

{
   if ( !object->mConsoleRendering || !object->mConsoleFillColor.alpha )
      return;
   // TODO: We need to support subdivision levels in GFXDrawUtil!
   if ( sphereLevel <= 0 )
      sphereLevel = object->mConsoleSphereLevel;
   GFXStateBlockDesc desc;
   desc.setBlend( true );
   MatrixF camera = GFX->getWorldMatrix();
   camera.inverse();
   
   SphereF sphere( pos, radius );
   if( sphere.isContained( camera.getPosition() ) )
      desc.setCullMode( GFXCullNone );
   GFX->getDrawUtil()->drawSphere( desc, radius, pos, object->mConsoleFillColor );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnEditTSCtrl_renderCircle(char * x__object, char * x__pos, char * x__normal, F32 radius, S32 segments)
{
EditTSCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F pos = Point3F();
sscanf(x__pos,"%f %f %f", &pos.x,&pos.y,&pos.z);
Point3F normal = Point3F();
sscanf(x__normal,"%f %f %f", &normal.x,&normal.y,&normal.z);

{
   if(!object->mConsoleRendering)
      return;
   if(!object->mConsoleFrameColor.alpha && !object->mConsoleFillColor.alpha)
      return;
   if ( segments <= 0 )
      segments = object->mConsoleCircleSegments;
   normal.normalizeSafe();
   AngAxisF aa;
   F32 dotUp = mDot( normal, Point3F(0,0,1) );
   if ( dotUp == 1.0f )
      aa.set( Point3F(0,0,1), 0.0f );     // normal is 0,0,1
   else if ( dotUp == -1.0f )
      aa.set( Point3F(1,0,0), M_PI_F );   // normal is 0,0,-1
   else
   {
      mCross( normal, Point3F(0,0,1), &aa.axis );
      aa.axis.normalizeSafe();
      aa.angle = mAcos( mClampF( dotUp, -1.f, 1.f ) );
   }
   MatrixF mat;
   aa.setMatrix(&mat);
   F32 step = M_2PI / segments;
   F32 angle = 0.f;
   Vector<Point3F> points(segments);
   for(U32 i = 0; i < segments; i++)
   {
      Point3F pnt(mCos(angle), mSin(angle), 0.f);
      mat.mulP(pnt);
      pnt *= radius;
      pnt += pos;
      points.push_front(pnt);
      angle += step;
   }
   GFX->setStateBlock(object->mBlendSB);
   // framed
   if(object->mConsoleFrameColor.alpha)
   {
      // TODO: Set GFX line width (when it exists) to the value of 'object->mConsoleLineWidth'
      PrimBuild::color( object->mConsoleFrameColor );
      PrimBuild::begin( GFXLineStrip, points.size() + 1 );
      for( int i = 0; i < points.size(); i++ )
         PrimBuild::vertex3fv( points[i] );
      // GFX does not have a LineLoop primitive, so connect the last line
      if( points.size() > 0 )
         PrimBuild::vertex3fv( points[0] );
      PrimBuild::end();
      // TODO: Reset GFX line width here
   }
   // filled
   if(object->mConsoleFillColor.alpha)
   {
      PrimBuild::color( object->mConsoleFillColor );
      PrimBuild::begin( GFXTriangleFan, points.size() + 2 );
      // Center point
      PrimBuild::vertex3fv( pos );
      // Edge verts
      for( int i = 0; i < points.size(); i++ )
         PrimBuild::vertex3fv( points[i] );
      PrimBuild::vertex3fv( points[0] );
      PrimBuild::end();
   }
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnEditTSCtrl_renderTriangle(char * x__object, char * x__a, char * x__b, char * x__c)
{
EditTSCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F a = Point3F();
sscanf(x__a,"%f %f %f", &a.x,&a.y,&a.z);
Point3F b = Point3F();
sscanf(x__b,"%f %f %f", &b.x,&b.y,&b.z);
Point3F c = Point3F();
sscanf(x__c,"%f %f %f", &c.x,&c.y,&c.z);
{
   if(!object->mConsoleRendering)
      return;
   if(!object->mConsoleFrameColor.alpha && !object->mConsoleFillColor.alpha)
      return;
   const Point3F* pnts[3] = { &a, &b, &c };
   GFX->setStateBlock(object->mBlendSB);
   // frame
   if( object->mConsoleFrameColor.alpha )
   {
      PrimBuild::color( object->mConsoleFrameColor );
  
      // TODO: Set GFX line width (when it exists) to the value of 'object->mConsoleLineWidth'
      PrimBuild::begin( GFXLineStrip, 4 );
         PrimBuild::vertex3fv( *pnts[0] );
         PrimBuild::vertex3fv( *pnts[1] );
         PrimBuild::vertex3fv( *pnts[2] );
         PrimBuild::vertex3fv( *pnts[0] );
      PrimBuild::end();
      // TODO: Reset GFX line width here
   }
   // fill
   if( object->mConsoleFillColor.alpha )
   {
      PrimBuild::color( object->mConsoleFillColor );
      PrimBuild::begin( GFXTriangleList, 3 );
         PrimBuild::vertex3fv( *pnts[0] );
         PrimBuild::vertex3fv( *pnts[1] );
         PrimBuild::vertex3fv( *pnts[2] );
      PrimBuild::end();
   }
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnEditTSCtrl_renderLine(char * x__object, char * x__start, char * x__end, F32 lineWidth)
{
EditTSCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F start = Point3F();
sscanf(x__start,"%f %f %f", &start.x,&start.y,&start.z);
Point3F end = Point3F();
sscanf(x__end,"%f %f %f", &end.x,&end.y,&end.z);
{
   if ( !object->mConsoleRendering || !object->mConsoleFrameColor.alpha )
      return;
   // TODO: We don't support 3d lines with width... fix this!
   if ( lineWidth <= 0 )
      lineWidth = object->mConsoleLineWidth;
   GFX->getDrawUtil()->drawLine( start, end, object->mConsoleFrameColor );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnEditTSCtrl_getGizmo(char * x__object)
{
EditTSCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getGizmo()->getId());
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnEditTSCtrl_isMiddleMouseDown(char * x__object)
{
EditTSCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isMiddleMouseDown();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMissionAreaCtrl_setMissionArea(char * x__object, char * x__area)
{
GuiMissionAreaCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
MissionArea* area; Sim::findObject(x__area, area ); 
{
   object->setMissionArea( area );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMissionAreaCtrl_updateTerrain(char * x__object)
{
GuiMissionAreaCtrl* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->updateTerrain();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMECreateUndoAction_addObject(char * x__object, char * x__a2)
{
MECreateUndoAction* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   SimObject *obj = NULL;
   if ( Sim::findObject( argv[2], obj ) && obj )
   	object->addObject( obj );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMEDeleteUndoAction_deleteObject(char * x__object, char * x__a2)
{
MEDeleteUndoAction* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   SimObject *obj = NULL;
   if ( Sim::findObject( argv[2], obj ) && obj )
   	object->deleteObject( obj );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_ignoreObjClass(char * x__object, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10, char * x__a11, char * x__a12, char * x__a13, char * x__a14, char * x__a15, char * x__a16, char * x__a17, char * x__a18, char * x__a19)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* a11 = (const char*)x__a11;
const char* a12 = (const char*)x__a12;
const char* a13 = (const char*)x__a13;
const char* a14 = (const char*)x__a14;
const char* a15 = (const char*)x__a15;
const char* a16 = (const char*)x__a16;
const char* a17 = (const char*)x__a17;
const char* a18 = (const char*)x__a18;
const char* a19 = (const char*)x__a19;
{
S32 argc = 20;
if (dStrlen(a19)==0)
if (dStrlen(a18)==0)
if (dStrlen(a17)==0)
if (dStrlen(a16)==0)
if (dStrlen(a15)==0)
if (dStrlen(a14)==0)
if (dStrlen(a13)==0)
if (dStrlen(a12)==0)
if (dStrlen(a11)==0)
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
else
argc=12;
else
argc=13;
else
argc=14;
else
argc=15;
else
argc=16;
else
argc=17;
else
argc=18;
else
argc=19;
else
argc=20;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
if (argc>5)
arguments.push_back(a5);
if (argc>6)
arguments.push_back(a6);
if (argc>7)
arguments.push_back(a7);
if (argc>8)
arguments.push_back(a8);
if (argc>9)
arguments.push_back(a9);
if (argc>10)
arguments.push_back(a10);
if (argc>11)
arguments.push_back(a11);
if (argc>12)
arguments.push_back(a12);
if (argc>13)
arguments.push_back(a13);
if (argc>14)
arguments.push_back(a14);
if (argc>15)
arguments.push_back(a15);
if (argc>16)
arguments.push_back(a16);
if (argc>17)
arguments.push_back(a17);
if (argc>18)
arguments.push_back(a18);
if (argc>19)
arguments.push_back(a19);
const char** argv = &arguments[0];
{
	object->ignoreObjClass(argc, argv);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_clearIgnoreList(char * x__object)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
	object->clearIgnoreList();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_clearSelection(char * x__object)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
	object->clearSelection();
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnWorldEditor_getActiveSelection(char * x__object)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
   if( !object->getActiveSelectionSet() )
     return (S32)( 0);
      
  return (S32)( object->getActiveSelectionSet()->getId());
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_setActiveSelection(char * x__object, char * x__a2)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   WorldEditorSelection* selection;
   if( !Sim::findObject( argv[ 2 ], selection ) )
   {
      Con::errorf( "WorldEditor::setActiveSelectionSet - no selection set '%s'", argv[ 2 ] );
      return;
   }
   
   object->makeActiveSelectionSet( selection );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_selectObject(char * x__object, char * x__a2)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	object->selectObject(argv[2]);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_unselectObject(char * x__object, char * x__a2)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	object->unselectObject(argv[2]);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_invalidateSelectionCentroid(char * x__object)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   WorldEditor::Selection* sel = object->getActiveSelectionSet();
   if(sel)
	   sel->invalidateCentroid();
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnWorldEditor_getSelectionSize(char * x__object)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
	return object->getSelectionSize();
}
}
;
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnWorldEditor_getSelectedObject(char * x__object, char * x__a2)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   S32 index = dAtoi(argv[2]);
   if(index < 0 || index >= object->getSelectionSize())
   {
      Con::errorf(ConsoleLogEntry::General, "WorldEditor::getSelectedObject: invalid object index");
     return (S32)((-1));
   }
  return (S32)((object->getSelectObject(index)));
}
}
;
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnWorldEditor_getSelectionRadius(char * x__object)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
	return object->getSelectionRadius();
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_getSelectionCentroid(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char * wle_returnObject;
{
{
	{wle_returnObject =object->getSelectionCentroidText();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_getSelectionExtent(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char * wle_returnObject;
{
{
   Point3F bounds = object->getSelectionExtent();
   char * ret = Con::getReturnBuffer(100);
   dSprintf(ret, 100, "%g %g %g", bounds.x, bounds.y, bounds.z);
   {wle_returnObject =ret;	
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_dropSelection(char * x__object, char * x__a2)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   bool skipUndo = false;
   if ( argc > 2 )
      skipUndo = dAtob( argv[2] );
	object->dropCurrentSelection( skipUndo );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_cutSelection(char * x__object)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->cutCurrentSelection();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_copySelection(char * x__object)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->copyCurrentSelection();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_pasteSelection(char * x__object)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->pasteSelection();
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnWorldEditor_canPasteSelection(char * x__object)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
{
	{wle_returnObject =object->canPasteSelection();
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_hideObject(char * x__object, char * x__a2, char * x__a3)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   SceneObject *obj;
   if ( !Sim::findObject( argv[2], obj ) )
      return;
   object->hideObject(obj, dAtob(argv[3]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_hideSelection(char * x__object, char * x__a2)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->hideSelection(dAtob(argv[2]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_lockSelection(char * x__object, char * x__a2)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->lockSelection(dAtob(argv[2]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_alignByBounds(char * x__object, char * x__a2)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	if(!object->alignByBounds(dAtoi(argv[2])))
		Con::warnf(ConsoleLogEntry::General, avar("worldEditor.alignByBounds: invalid bounds axis '%s'", argv[2]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_alignByAxis(char * x__object, char * x__a2)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	if(!object->alignByAxis(dAtoi(argv[2])))
		Con::warnf(ConsoleLogEntry::General, avar("worldEditor.alignByAxis: invalid axis '%s'", argv[2]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_resetSelectedRotation(char * x__object)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
	object->resetSelectedRotation();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_resetSelectedScale(char * x__object)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
	object->resetSelectedScale();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_redirectConsole(char * x__object, char * x__a2)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->redirectConsole(dAtoi(argv[2]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_addUndoState(char * x__object)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
	object->addUndoState();
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnWorldEditor_getSoftSnap(char * x__object)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
{
	{wle_returnObject =object->mSoftSnap;
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_setSoftSnap(char * x__object, char * x__a2)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	object->mSoftSnap = dAtob(argv[2]);
}
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnWorldEditor_getSoftSnapSize(char * x__object)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
	return object->mSoftSnapSize;
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_setSoftSnapSize(char * x__object, char * x__a2)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	object->mSoftSnapSize = dAtof(argv[2]);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_softSnapSizeByBounds(char * x__object, char * x__a2)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	object->mSoftSnapSizeByBounds = dAtob(argv[2]);
}
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnWorldEditor_getSoftSnapBackfaceTolerance(char * x__object)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
	return object->mSoftSnapBackfaceTolerance;
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_setSoftSnapBackfaceTolerance(char * x__object, char * x__a2)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	object->mSoftSnapBackfaceTolerance = dAtof(argv[2]);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_softSnapRender(char * x__object, char * x__a2)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	object->mSoftSnapRender = dAtob(argv[2]);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_softSnapRenderTriangle(char * x__object, char * x__a2)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	object->mSoftSnapRenderTriangle = dAtob(argv[2]);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_softSnapDebugRender(char * x__object, char * x__a2)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	object->mSoftSnapDebugRender = dAtob(argv[2]);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_transformSelection(char * x__object, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10, char * x__a11, char * x__a12)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* a11 = (const char*)x__a11;
const char* a12 = (const char*)x__a12;
{
S32 argc = 13;
if (dStrlen(a12)==0)
if (dStrlen(a11)==0)
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
else
argc=12;
else
argc=13;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
if (argc>5)
arguments.push_back(a5);
if (argc>6)
arguments.push_back(a6);
if (argc>7)
arguments.push_back(a7);
if (argc>8)
arguments.push_back(a8);
if (argc>9)
arguments.push_back(a9);
if (argc>10)
arguments.push_back(a10);
if (argc>11)
arguments.push_back(a11);
if (argc>12)
arguments.push_back(a12);
const char** argv = &arguments[0];
{
   bool position = dAtob(argv[2]);
   Point3F p(0.0f, 0.0f, 0.0f);
   dSscanf(argv[3], "%g %g %g", &p.x, &p.y, &p.z);
   bool relativePos = dAtob(argv[4]);
   bool rotate = dAtob(argv[5]);
   EulerF r(0.0f, 0.0f, 0.0f);
   dSscanf(argv[6], "%g %g %g", &r.x, &r.y, &r.z);
   bool relativeRot = dAtob(argv[7]);
   bool rotLocal = dAtob(argv[8]);
   S32 scaleType = dAtoi(argv[9]);
   Point3F s(1.0f, 1.0f, 1.0f);
   dSscanf(argv[10], "%g %g %g", &s.x, &s.y, &s.z);
   bool sRelative = dAtob(argv[11]);
   bool sLocal = dAtob(argv[12]);
   object->transformSelection(position, p, relativePos, rotate, r, relativeRot, rotLocal, scaleType, s, sRelative, sLocal);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_colladaExportSelection(char * x__object, char * x__a2)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{  
   object->colladaExportSelection( argv[2] );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_makeSelectionPrefab(char * x__object, char * x__a2)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->makeSelectionPrefab( argv[2] );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_explodeSelectedPrefab(char * x__object)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->explodeSelectedPrefab();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_mountRelative(char * x__object, char * x__a2, char * x__a3)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   SceneObject *objA;
   if ( !Sim::findObject( argv[2], objA ) )
      return;
   SceneObject *objB;
   if ( !Sim::findObject( argv[3], objB ) )
      return;
   MatrixF xfm = objB->getTransform();   
   MatrixF mat = objA->getWorldTransform();
   xfm.mul( mat );
   
   Point3F pos = objB->getPosition();
   MatrixF temp = objA->getTransform();
   temp.scale( objA->getScale() );
   temp.inverse();
   temp.mulP( pos );
   
   xfm.setPosition( pos );
   
   objA->mountObject( objB, -1, xfm );
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnWorldEditor_getSoftSnapAlignment(char * x__object)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
WorldEditor::AlignmentType wle_returnObject;
{
   {wle_returnObject =object->mSoftSnapAlignment;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_setSoftSnapAlignment(char * x__object, S32 x__type)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
WorldEditor::AlignmentType type = (WorldEditor::AlignmentType)x__type;
{
   object->mSoftSnapAlignment = type;
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnWorldEditor_getTerrainSnapAlignment(char * x__object)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
WorldEditor::AlignmentType wle_returnObject;
{
   {wle_returnObject =object->mTerrainSnapAlignment;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_setTerrainSnapAlignment(char * x__object, S32 x__alignment)
{
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
WorldEditor::AlignmentType alignment = (WorldEditor::AlignmentType)x__alignment;
{
   object->mTerrainSnapAlignment = alignment;
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_createPolyhedralObject(char * x__object, char * x__className, char * x__geometryProvider,  char* retval)
{
dSprintf(retval,1024,"");
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* className = (const char*)x__className;
SceneObject* geometryProvider; Sim::findObject(x__geometryProvider, geometryProvider ); 
SceneObject* wle_returnObject;
{
   if( !geometryProvider )
   {
      Con::errorf( "WorldEditor::createPolyhedralObject - Invalid geometry provider!" );
      {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
   }
   if( !className || !className[ 0 ] )
   {
      Con::errorf( "WorldEditor::createPolyhedralObject - Invalid class name" );
      {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
   }
   AbstractClassRep* classRep = AbstractClassRep::findClassRep( className );
   if( !classRep )
   {
      Con::errorf( "WorldEditor::createPolyhedralObject - No such class: %s", className );
      {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
   }
   // We don't want the extracted poly list to be affected by the object's
   // current transform and scale so temporarily reset them.
   MatrixF savedTransform = geometryProvider->getTransform();
   Point3F savedScale = geometryProvider->getScale();
   geometryProvider->setTransform( MatrixF::Identity );
   geometryProvider->setScale( Point3F( 1.f, 1.f, 1.f ) );
   // Extract the geometry.  Use the object-space bounding volumes
   // as we have moved the object to the origin for the moment.
   OptimizedPolyList polyList;
   if( !geometryProvider->buildPolyList( PLC_Export, &polyList, geometryProvider->getObjBox(), geometryProvider->getObjBox().getBoundingSphere() ) )
   {
      Con::errorf( "WorldEditor::createPolyhedralObject - Failed to extract geometry!" );
      {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
   }
   // Restore the object's original transform.
   geometryProvider->setTransform( savedTransform );
   geometryProvider->setScale( savedScale );
   // Create the object.
   SceneObject* object = dynamic_cast< SceneObject* >( classRep->create() );
   if( !Object )
   {
      Con::errorf( "WorldEditor::createPolyhedralObject - Could not create SceneObject with class '%s'", className );
      {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
   }
   // Convert the polylist to a polyhedron.
   Polyhedron polyhedron = polyList.toPolyhedron();
   // Add the vertex data.
   const U32 numPoints = polyhedron.getNumPoints();
   const Point3F* points = polyhedron.getPoints();
   for( U32 i = 0; i < numPoints; ++ i )
   {
      static StringTableEntry sPoint = StringTable->insert( "point" );
      object->setDataField( sPoint, NULL, EngineMarshallData( points[ i ] ) );
   }
   // Add the plane data.
   const U32 numPlanes = polyhedron.getNumPlanes();
   const PlaneF* planes = polyhedron.getPlanes();
   for( U32 i = 0; i < numPlanes; ++ i )
   {
      static StringTableEntry sPlane = StringTable->insert( "plane" );
      const PlaneF& plane = planes[ i ];
      char buffer[ 1024 ];
      dSprintf( buffer, sizeof( buffer ), "%g %g %g %g", plane.x, plane.y, plane.z, plane.d );
      object->setDataField( sPlane, NULL, buffer );
   }
   // Add the edge data.
   const U32 numEdges = polyhedron.getNumEdges();
   const Polyhedron::Edge* edges = polyhedron.getEdges();
   for( U32 i = 0; i < numEdges; ++ i )
   {
      static StringTableEntry sEdge = StringTable->insert( "edge" );
      const Polyhedron::Edge& edge = edges[ i ];
      char buffer[ 1024 ];
      dSprintf( buffer, sizeof( buffer ), "%i %i %i %i ",
         edge.face[ 0 ], edge.face[ 1 ],
         edge.vertex[ 0 ], edge.vertex[ 1 ]
      );
      object->setDataField( sEdge, NULL, buffer );
   }
   // Set the transform.
   object->setTransform( savedTransform );
   object->setScale( savedScale );
   // Register and return the object.
   if( !object->registerObject() )
   {
      Con::errorf( "WorldEditor::createPolyhedralObject - Failed to register object!" );
      delete object;
      {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
   }
   {wle_returnObject =object;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnWorldEditor_createConvexShapeFrom(char * x__object, char * x__polyObject,  char* retval)
{
dSprintf(retval,1024,"");
WorldEditor* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
SceneObject* polyObject; Sim::findObject(x__polyObject, polyObject ); 
ConvexShape* wle_returnObject;
{
   if( !polyObject )
   {
      Con::errorf( "WorldEditor::createConvexShapeFrom - Invalid object" );
      {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
   }
   IScenePolyhedralObject* iPoly = dynamic_cast< IScenePolyhedralObject* >( polyObject );
   if( !iPoly )
   {
      Con::errorf( "WorldEditor::createConvexShapeFrom - Not a polyhedral object!" );
      {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
   }
   // Get polyhedron.
   AnyPolyhedron polyhedron = iPoly->ToAnyPolyhedron();
   const U32 numPlanes = polyhedron.getNumPlanes();
   if( !numPlanes )
   {
      Con::errorf( "WorldEditor::createConvexShapeFrom - Object returned no valid polyhedron" );
      {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
   }
   // Create a ConvexShape.
   ConvexShape* shape = new ConvexShape();
   // Add all planes.
   for( U32 i = 0; i < numPlanes; ++ i )
   {
      const PlaneF& plane = polyhedron.getPlanes()[ i ];
      // Polyhedron planes are facing inwards so we need to
      // invert the normal here.
      Point3F normal = plane.getNormal();
      normal.neg();
      // Turn the orientation of the plane into a quaternion.
      // The normal is our up vector (that's what's expected
      // by ConvexShape for the surface orientation).
      MatrixF orientation( true );
      MathUtils::getMatrixFromUpVector( normal, &orientation );
      const QuatF quat( orientation );
      // Get the plane position.
      const Point3F position = plane.getPosition();
      // Turn everything into a "surface" property for the ConvexShape.
      char buffer[ 1024 ];
      dSprintf( buffer, sizeof( buffer ), "%g %g %g %g %g %g %g",
         quat.x, quat.y, quat.z, quat.w,
         position.x, position.y, position.z
      );
      // Add the surface.
      static StringTableEntry sSurface = StringTable->insert( "surface" );
      shape->setDataField( sSurface, NULL, buffer );
   }
   // Copy the transform.
   shape->setTransform( polyObject->getTransform() );
   shape->setScale( polyObject->getScale() );
   // Register the shape.
   if( !shape->registerObject() )
   {
      Con::errorf( "WorldEditor::createConvexShapeFrom - Could not register ConvexShape!" );
      delete shape;
      {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
   }
   {wle_returnObject =shape;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnLangTable_addLanguage(char * x__object, char * x__a2, char * x__a3)
{
LangTable* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
	UTF8 scriptFilenameBuffer[1024];
	
	Con::expandScriptFilename((char*)scriptFilenameBuffer, sizeof(scriptFilenameBuffer), argv[2]);
	return object->addLanguage(scriptFilenameBuffer, argc == 4 ? (const UTF8*)argv[3] : NULL);
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnLangTable_getString(char * x__object, char * x__a2,  char* retval)
{
dSprintf(retval,4096,"");
LangTable* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char * wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	const char * str =	(const char*)object->getString(dAtoi(argv[2]));
	if(str != NULL)
	{
		char * ret = Con::getReturnBuffer(dStrlen(str) + 1);
		dStrcpy(ret, str);
		{wle_returnObject =ret;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
	}
	
	{wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnLangTable_setDefaultLanguage(char * x__object, char * x__a2)
{
LangTable* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	object->setDefaultLanguage(dAtoi(argv[2]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnLangTable_setCurrentLanguage(char * x__object, char * x__a2)
{
LangTable* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	object->setCurrentLanguage(dAtoi(argv[2]));
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnLangTable_getCurrentLanguage(char * x__object)
{
LangTable* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
	return object->getCurrentLanguage();
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnLangTable_getLangName(char * x__object, char * x__a2,  char* retval)
{
dSprintf(retval,4096,"");
LangTable* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char * wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
	const char * str = (const char*)object->getLangName(dAtoi(argv[2]));
	if(str != NULL)
	{
		char * ret = Con::getReturnBuffer(dStrlen(str) + 1);
		dStrcpy(ret, str);
		{wle_returnObject =ret;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
	}
	
	{wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnLangTable_getNumLang(char * x__object)
{
LangTable* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
	return object->getNumLang();
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__setInteriorFocusedDebug(char * x__a1)
{
const char* a1 = (const char*)x__a1;
{
S32 argc = 2;
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
const char** argv = &arguments[0];
{
   if (dAtob(argv[1])) {
      Interior::smFocusedDebug = true;
   } else {
      Interior::smFocusedDebug = false;
   }
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn__isPointInside(char * x__a1, char * x__a2, char * x__a3)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
bool wle_returnObject;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   static bool lastValue = false;
   if(!(argc == 2 || argc == 4))
   {
      Con::errorf(ConsoleLogEntry::General, "cIsPointInside: invalid parameters");
      {wle_returnObject =(lastValue);
return (S32)(wle_returnObject);}
   }
   Point3F pos;
   if(argc == 2)
      dSscanf(argv[1], "%g %g %g", &pos.x, &pos.y, &pos.z);
   else
   {
      pos.x = dAtof(argv[1]);
      pos.y = dAtof(argv[2]);
      pos.z = dAtof(argv[3]);
   }
   RayInfo collision;
   if(gClientContainer.castRay(pos, Point3F(pos.x, pos.y, pos.z - 2000.f), InteriorObjectType, &collision))
   {
      if(collision.face == -1)
         Con::errorf(ConsoleLogEntry::General, "cIsPointInside: failed to find hit face on interior");
      else
      {
         InteriorInstance * interior = dynamic_cast<InteriorInstance *>(collision.object);
         if(interior)
            lastValue = !interior->getDetailLevel(0)->isSurfaceOutsideVisible(collision.face);
         else
            Con::errorf(ConsoleLogEntry::General, "cIsPointInside: invalid interior on collision");
      }
   }
   {wle_returnObject =(lastValue);
return (S32)(wle_returnObject);}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_setInteriorRenderMode(S32 mode)
{
{
	if (mode < 0 || mode > Interior::ShowDetailLevel)
		mode = 0;
	Interior::smRenderMode = mode;
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPathedInterior_setPathPosition(char * x__object, char * x__a2)
{
PathedInterior* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   ((PathedInterior *) object)->setPathPosition(dAtoi(argv[2]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPathedInterior_setTargetPosition(char * x__object, char * x__a2)
{
PathedInterior* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   ((PathedInterior *) object)->setTargetPosition(dAtoi(argv[2]));
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_setLightManager(char * x__name)
{
const char* name = (const char*)x__name;
bool wle_returnObject;
{
   {wle_returnObject =gClientSceneGraph->setLightManager( name );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_lightScene(char * x__completeCallbackFn, char * x__mode)
{
const char* completeCallbackFn = (const char*)x__completeCallbackFn;
const char* mode = (const char*)x__mode;
bool wle_returnObject;
{
   if ( !LIGHTMGR )
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   {wle_returnObject =LIGHTMGR->lightScene( completeCallbackFn, mode );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getLightManagerNames(char* retval)
{
dSprintf(retval,1024,"");
String wle_returnObject;
{
   String names;
   LightManager::getLightManagerNames( &names );
   {wle_returnObject =names;
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getActiveLightManager(char* retval)
{
dSprintf(retval,4096,"");
const char* wle_returnObject;
{
   if ( !LIGHTMGR )
      {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   {wle_returnObject =LIGHTMGR->getName();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_resetLightManager()
{
{
   LightManager *lm = LIGHTMGR;
   if ( !lm )
      return;
   SceneManager *sm = lm->getSceneManager();
   lm->deactivate();
   lm->activate( sm );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__setShadowVizLight(char * x__a1,  char* retval)
{
dSprintf(retval,4096,"");
const char* a1 = (const char*)x__a1;
const char* wle_returnObject;
{
S32 argc = 2;
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
const char** argv = &arguments[0];
{
   static const String DebugTargetName( "AL_ShadowVizTexture" );
   NamedTexTarget *target = NamedTexTarget::find( DebugTargetName );
   if ( target )
      target->unregister();
   AdvancedLightManager *lm = dynamic_cast<AdvancedLightManager*>( LIGHTMGR );
   if ( !lm )
      {wle_returnObject =0;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   SimObject *object;
   Sim::findObject( argv[1], object );
   LightShadowMap *lightShadowMap = lm->findShadowMapForObject( object );
   if ( !lightShadowMap || !lightShadowMap->getTexture() )
      {wle_returnObject =0;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   lightShadowMap->setDebugTarget( DebugTargetName );
   GFXTextureObject *texObject = lightShadowMap->getTexture();
   const Point3I &size = texObject->getSize();
   F32 aspect = (F32)size.x / (F32)size.y;
   char *result = Con::getReturnBuffer( 64 );
   dSprintf( result, 64, "%d %d %g", size.x, size.y, aspect ); 
   {wle_returnObject =result;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMaterial_flush(char * x__object)
{
Material* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->flush();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMaterial_reload(char * x__object)
{
Material* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->reload();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMaterial_dumpInstances(char * x__object)
{
Material* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   MATMGR->dumpMaterialInstances( object );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMaterial_getAnimFlags(char * x__object, char * x__a2,  char* retval)
{
dSprintf(retval,4096,"");
Material* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   char * animFlags = Con::getReturnBuffer(512);
   if(object->mAnimFlags[ dAtoi(argv[2]) ] & Material::Scroll)
   {
	   if(dStrcmp( animFlags, "" ) == 0)
	      dStrcpy( animFlags, "$Scroll" );
   }
   if(object->mAnimFlags[ dAtoi(argv[2]) ] & Material::Rotate)
   {
	   if(dStrcmp( animFlags, "" ) == 0)
	      dStrcpy( animFlags, "$Rotate" );
	   else
			dStrcat( animFlags, " | $Rotate");
   }
   if(object->mAnimFlags[ dAtoi(argv[2]) ] & Material::Wave)
   {
	   if(dStrcmp( animFlags, "" ) == 0)
	      dStrcpy( animFlags, "$Wave" );
	   else
			dStrcat( animFlags, " | $Wave");
   }
   if(object->mAnimFlags[ dAtoi(argv[2]) ] & Material::Scale)
   {
	   if(dStrcmp( animFlags, "" ) == 0)
	      dStrcpy( animFlags, "$Scale" );
	   else
			dStrcat( animFlags, " | $Scale");
   }
   if(object->mAnimFlags[ dAtoi(argv[2]) ] & Material::Sequence)
   {
	   if(dStrcmp( animFlags, "" ) == 0)
	      dStrcpy( animFlags, "$Sequence" );
	   else
			dStrcat( animFlags, " | $Sequence");
   }
	{wle_returnObject =animFlags;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMaterial_getFilename(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
Material* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
{
	SimObject *material = static_cast<SimObject *>(object);
   {wle_returnObject =material->getFilename();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnMaterial_isAutoGenerated(char * x__object)
{
Material* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
{
   {wle_returnObject =object->isAutoGenerated();
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMaterial_setAutoGenerated(char * x__object, char * x__a2)
{
Material* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->setAutoGenerated(dAtob(argv[2]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__addMaterialMapping(char * x__a1, char * x__a2)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   MATMGR->mapMaterial(argv[1],argv[2]);
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__getMaterialMapping(char * x__a1,  char* retval)
{
dSprintf(retval,4096,"");
const char* a1 = (const char*)x__a1;
const char* wle_returnObject;
{
S32 argc = 2;
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
const char** argv = &arguments[0];
{
   {wle_returnObject =MATMGR->getMapEntry(argv[1]).c_str();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn__getRandom(char * x__a1, char * x__a2)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   if (argc == 2)
     return (F32)( F32(gRandGen.randI(0,getMax( dAtoi(argv[1]), 0 ))));
   else
   {
      if (argc == 3) 
      {
         S32 min = dAtoi(argv[1]);
         S32 max = dAtoi(argv[2]);
         if (min > max) 
         {
            S32 t = min;
            min = max;
            max = t;
         }
        return (F32)( F32(gRandGen.randI(min,max)));
      }
   }
  return (F32)( gRandGen.randF());
}
arguments.clear();
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_VectorAdd(char * x__a, char * x__b,  char* retval)
{
dSprintf(retval,1024,"");
VectorF a = VectorF();
sscanf(x__a,"%f %f %f", &a.x, &a.y, &a.z);

VectorF b = VectorF();
sscanf(x__b,"%f %f %f", &b.x, &b.y, &b.z);

VectorF wle_returnObject;
{
   {wle_returnObject =a + b;
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_VectorSub(char * x__a, char * x__b,  char* retval)
{
dSprintf(retval,1024,"");
VectorF a = VectorF();
sscanf(x__a,"%f %f %f", &a.x, &a.y, &a.z);

VectorF b = VectorF();
sscanf(x__b,"%f %f %f", &b.x, &b.y, &b.z);

VectorF wle_returnObject;
{
   {wle_returnObject =a - b;
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_VectorScale(char * x__a, F32 scalar,  char* retval)
{
dSprintf(retval,1024,"");
VectorF a = VectorF();
sscanf(x__a,"%f %f %f", &a.x, &a.y, &a.z);

VectorF wle_returnObject;
{
   {wle_returnObject =a * scalar;
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_VectorNormalize(char * x__v,  char* retval)
{
dSprintf(retval,1024,"");
VectorF v = VectorF();
sscanf(x__v,"%f %f %f", &v.x, &v.y, &v.z);

VectorF wle_returnObject;
{
   VectorF n( v );
   n.normalizeSafe();
   {wle_returnObject =n;
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_VectorDot(char * x__a, char * x__b)
{
VectorF a = VectorF();
sscanf(x__a,"%f %f %f", &a.x, &a.y, &a.z);

VectorF b = VectorF();
sscanf(x__b,"%f %f %f", &b.x, &b.y, &b.z);

{
  return (F32)( mDot( a, b ));
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_VectorCross(char * x__a, char * x__b,  char* retval)
{
dSprintf(retval,1024,"");
VectorF a = VectorF();
sscanf(x__a,"%f %f %f", &a.x, &a.y, &a.z);

VectorF b = VectorF();
sscanf(x__b,"%f %f %f", &b.x, &b.y, &b.z);

VectorF wle_returnObject;
{
   VectorF v;
   mCross( a, b, &v );
   {wle_returnObject =v;
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_VectorDist(char * x__a, char * x__b)
{
VectorF a = VectorF();
sscanf(x__a,"%f %f %f", &a.x, &a.y, &a.z);

VectorF b = VectorF();
sscanf(x__b,"%f %f %f", &b.x, &b.y, &b.z);

{
   VectorF v = b - a;
  return (F32)( v.len());
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_VectorLen(char * x__v)
{
VectorF v = VectorF();
sscanf(x__v,"%f %f %f", &v.x, &v.y, &v.z);

{
  return (F32)( v.len());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_VectorOrthoBasis(char * x__aa,  char* retval)
{
dSprintf(retval,1024,"");
AngAxisF aa = AngAxisF();
sscanf(x__aa,"%f %f %f %f",&aa.axis.x,&aa.axis.y,&aa.axis.z,&aa.angle);
MatrixF wle_returnObject;
{
   MatrixF mat;
   aa.setMatrix(&mat);
   {wle_returnObject =mat;
dSprintf(retval,1024,"%f %f %f %f %f %f %f ",TransformF(wle_returnObject).mPosition.x,TransformF(wle_returnObject).mPosition.y,TransformF(wle_returnObject).mPosition.z,TransformF(wle_returnObject).mOrientation.axis.x,TransformF(wle_returnObject).mOrientation.axis.y,TransformF(wle_returnObject).mOrientation.axis.z,TransformF(wle_returnObject).mOrientation.angle);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_VectorLerp(char * x__a, char * x__b, F32 t,  char* retval)
{
dSprintf(retval,1024,"");
VectorF a = VectorF();
sscanf(x__a,"%f %f %f", &a.x, &a.y, &a.z);

VectorF b = VectorF();
sscanf(x__b,"%f %f %f", &b.x, &b.y, &b.z);

VectorF wle_returnObject;
{
   VectorF c;
   c.interpolate( a, b, t );
   
   {wle_returnObject =c;
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_MatrixCreate(char * x__position, char * x__orientation,  char* retval)
{
dSprintf(retval,1024,"");
VectorF position = VectorF();
sscanf(x__position,"%f %f %f", &position.x, &position.y, &position.z);

AngAxisF orientation = AngAxisF();
sscanf(x__orientation,"%f %f %f %f",&orientation.axis.x,&orientation.axis.y,&orientation.axis.z,&orientation.angle);
TransformF wle_returnObject;
{
   TransformF transform( position, orientation );
   {wle_returnObject =transform;
dSprintf(retval,1024,"%f %f %f %f %f %f %f ",wle_returnObject.mPosition.x,wle_returnObject.mPosition.y,wle_returnObject.mPosition.z,wle_returnObject.mOrientation.axis.x,wle_returnObject.mOrientation.axis.y,wle_returnObject.mOrientation.axis.z,wle_returnObject.mOrientation.angle);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_MatrixCreateFromEuler(char * x__angles,  char* retval)
{
dSprintf(retval,1024,"");
Point3F angles = Point3F();
sscanf(x__angles,"%f %f %f", &angles.x,&angles.y,&angles.z);
TransformF wle_returnObject;
{
   QuatF rotQ( angles );
   AngAxisF aa;
   aa.set(rotQ);
   {wle_returnObject =TransformF( Point3F::Zero, aa );
dSprintf(retval,1024,"%f %f %f %f %f %f %f ",wle_returnObject.mPosition.x,wle_returnObject.mPosition.y,wle_returnObject.mPosition.z,wle_returnObject.mOrientation.axis.x,wle_returnObject.mOrientation.axis.y,wle_returnObject.mOrientation.axis.z,wle_returnObject.mOrientation.angle);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_MatrixMultiply(char * x__left, char * x__right,  char* retval)
{
dSprintf(retval,1024,"");
TransformF left = TransformF();
sscanf( x__left,"%f %f %f %f %f %f %f", &left.mPosition.x, &left.mPosition.y, &left.mPosition.z, &left.mOrientation.axis.x, &left.mOrientation.axis.y, &left.mOrientation.axis.z, &left.mOrientation.angle);
TransformF right = TransformF();
sscanf( x__right,"%f %f %f %f %f %f %f", &right.mPosition.x, &right.mPosition.y, &right.mPosition.z, &right.mOrientation.axis.x, &right.mOrientation.axis.y, &right.mOrientation.axis.z, &right.mOrientation.angle);
TransformF wle_returnObject;
{
   MatrixF m1 = left.getMatrix();
   MatrixF m2 = right.getMatrix();
   m1.mul( m2 );
   {wle_returnObject =TransformF( m1 );
dSprintf(retval,1024,"%f %f %f %f %f %f %f ",wle_returnObject.mPosition.x,wle_returnObject.mPosition.y,wle_returnObject.mPosition.z,wle_returnObject.mOrientation.axis.x,wle_returnObject.mOrientation.axis.y,wle_returnObject.mOrientation.axis.z,wle_returnObject.mOrientation.angle);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_MatrixMulVector(char * x__transform, char * x__vector,  char* retval)
{
dSprintf(retval,1024,"");
TransformF transform = TransformF();
sscanf( x__transform,"%f %f %f %f %f %f %f", &transform.mPosition.x, &transform.mPosition.y, &transform.mPosition.z, &transform.mOrientation.axis.x, &transform.mOrientation.axis.y, &transform.mOrientation.axis.z, &transform.mOrientation.angle);
VectorF vector = VectorF();
sscanf(x__vector,"%f %f %f", &vector.x, &vector.y, &vector.z);

VectorF wle_returnObject;
{
   MatrixF m = transform.getMatrix();
   m.mulV( vector );
   {wle_returnObject =vector;
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_MatrixMulPoint(char * x__transform, char * x__point,  char* retval)
{
dSprintf(retval,1024,"");
TransformF transform = TransformF();
sscanf( x__transform,"%f %f %f %f %f %f %f", &transform.mPosition.x, &transform.mPosition.y, &transform.mPosition.z, &transform.mOrientation.axis.x, &transform.mOrientation.axis.y, &transform.mOrientation.axis.z, &transform.mOrientation.angle);
Point3F point = Point3F();
sscanf(x__point,"%f %f %f", &point.x,&point.y,&point.z);
Point3F wle_returnObject;
{
   MatrixF m = transform.getMatrix();
   m.mulP( point );
   {wle_returnObject =point;
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getBoxCenter(char * x__box,  char* retval)
{
dSprintf(retval,1024,"");
Box3F box = Box3F();
sscanf(x__box,"%f %f %f %f %f %f",&box.minExtents.x,&box.minExtents.y,&box.minExtents.z,&box.maxExtents.x,&box.maxExtents.y,&box.maxExtents.z);
Point3F wle_returnObject;
{
   {wle_returnObject =box.getCenter();
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_setRandomSeed(S32 seed)
{
{
   if( seed == -1 )
      seed = Platform::getRealMilliseconds();
	MRandomLCG::setGlobalRandSeed( seed );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_getRandomSeed()
{
{
  return (S32)( gRandGen.getSeed());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_mSolveQuadratic(F32 a, F32 b, F32 c,  char* retval)
{
dSprintf(retval,4096,"");

const char* wle_returnObject;
{
   F32 x[2];
   U32 sol = mSolveQuadratic( a, b, c, x );
   char * retBuffer = Con::getReturnBuffer(256);
   dSprintf(retBuffer, 256, "%d %g %g", sol, x[0], x[1]);
   {wle_returnObject =retBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_mSolveCubic(F32 a, F32 b, F32 c, F32 d,  char* retval)
{
dSprintf(retval,4096,"");

const char* wle_returnObject;
{    
   F32 x[3];
   U32 sol = mSolveCubic( a, b, c, d, x );
   char * retBuffer = Con::getReturnBuffer(256);
   dSprintf(retBuffer, 256, "%d %g %g %g", sol, x[0], x[1], x[2]);
   {wle_returnObject =retBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_mSolveQuartic(F32 a, F32 b, F32 c, F32 d, F32 e,  char* retval)
{
dSprintf(retval,4096,"");


const char* wle_returnObject;
{
   F32 x[4];
   char * retBuffer = Con::getReturnBuffer(256);
   U32 sol = mSolveQuartic(a, b, c, d, e, x);
   dSprintf(retBuffer, 256, "%d %g %g %g %g", sol, x[0], x[1], x[2], x[3]);
   {wle_returnObject =retBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_mFloor(F32 v)
{
{
  return (S32)( (S32)mFloor( v ));
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_mRound(F32 v)
{
{
  return (S32)( (S32)mFloor( v + 0.5f ));
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_mCeil(F32 v)
{
{
  return (S32)( (S32)mCeil( v ));
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_mFloatLength(F32 v, U32 precision,  char* retval)
{
dSprintf(retval,4096,"");
const char* wle_returnObject;
{
   char fmtString[8] = "%.0f";
   if (precision > 9)
      precision = 9;
   fmtString[2] = '0' + precision;
   char * outBuffer = Con::getReturnBuffer(256);
   dSprintf(outBuffer, 255, fmtString, v);
   {wle_returnObject =outBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_mAbs(F32 v)
{
{
  return (F32)( mFabs( v ));
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_mFMod(F32 v, F32 d)
{

{
  return (F32)( mFmod( v, d ));
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_mSqrt(F32 v)
{
{
  return (F32)( mSqrt (v ));
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_mPow(F32 v, F32 p)
{

{
  return (F32)( mPow( v, p ));
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_mLog(F32 v)
{
{
  return (F32)( mLog( v ));
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_mSin(F32 v)
{
{
  return (F32)( mSin( v ));
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_mCos(F32 v)
{
{
  return (F32)( mCos( v ));
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_mTan(F32 v)
{
{
  return (F32)( mTan( v ));
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_mAsin(F32 v)
{
{
  return (F32)( mAsin( v ));
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_mAcos(F32 v)
{
{
  return (F32)( mAcos( v ));
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_mAtan(F32 rise, F32 run)
{

{
  return (F32)( mAtan2( rise, run ));
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_mRadToDeg(F32 radians)
{
{
  return (F32)( mRadToDeg( radians ));
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_mDegToRad(F32 degrees)
{
{
  return (F32)( mDegToRad( degrees ));
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_mClamp(F32 v, F32 min, F32 max)
{

{
  return (F32)( mClampF( v, min, max ));
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_mSaturate(F32 v)
{
{
  return (F32)( mClampF( v, 0.0f, 1.0f ));
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_getMax(F32 v1, F32 v2)
{

{
  return (F32)( getMax( v1, v2 ));
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_getMin(F32 v1, F32 v2)
{

{
  return (F32)( getMin( v1, v2 ));
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_mLerp(F32 v1, F32 v2, F32 time)
{

{
  return (F32)( mLerp( v1, v2, time ));
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_mPi()
{
{
  return (F32)( M_PI_F);
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_m2Pi()
{
{
  return (F32)( M_2PI_F);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_mIsPow2(S32 v)
{
bool wle_returnObject;
{
   {wle_returnObject =isPow2( v );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimResponseCurve_addPoint(char * x__object, char * x__a2, char * x__a3)
{
SimResponseCurve* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   object->addPoint( dAtof(argv[2]), dAtof(argv[3]) );
}
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnSimResponseCurve_getValue(char * x__object, char * x__a2)
{
SimResponseCurve* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
  return (F32)( object->getValue( dAtof(argv[2]) ));
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSimResponseCurve_clear(char * x__object)
{
SimResponseCurve* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->clear();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__getTemporaryDirectory(char* retval)
{
dSprintf(retval,4096,"");
const char * wle_returnObject;
{
{
   {wle_returnObject =Platform::getTemporaryDirectory();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__getTemporaryFileName(char* retval)
{
dSprintf(retval,4096,"");
const char * wle_returnObject;
{
{
   {wle_returnObject =Platform::getTemporaryFileName();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_profilerMarkerEnable(char * x__markerName, bool enable)
{
const char* markerName = (const char*)x__markerName;

{
   if( gProfiler )
      gProfiler->enableMarker( markerName, enable );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_profilerEnable(bool enable)
{
{
   if(gProfiler)
      gProfiler->enable(enable);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_profilerDump()
{
{
   if(gProfiler)
      gProfiler->dumpToConsole();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_profilerDumpToFile(char * x__fileName)
{
const char* fileName = (const char*)x__fileName;
{
   if(gProfiler)
      gProfiler->dumpToFile(fileName);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_profilerReset()
{
{
   if(gProfiler)
      gProfiler->reset();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMenuBar_attachToCanvas(char * x__object, char * x__a2, char * x__a3)
{
MenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   object->attachToCanvas(dynamic_cast<GuiCanvas*>(Sim::findObject(argv[2])), dAtoi(argv[3]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMenuBar_removeFromCanvas(char * x__object)
{
MenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->removeFromCanvas();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMenuBar_insert(char * x__object, char * x__a2, char * x__a3)
{
MenuBar* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   SimObject* pObject = Sim::findObject(argv[2]);
   if(pObject)
      object->insertObject(pObject, dAtoi(argv[3]));
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPopupMenu_insertItem(char * x__object, char * x__a2, char * x__a3, char * x__a4)
{
PopupMenu* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
{
S32 argc = 5;
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
const char** argv = &arguments[0];
{
  return (S32)( object->insertItem(dAtoi(argv[2]), argc < 4 ? NULL : argv[3], argc < 5 ? "" : argv[4]));
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPopupMenu_removeItem(char * x__object, char * x__a2)
{
PopupMenu* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->removeItem(dAtoi(argv[2]));
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPopupMenu_insertSubMenu(char * x__object, char * x__a2, char * x__a3, char * x__a4)
{
PopupMenu* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
{
S32 argc = 5;
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
const char** argv = &arguments[0];
{
   PopupMenu *mnu = dynamic_cast<PopupMenu *>(Sim::findObject(argv[4]));
   if(mnu == NULL)
   {
      Con::errorf("PopupMenu::insertSubMenu - Invalid PopupMenu object specified for submenu");
     return (S32)( -1);
   }
  return (S32)( object->insertSubMenu(dAtoi(argv[2]), argv[3], mnu));
}
}
;
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPopupMenu_setItem(char * x__object, char * x__a2, char * x__a3, char * x__a4)
{
PopupMenu* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
bool wle_returnObject;
{
S32 argc = 5;
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
const char** argv = &arguments[0];
{
   {wle_returnObject =object->setItem(dAtoi(argv[2]), argv[3], argc < 5 ? "" : argv[4]);
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPopupMenu_enableItem(char * x__object, char * x__a2, char * x__a3)
{
PopupMenu* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   object->enableItem(dAtoi(argv[2]), dAtob(argv[3]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPopupMenu_checkItem(char * x__object, char * x__a2, char * x__a3)
{
PopupMenu* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   object->checkItem(dAtoi(argv[2]), dAtob(argv[3]));
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPopupMenu_checkRadioItem(char * x__object, char * x__a2, char * x__a3, char * x__a4)
{
PopupMenu* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
{
S32 argc = 5;
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
const char** argv = &arguments[0];
{
   object->checkRadioItem(dAtoi(argv[2]), dAtoi(argv[3]), dAtoi(argv[4]));
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPopupMenu_isItemChecked(char * x__object, char * x__a2)
{
PopupMenu* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
bool wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   {wle_returnObject =object->isItemChecked(dAtoi(argv[2]));
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPopupMenu_getItemCount(char * x__object)
{
PopupMenu* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
  return (S32)( object->getItemCount());
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPopupMenu_attachToMenuBar(char * x__object, char * x__a2, char * x__a3, char * x__a4)
{
PopupMenu* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
{
S32 argc = 5;
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
const char** argv = &arguments[0];
{
   object->attachToMenuBar(dynamic_cast<GuiCanvas*>(Sim::findObject(argv[2])),dAtoi(argv[3]), argv[4]);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPopupMenu_removeFromMenuBar(char * x__object)
{
PopupMenu* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->removeFromMenuBar();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPopupMenu_showPopup(char * x__object, char * x__a2, char * x__a3, char * x__a4)
{
PopupMenu* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
{
S32 argc = 5;
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
const char** argv = &arguments[0];
{
   GuiCanvas *pCanvas = dynamic_cast<GuiCanvas*>(Sim::findObject(argv[2]));
   S32 x = argc >= 4 ? dAtoi(argv[3]) : -1;
   S32 y = argc >= 5 ? dAtoi(argv[4]) : -1;
   object->showPopup(pCanvas, x, y);
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_messageBox(char * x__title, char * x__message, S32 x__buttons, S32 x__icons)
{
const char* title = (const char*)x__title;
const char* message = (const char*)x__message;
MBButtons buttons = (MBButtons)x__buttons;
MBIcons icons = (MBIcons)x__icons;
{
  return (S32)( Platform::messageBox( title, message, buttons, icons ));
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn__isJoystickEnabled()
{
bool wle_returnObject;
{
{
   
   {wle_returnObject =DInputManager::isJoystickEnabled();
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn__enableXInput()
{
bool wle_returnObject;
{
{
   // Although I said above that you couldn't change the "activation" of XInput,
   // you can enable and disable it. It gets enabled by default if you have the
   // DLL. You would want to disable it if you have 360 controllers and want to
   // read them as joysticks... why you'd want to do that is beyond me
   
   {wle_returnObject =( DInputManager::enableXInput() );
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn__isXInputConnected(char * x__a1)
{
const char* a1 = (const char*)x__a1;
bool wle_returnObject;
{
S32 argc = 2;
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
const char** argv = &arguments[0];
{
   
   DInputManager* mgr = dynamic_cast<DInputManager*>( Input::getManager() );
   if ( mgr && mgr->isEnabled() ) {wle_returnObject =mgr->isXInputConnected( atoi( argv[1] ) );
return (S32)(wle_returnObject);}
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn__getXInputState(char * x__a1, char * x__a2, char * x__a3)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   
   DInputManager* mgr = dynamic_cast<DInputManager*>( Input::getManager() );
   if ( !mgr || !mgr->isEnabled() ) 
     return (int)( -1);
   // Use a little bit of macro magic to simplify this otherwise monolothic
   // block of code.
#define GET_XI_STATE(constName) \
   if (!dStricmp(argv[2], #constName)) \
     return (int)( mgr->getXInputState( dAtoi( argv[1] ), constName, ( dAtoi ( argv[3] ) == 1) ));
   
   GET_XI_STATE(XI_THUMBLX);
   GET_XI_STATE(XI_THUMBLY);
   GET_XI_STATE(XI_THUMBRX);
   GET_XI_STATE(XI_THUMBRY);
   GET_XI_STATE(XI_LEFT_TRIGGER);
   GET_XI_STATE(XI_RIGHT_TRIGGER);
   GET_XI_STATE(SI_UPOV);
   GET_XI_STATE(SI_DPOV);
   GET_XI_STATE(SI_LPOV);
   GET_XI_STATE(SI_RPOV);
   GET_XI_STATE(XI_START);
   GET_XI_STATE(XI_BACK);
   GET_XI_STATE(XI_LEFT_THUMB);
   GET_XI_STATE(XI_RIGHT_THUMB);
   GET_XI_STATE(XI_LEFT_SHOULDER);
   GET_XI_STATE(XI_RIGHT_SHOULDER);
   GET_XI_STATE(XI_A);
   GET_XI_STATE(XI_B);
   GET_XI_STATE(XI_X);
   GET_XI_STATE(XI_Y);
#undef GET_XI_STATE
  return (int)( -1);
}
arguments.clear();
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__rumble(char * x__a1, char * x__a2, char * x__a3)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   DInputManager* mgr = dynamic_cast<DInputManager*>( Input::getManager() );
   if ( mgr && mgr->isEnabled() )
   {
      mgr->rumble(argv[1], dAtof(argv[2]), dAtof(argv[3]));
   }
   else
   {
      Con::printf( "DirectInput/XInput is not enabled." );
   }
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnFileDialog_Execute(char * x__object)
{
FileDialog* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->Execute();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__debug_debugbreak()
{
{
{
   Platform::debugBreak();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_dumpRandomNormalMap()
{
{
   GFXTexHandle tex;
   tex.set( 64, 64, GFXFormatR8G8B8A8, &GFXDefaultPersistentProfile, "" );
   GFXLockedRect *rect = tex.lock();
   U8 *f = rect->bits;
   for ( U32 i = 0; i < 64*64; i++, f += 4 )
   {               
      VectorF vec;
      vec.x = mRandF( -1.0f, 1.0f );
      vec.y = mRandF( -1.0f, 1.0f );
      vec.z = mRandF( -1.0f, 1.0f );
      vec.normalizeSafe();
      f[0] = U8_MAX * ( ( 1.0f + vec.x ) * 0.5f );
      f[1] = U8_MAX * ( ( 1.0f + vec.y ) * 0.5f );
      f[2] = U8_MAX * ( ( 1.0f + vec.z ) * 0.5f );
      f[3] = U8_MAX;
   }
   tex.unlock();
   String path = Torque::FS::MakeUniquePath( "", "randNormTex", "png" );
   tex->dumpToDisk( "png", path );   
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPostEffect_reload(char * x__object)
{
PostEffect* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   return object->reload();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPostEffect_enable(char * x__object)
{
PostEffect* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->enable();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPostEffect_disable(char * x__object)
{
PostEffect* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->disable();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPostEffect_toggle(char * x__object)
{
PostEffect* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   if ( object->isEnabled() )
      object->disable();
   else
      object->enable();
   {wle_returnObject =object->isEnabled();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPostEffect_isEnabled(char * x__object)
{
PostEffect* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isEnabled();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPostEffect_setTexture(char * x__object, S32 index, char * x__filePath)
{
PostEffect* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

const char* filePath = (const char*)x__filePath;
{   
	if ( index > -1 && index < PostEffect::NumTextures )
		object->setTexture( index, filePath );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPostEffect_setShaderConst(char * x__object, char * x__name, char * x__value)
{
PostEffect* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* name = (const char*)x__name;
const char* value = (const char*)x__value;
{
   object->setShaderConst( name, value );
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnPostEffect_getAspectRatio(char * x__object)
{
PostEffect* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getAspectRatio());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPostEffect_dumpShaderDisassembly(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
PostEffect* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
String wle_returnObject;
{
   String fileName;
   object->dumpShaderDisassembly( fileName );
   {wle_returnObject =fileName;   
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPostEffect_setShaderMacro(char * x__object, char * x__key, char * x__value)
{
PostEffect* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* key = (const char*)x__key;
const char* value = (const char*)x__value;
{   
   object->setShaderMacro( key, value );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPostEffect_removeShaderMacro(char * x__object, char * x__key)
{
PostEffect* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* key = (const char*)x__key;
{
   object->removeShaderMacro( key );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPostEffect_clearShaderMacros(char * x__object)
{
PostEffect* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->clearShaderMacros();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnRenderBinManager_getBinType(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
RenderBinManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->getRenderInstType().getName();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnRenderPassManager_getManagerCount(char * x__object)
{
RenderPassManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getManagerCount());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnRenderPassManager_getManager(char * x__object, S32 index,  char* retval)
{
dSprintf(retval,1024,"");
RenderPassManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
RenderBinManager* wle_returnObject;
{
   if(index < 0 || index >= object->getManagerCount())
      {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
   {wle_returnObject =object->getManager(index);
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnRenderPassManager_addManager(char * x__object, char * x__renderBin)
{
RenderPassManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
RenderBinManager* renderBin; Sim::findObject(x__renderBin, renderBin ); 
{
   if ( renderBin )
      object->addManager( renderBin );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnRenderPassManager_removeManager(char * x__object, char * x__renderBin)
{
RenderPassManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
RenderBinManager* renderBin; Sim::findObject(x__renderBin, renderBin ); 
{
   if ( renderBin )
      object->removeManager( renderBin );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnRenderPassStateToken_enable(char * x__object)
{
RenderPassStateToken* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->enable(true);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnRenderPassStateToken_disable(char * x__object)
{
RenderPassStateToken* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->enable(false);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnRenderPassStateToken_toggle(char * x__object)
{
RenderPassStateToken* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->enable(!object->isEnabled());
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__clearClientPaths()
{
{
{
   gClientPathManager->clearPaths();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_setReflectFormat(S32 x__format)
{
GFXFormat format = (GFXFormat)x__format;
{
   REFLECTMGR->setReflectFormat( format );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_containerBoxEmpty(U32 mask, char * x__center, F32 xRadius, F32 yRadius, F32 zRadius, bool useClientContainer)
{
Point3F center = Point3F();
sscanf(x__center,"%f %f %f", &center.x,&center.y,&center.z);


bool wle_returnObject;
{
   Point3F extent( xRadius, yRadius, zRadius );
   extent.y = extent.y >= 0 ? extent.y : extent.x;
   extent.z = extent.z >= 0 ? extent.z : extent.x;
   Box3F    B(center - extent, center + extent, true);
   EarlyOutPolyList polyList;
   polyList.mPlaneList.clear();
   polyList.mNormal.set(0,0,0);
   polyList.mPlaneList.setSize(6);
   polyList.mPlaneList[0].set(B.minExtents, VectorF(-1,0,0));
   polyList.mPlaneList[1].set(B.maxExtents, VectorF(0,1,0));
   polyList.mPlaneList[2].set(B.maxExtents, VectorF(1,0,0));
   polyList.mPlaneList[3].set(B.minExtents, VectorF(0,-1,0));
   polyList.mPlaneList[4].set(B.minExtents, VectorF(0,0,-1));
   polyList.mPlaneList[5].set(B.maxExtents, VectorF(0,0,1));
   SceneContainer* pContainer = useClientContainer ? &gClientContainer : &gServerContainer;
   {wle_returnObject =! pContainer->buildPolyList(PLC_Collision, B, mask, &polyList);
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_initContainerRadiusSearch(char * x__pos, F32 radius, U32 mask, bool useClientContainer)
{
Point3F pos = Point3F();
sscanf(x__pos,"%f %f %f", &pos.x,&pos.y,&pos.z);

{
   SceneContainer* pContainer = useClientContainer ? &gClientContainer : &gServerContainer;
   pContainer->initRadiusSearch( pos, radius, mask );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_initContainerTypeSearch(U32 mask, bool useClientContainer)
{

{
   SceneContainer* pContainer = useClientContainer ? &gClientContainer : &gServerContainer;
   pContainer->initTypeSearch( mask );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_containerSearchNext(bool useClientContainer,  char* retval)
{
dSprintf(retval,1024,"");
SceneObject* wle_returnObject;
{
   SceneContainer* pContainer = useClientContainer ? &gClientContainer : &gServerContainer;
   {wle_returnObject =pContainer->containerSearchNextObject();
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_containerSearchCurrDist(bool useClientContainer)
{
{
   SceneContainer* pContainer = useClientContainer ? &gClientContainer : &gServerContainer;
  return (F32)( pContainer->containerSearchCurrDist());
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_containerSearchCurrRadiusDist(bool useClientContainer)
{
{
   SceneContainer* pContainer = useClientContainer ? &gClientContainer : &gServerContainer;
  return (F32)( pContainer->containerSearchCurrRadiusDist());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_containerRayCast(char * x__start, char * x__end, U32 mask, char * x__pExempt, bool useClientContainer,  char* retval)
{
dSprintf(retval,4096,"");
Point3F start = Point3F();
sscanf(x__start,"%f %f %f", &start.x,&start.y,&start.z);
Point3F end = Point3F();
sscanf(x__end,"%f %f %f", &end.x,&end.y,&end.z);

SceneObject* pExempt; Sim::findObject(x__pExempt, pExempt ); 
const char* wle_returnObject;
{
   if (pExempt)
      pExempt->disableCollision();
   SceneContainer* pContainer = useClientContainer ? &gClientContainer : &gServerContainer;
   RayInfo rinfo;
   S32 ret = 0;
   if (pContainer->castRay(start, end, mask, &rinfo) == true)
      ret = rinfo.object->getId();
   if (pExempt)
      pExempt->enableCollision();
   // add the hit position and normal?
   char *returnBuffer = Con::getReturnBuffer(256);
   if(ret)
   {
      dSprintf(returnBuffer, 256, "%d %g %g %g %g %g %g %g",
               ret, rinfo.point.x, rinfo.point.y, rinfo.point.z,
               rinfo.normal.x, rinfo.normal.y, rinfo.normal.z, rinfo.distance);
   }
   else
   {
      returnBuffer[0] = '0';
      returnBuffer[1] = '\0';
   }
   {wle_returnObject =(returnBuffer);
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_sceneDumpZoneStates(bool updateFirst)
{
{
   if( !gClientSceneGraph )
   {
      Con::errorf( "sceneDumpZoneStates - Only valid on client!" );
      return;
   }
   SceneZoneSpaceManager* manager = gClientSceneGraph->getZoneManager();
   if( !manager )
   {
      Con::errorf( "sceneDumpZoneStates - Scene is not using zones!" );
      return;
   }
   manager->dumpZoneStates( updateFirst );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_sceneGetZoneOwner(U32 zoneId,  char* retval)
{
dSprintf(retval,1024,"");
SceneObject* wle_returnObject;
{
   if( !gClientSceneGraph )
   {
      Con::errorf( "sceneGetZoneOwner - Only valid on client!" );
      {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
   }
   SceneZoneSpaceManager* manager = gClientSceneGraph->getZoneManager();
   if( !manager )
   {
      Con::errorf( "sceneGetZoneOwner - Scene is not using zones!" );
      {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
   }
   if( !manager->isValidZoneId( zoneId ) )
   {
      Con::errorf( "sceneGetZoneOwner - Invalid zone ID: %i", zoneId );
      {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
   }
   {wle_returnObject =manager->getZoneOwner( zoneId );
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSceneObject_getType(char * x__object)
{
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getTypeMask());
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSceneObject_mountObject(char * x__object, char * x__objB, S32 slot, char * x__txfm)
{
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
SceneObject* objB; Sim::findObject(x__objB, objB ); 
TransformF txfm = TransformF();
sscanf( x__txfm,"%f %f %f %f %f %f %f", &txfm.mPosition.x, &txfm.mPosition.y, &txfm.mPosition.z, &txfm.mOrientation.axis.x, &txfm.mOrientation.axis.y, &txfm.mOrientation.axis.z, &txfm.mOrientation.angle);
bool wle_returnObject;
{
   if ( objB )
   {
      object->mountObject( objB, slot, txfm.getMatrix() );
      {wle_returnObject =true;
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSceneObject_unmountObject(char * x__object, char * x__target)
{
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
SceneObject* target; Sim::findObject(x__target, target ); 
bool wle_returnObject;
{
   if ( target )
   {
      object->unmountObject(target);
      {wle_returnObject =true;
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSceneObject_unmount(char * x__object)
{
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->unmount();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSceneObject_isMounted(char * x__object)
{
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isMounted();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSceneObject_getObjectMount(char * x__object)
{
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->isMounted()? object->getObjectMount()->getId(): 0);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSceneObject_getMountedObjectCount(char * x__object)
{
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getMountedObjectCount());
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSceneObject_getMountedObject(char * x__object, S32 slot)
{
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   SceneObject* mobj = object->getMountedObject( slot );
  return (S32)( mobj? mobj->getId(): 0);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSceneObject_getMountedObjectNode(char * x__object, S32 slot)
{
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getMountedObjectNode( slot ));
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSceneObject_getMountNodeObject(char * x__object, S32 node)
{
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   SceneObject* mobj = object->getMountNodeObject( node );
  return (S32)( mobj? mobj->getId(): 0);
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSceneObject_getTransform(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
TransformF wle_returnObject;
{
   {wle_returnObject =object->getTransform();
dSprintf(retval,1024,"%f %f %f %f %f %f %f ",wle_returnObject.mPosition.x,wle_returnObject.mPosition.y,wle_returnObject.mPosition.z,wle_returnObject.mOrientation.axis.x,wle_returnObject.mOrientation.axis.y,wle_returnObject.mOrientation.axis.z,wle_returnObject.mOrientation.angle);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSceneObject_getInverseTransform(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
TransformF wle_returnObject;
{
   {wle_returnObject =object->getWorldTransform();
dSprintf(retval,1024,"%f %f %f %f %f %f %f ",wle_returnObject.mPosition.x,wle_returnObject.mPosition.y,wle_returnObject.mPosition.z,wle_returnObject.mOrientation.axis.x,wle_returnObject.mOrientation.axis.y,wle_returnObject.mOrientation.axis.z,wle_returnObject.mOrientation.angle);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSceneObject_getPosition(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F wle_returnObject;
{
   {wle_returnObject =object->getTransform().getPosition();
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSceneObject_getEulerRotation(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F wle_returnObject;
{
   Point3F euler = object->getTransform().toEuler();
   
   // Convert to degrees.
   euler.x = mRadToDeg( euler.x );
   euler.y = mRadToDeg( euler.y );
   euler.z = mRadToDeg( euler.z );
   
   {wle_returnObject =euler;
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSceneObject_getForwardVector(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
VectorF wle_returnObject;
{
   {wle_returnObject =object->getTransform().getForwardVector();
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSceneObject_getRightVector(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
VectorF wle_returnObject;
{
   {wle_returnObject =object->getTransform().getRightVector();
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSceneObject_getUpVector(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
VectorF wle_returnObject;
{
   {wle_returnObject =object->getTransform().getUpVector();
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSceneObject_setTransform(char * x__object, char * x__txfm)
{
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
TransformF txfm = TransformF();
sscanf( x__txfm,"%f %f %f %f %f %f %f", &txfm.mPosition.x, &txfm.mPosition.y, &txfm.mPosition.z, &txfm.mOrientation.axis.x, &txfm.mOrientation.axis.y, &txfm.mOrientation.axis.z, &txfm.mOrientation.angle);
{
   if ( !txfm.hasRotation() )
      object->setPosition( txfm.getPosition() );
   else
      object->setTransform( txfm.getMatrix() );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSceneObject_getScale(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F wle_returnObject;
{
   {wle_returnObject =object->getScale();
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSceneObject_setScale(char * x__object, char * x__scale)
{
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F scale = Point3F();
sscanf(x__scale,"%f %f %f", &scale.x,&scale.y,&scale.z);
{
   object->setScale( scale );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSceneObject_getWorldBox(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Box3F wle_returnObject;
{
   {wle_returnObject =object->getWorldBox();
dSprintf(retval,1024,"%f %f %f %f %f %f ",wle_returnObject.minExtents.x,wle_returnObject.minExtents.y,wle_returnObject.minExtents.z,wle_returnObject.maxExtents.x,wle_returnObject.maxExtents.y,wle_returnObject.maxExtents.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSceneObject_getWorldBoxCenter(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F wle_returnObject;
{
   Point3F center;
   object->getWorldBox().getCenter( &center );
   {wle_returnObject =center;
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSceneObject_getObjectBox(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Box3F wle_returnObject;
{
   {wle_returnObject =object->getObjBox();
dSprintf(retval,1024,"%f %f %f %f %f %f ",wle_returnObject.minExtents.x,wle_returnObject.minExtents.y,wle_returnObject.minExtents.z,wle_returnObject.maxExtents.x,wle_returnObject.maxExtents.y,wle_returnObject.maxExtents.z);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSceneObject_isGlobalBounds(char * x__object)
{
SceneObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isGlobalBounds();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_pathOnMissionLoadDone()
{
{
   // Need to load subobjects for all loaded interiors...
   SimGroup* pMissionGroup = dynamic_cast<SimGroup*>(Sim::findObject("MissionGroup"));
   AssertFatal(pMissionGroup != NULL, "Error, mission done loading and no mission group?");
   U32 currStart = 0;
   U32 currEnd   = 1;
   Vector<SimGroup*> groups;
   groups.push_back(pMissionGroup);
   while (true) {
      for (U32 i = currStart; i < currEnd; i++) {
         for (SimGroup::iterator itr = groups[i]->begin(); itr != groups[i]->end(); itr++) {
            if (dynamic_cast<SimGroup*>(*itr) != NULL)
               groups.push_back(static_cast<SimGroup*>(*itr));
         }
      }
      if (groups.size() == currEnd) {
         break;
      } else {
         currStart = currEnd;
         currEnd   = groups.size();
      }
   }
   for (U32 i = 0; i < groups.size(); i++) {
      SimPath::Path* pPath = dynamic_cast<SimPath::Path*>(groups[i]);
      if (pPath)
         pPath->updatePath();
   }
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSFXController_getCurrentSlot(char * x__object)
{
SFXController* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getCurrentSlot());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSFXController_setCurrentSlot(char * x__object, S32 index)
{
SFXController* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setCurrentSlot( index );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSFXParameter_getParameterName(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
SFXParameter* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
String wle_returnObject;
{
   {wle_returnObject =object->getInternalName();
dSprintf(retval,4096,"%s",wle_returnObject.c_str());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSFXParameter_reset(char * x__object)
{
SFXParameter* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->reset();
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnSFXProfile_getSoundDuration(char * x__object)
{
SFXProfile* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( ( F32 ) object->getSoundDuration() * 0.001f);
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSFXSource_setTransform(char * x__object, char * x__a2, char * x__a3)
{
SFXSource* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   MatrixF mat = object->getTransform();
   Point3F pos;
   dSscanf( argv[2], "%g %g %g", &pos.x, &pos.y, &pos.z );
   mat.setPosition( pos );
   
   if( argc > 3 )
   {
      Point3F dir;
      dSscanf( argv[ 3 ], "%g %g %g", &dir.x, &dir.y, &dir.z );
      mat.setColumn( 1, dir );
   }
   
   object->setTransform( mat );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSFXSource_play(char * x__object, F32 fadeInTime)
{
SFXSource* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->play( fadeInTime );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSFXSource_stop(char * x__object, F32 fadeOutTime)
{
SFXSource* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->stop( fadeOutTime );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSFXSource_pause(char * x__object, F32 fadeOutTime)
{
SFXSource* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->pause( fadeOutTime );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSFXSource_isPlaying(char * x__object)
{
SFXSource* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isPlaying();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSFXSource_isPaused(char * x__object)
{
SFXSource* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isPaused();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSFXSource_isStopped(char * x__object)
{
SFXSource* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isStopped();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSFXSource_getStatus(char * x__object)
{
SFXSource* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
SFXStatus wle_returnObject;
{
   {wle_returnObject =object->getStatus();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnSFXSource_getVolume(char * x__object)
{
SFXSource* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getVolume());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSFXSource_setVolume(char * x__object, F32 volume)
{
SFXSource* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setVolume( volume );
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnSFXSource_getAttenuatedVolume(char * x__object)
{
SFXSource* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getAttenuatedVolume());
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnSFXSource_getFadeInTime(char * x__object)
{
SFXSource* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getFadeInTime());
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnSFXSource_getFadeOutTime(char * x__object)
{
SFXSource* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getFadeOutTime());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSFXSource_setFadeTimes(char * x__object, F32 fadeInTime, F32 fadeOutTime)
{
SFXSource* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->setFadeTimes( fadeInTime, fadeOutTime );
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnSFXSource_getPitch(char * x__object)
{
SFXSource* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getPitch());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSFXSource_setPitch(char * x__object, F32 pitch)
{
SFXSource* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setPitch( pitch );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSFXSource_setCone(char * x__object, F32 innerAngle, F32 outerAngle, F32 outsideVolume)
{
SFXSource* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   bool isValid = true;
   
   if( innerAngle < 0.0 || innerAngle > 360.0 )
   {
      Con::errorf( "SFXSource.setCone() - 'innerAngle' must be between 0 and 360" );
      isValid = false;
   }
   if( outerAngle < 0.0 || outerAngle > 360.0 )
   {
      Con::errorf( "SFXSource.setCone() - 'outerAngle' must be between 0 and 360" );
      isValid = false;
   }
   if( outsideVolume < 0.0 || outsideVolume > 1.0 )
   {
      Con::errorf( "SFXSource.setCone() - 'outsideVolume' must be between 0 and 1" );
      isValid = false;
   }
   
   if( !isValid )
      return;
      
   object->setCone( innerAngle, outerAngle, outsideVolume );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSFXSource_getParameterCount(char * x__object)
{
SFXSource* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getNumParameters());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSFXSource_addParameter(char * x__object, char * x__parameter)
{
SFXSource* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
SFXParameter* parameter; Sim::findObject(x__parameter, parameter ); 
{
   if( parameter )
      object->addParameter( parameter );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSFXSource_removeParameter(char * x__object, char * x__parameter)
{
SFXSource* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
SFXParameter* parameter; Sim::findObject(x__parameter, parameter ); 
{
   if( parameter )
      object->removeParameter( parameter );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSFXSource_getParameter(char * x__object, S32 index,  char* retval)
{
dSprintf(retval,1024,"");
SFXSource* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
SFXParameter* wle_returnObject;
{
   if( index >= object->getNumParameters() )
   {
      Con::errorf( "SFXSource::getParameter - index out of range: %i", index );
      {wle_returnObject =0;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
   }
   
   {wle_returnObject =object->getParameter( index );
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSFXSource_addMarker(char * x__object, char * x__name, F32 pos)
{
SFXSource* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
String name = String( x__name);
{
   object->addMarker( name, pos );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn__sfxCreateSource(char * x__a1, char * x__a2, char * x__a3, char * x__a4, char * x__a5)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
{
S32 argc = 6;
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
if (argc>=5)
arguments.push_back(a4);
if (argc>=6)
arguments.push_back(a5);
const char** argv = &arguments[0];
{
   SFXDescription* description = NULL;
   SFXTrack* track = dynamic_cast< SFXTrack* >( Sim::findObject( argv[1] ) );
   if ( !track )
   {
      description = dynamic_cast< SFXDescription* >( Sim::findObject( argv[1] ) );
      if ( !description )
      {
         Con::printf( "Unable to locate sound track/description '%s'", argv[1] );
        return (S32)( 0);
      }
   }
   SFXSource* source = NULL;
   if ( track )
   {
      if ( argc == 2 )
      {
         source = SFX->createSource( track );
      }
      else
      {
         MatrixF transform;
         transform.set( EulerF(0,0,0), Point3F( dAtof(argv[2]), dAtof(argv[3]), dAtof(argv[4])) );
         source = SFX->createSource( track, &transform );
      }
   }
   else if ( description )
   {
      SFXProfile* tempProfile = new SFXProfile( description, StringTable->insert( argv[2] ), true );
      if( !tempProfile->registerObject() )
      {
         Con::errorf( "sfxCreateSource - unable to create profile" );
         delete tempProfile;
      }
      else
      {
         if ( argc == 3 )
         {
            source = SFX->createSource( tempProfile );
         }
         else
         {
            MatrixF transform;
            transform.set(EulerF(0,0,0), Point3F( dAtof(argv[3]),dAtof(argv[4]),dAtof(argv[5]) ));
            source = SFX->createSource( tempProfile, &transform );
         }
         tempProfile->setAutoDelete( true );
      }
   }
   if ( source )
     return (S32)( source->getId());
  return (S32)( 0);
}
arguments.clear();
}
;
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn__sfxPlay(char * x__a1, char * x__a2, char * x__a3, char * x__a4)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
{
S32 argc = 5;
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
if (argc>=5)
arguments.push_back(a4);
const char** argv = &arguments[0];
{
   if ( argc == 2 )
   {
      SFXSource* source = dynamic_cast<SFXSource*>( Sim::findObject( argv[1] ) );
      if ( source )
      {
         source->play();
        return (S32)( source->getId());
      }
   }
   SFXTrack* track = dynamic_cast<SFXTrack*>( Sim::findObject( argv[1] ) );
   if ( !track )
   {
      Con::printf( "Unable to locate sfx track '%s'", argv[1] );
     return (S32)( 0);
   }
   Point3F pos(0.f, 0.f, 0.f);
   if ( argc == 3 )
      dSscanf( argv[2], "%g %g %g", &pos.x, &pos.y, &pos.z );
   else if(argc == 5)
      pos.set( dAtof(argv[2]), dAtof(argv[3]), dAtof(argv[4]) );
   MatrixF transform;
   transform.set( EulerF(0,0,0), pos );
   SFXSource* source = SFX->playOnce( track, &transform );
   if ( source )
     return (S32)( source->getId());
  return (S32)( 0);
}
arguments.clear();
}
;
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn__sfxPlayOnce(char * x__a1, char * x__a2, char * x__a3, char * x__a4, char * x__a5)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
{
S32 argc = 6;
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
if (argc>=5)
arguments.push_back(a4);
if (argc>=6)
arguments.push_back(a5);
const char** argv = &arguments[0];
{
   SFXDescription* description = NULL;
   SFXTrack* track = dynamic_cast< SFXTrack* >( Sim::findObject( argv[1] ) );
   if( !track )
   {
      description = dynamic_cast< SFXDescription* >( Sim::findObject( argv[1] ) );
      if( !description )
      {
         Con::errorf( "sfxPlayOnce - Unable to locate sound track/description '%s'", argv[1] );
        return (S32)( 0);
      }
   }
   SFXSource* source = NULL;
   if( track )
   {
      if( argc == 2 )
         source = SFX->playOnce( track );
      else
      {
         MatrixF transform;
         transform.set( EulerF( 0, 0, 0 ), Point3F( dAtof( argv[ 2 ] ), dAtof( argv[ 3 ] ),dAtof( argv[ 4 ] ) ) );
         F32 fadeInTime = -1.f;
         if( argc > 5 )
            fadeInTime = dAtof( argv[ 5 ] );
         source = SFX->playOnce( track, &transform, NULL, fadeInTime );
      }
   }
   else if( description )
   {
      SFXProfile* tempProfile = new SFXProfile( description, StringTable->insert( argv[2] ), true );
      if( !tempProfile->registerObject() )
      {
         Con::errorf( "sfxPlayOnce - unable to create profile" );
         delete tempProfile;
      }
      else
      {
         if ( argc == 3 )
            source = SFX->playOnce( tempProfile );
         else
         {
            MatrixF transform;
            transform.set(EulerF(0,0,0), Point3F( dAtof(argv[3]),dAtof(argv[4]),dAtof(argv[5]) ));
            F32 fadeInTime = -1.f;
            if( argc > 6 )
               fadeInTime = dAtof( argv[ 6 ] );
            source = SFX->playOnce( tempProfile, &transform, NULL, fadeInTime );
         }
         
         // Set profile to auto-delete when SFXSource releases its reference.
         // Also add to root group so the profile will get deleted when the
         // Sim system is shut down before the SFXSource has played out.
         tempProfile->setAutoDelete( true );
         Sim::getRootGroup()->addObject( tempProfile );
      }
   }
   if( !source )
     return (S32)( 0);
      
  return (S32)( source->getId());
}
arguments.clear();
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_sfxGetAvailableDevices(char* retval)
{
dSprintf(retval,4096,"");
const char* wle_returnObject;
{
   char* deviceList = Con::getReturnBuffer( 2048 );
   deviceList[0] = 0;
   SFXProvider* provider = SFXProvider::getFirstProvider();
   while ( provider )
   {
      // List the devices in this provider.
      const SFXDeviceInfoVector& deviceInfo = provider->getDeviceInfo();
      for ( S32 d=0; d < deviceInfo.size(); d++ )
      {
         const SFXDeviceInfo* info = deviceInfo[d];
         dStrcat( deviceList, provider->getName() );
         dStrcat( deviceList, "\t" );
         dStrcat( deviceList, info->name );
         dStrcat( deviceList, "\t" );
         dStrcat( deviceList, info->hasHardware ? "1" : "0" );
         dStrcat( deviceList, "\t" );
         dStrcat( deviceList, Con::getIntArg( info->maxBuffers ) );         
         dStrcat( deviceList, "\n" );
         
         //TODO: caps
      }
      provider = provider->getNextProvider();
   }
   {wle_returnObject =deviceList;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_sfxCreateDevice(char * x__provider, char * x__device, bool useHardware, S32 maxBuffers)
{
const char* provider = (const char*)x__provider;
const char* device = (const char*)x__device;

bool wle_returnObject;
{
   {wle_returnObject =SFX->createDevice( provider, device, useHardware, maxBuffers, true );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_sfxDeleteDevice()
{
{
   SFX->deleteDevice();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_sfxGetDeviceInfo(char* retval)
{
dSprintf(retval,4096,"");
const char* wle_returnObject;
{
   String deviceInfo = SFX->getDeviceInfoString();
   if( deviceInfo.isEmpty() )
      {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
      
   {wle_returnObject =Con::getReturnBuffer( deviceInfo );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_sfxStop(char * x__source)
{
SFXSource* source; Sim::findObject(x__source, source ); 
{
   if( source )
      source->stop();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_sfxStopAndDelete(char * x__source)
{
SFXSource* source; Sim::findObject(x__source, source ); 
{
   if( source )
      SFX->stopAndDeleteSource( source );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_sfxDeleteWhenStopped(char * x__source)
{
SFXSource* source; Sim::findObject(x__source, source ); 
{
   if( source )
      SFX->deleteWhenStopped( source );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn_sfxGetDistanceModel()
{
SFXDistanceModel wle_returnObject;
{
   {wle_returnObject =SFX->getDistanceModel();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_sfxSetDistanceModel(S32 x__model)
{
SFXDistanceModel model = (SFXDistanceModel)x__model;
{
   SFX->setDistanceModel( model );
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_sfxGetDopplerFactor()
{
{
  return (F32)( SFX->getDopplerFactor());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_sfxSetDopplerFactor(F32 value)
{
{
   if( value < 0.0f )
   {
      Con::errorf( "sfxSetDopplerFactor - factor must be >0" );
      return;
   }
   SFX->setDopplerFactor( value );
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_sfxGetRolloffFactor()
{
{
  return (F32)( SFX->getRolloffFactor());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_sfxSetRolloffFactor(F32 value)
{
{
   if( value <= 0.0f )
   {
      Con::errorf( "sfxSetRolloffFactor - factor must be >0" );
      return;
   }
   SFX->setRolloffFactor( value );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_sfxDumpSources(bool includeGroups)
{
{
   SFX->dumpSources( NULL, !includeGroups );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_sfxDumpSourcesToString(bool includeGroups,  char* retval)
{
dSprintf(retval,4096,"");
const char* wle_returnObject;
{
   StringBuilder str;
   SFX->dumpSources( &str, !includeGroups );
   
   {wle_returnObject =Con::getReturnBuffer( str );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnActionMap_bind(char * x__object, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9)
{
ActionMap* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
bool wle_returnObject;
{
S32 argc = 10;
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
if (argc>5)
arguments.push_back(a5);
if (argc>6)
arguments.push_back(a6);
if (argc>7)
arguments.push_back(a7);
if (argc>8)
arguments.push_back(a8);
if (argc>9)
arguments.push_back(a9);
const char** argv = &arguments[0];
{
   {wle_returnObject =object->processBind( argc - 2, argv + 2, NULL );
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnActionMap_bindObj(char * x__object, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10)
{
ActionMap* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
bool wle_returnObject;
{
S32 argc = 11;
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
if (argc>5)
arguments.push_back(a5);
if (argc>6)
arguments.push_back(a6);
if (argc>7)
arguments.push_back(a7);
if (argc>8)
arguments.push_back(a8);
if (argc>9)
arguments.push_back(a9);
if (argc>10)
arguments.push_back(a10);
const char** argv = &arguments[0];
{
    SimObject* simObject = Sim::findObject(argv[argc - 1]);
    if ( simObject == NULL )
    {
        Con::warnf("ActionMap::bindObj() - Cannot bind, specified object was not found!");
        {wle_returnObject =false;
return (S32)(wle_returnObject);}
    }
    {wle_returnObject =object->processBind( argc - 3, argv + 2, simObject );
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getCurrentActionMap(char* retval)
{
dSprintf(retval,1024,"");
ActionMap* wle_returnObject;
{
   SimSet* pActionMapSet = Sim::getActiveActionMapSet();
   {wle_returnObject =dynamic_cast< ActionMap* >( pActionMapSet->last() );
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnActionMap_bindCmd(char * x__object, char * x__device, char * x__action, char * x__makeCmd, char * x__breakCmd)
{
ActionMap* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* device = (const char*)x__device;
const char* action = (const char*)x__action;
const char* makeCmd = (const char*)x__makeCmd;
const char* breakCmd = (const char*)x__breakCmd;
bool wle_returnObject;
{
   {wle_returnObject =object->processBindCmd( device, action, makeCmd, breakCmd );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnActionMap_unbind(char * x__object, char * x__device, char * x__action)
{
ActionMap* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* device = (const char*)x__device;
const char* action = (const char*)x__action;
bool wle_returnObject;
{
   {wle_returnObject =object->processUnbind( device, action );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnActionMap_unbindObj(char * x__object, char * x__device, char * x__action, char * x__obj)
{
ActionMap* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* device = (const char*)x__device;
const char* action = (const char*)x__action;
const char* obj = (const char*)x__obj;
bool wle_returnObject;
{
    SimObject* simObject = Sim::findObject(obj);
    if ( simObject == NULL )
    {
        Con::warnf("ActionMap::unbindObj() - Cannot unbind, specified object was not found!");
        {wle_returnObject =false;
return (S32)(wle_returnObject);}
    }
    {wle_returnObject =object->processUnbind( device, action, simObject );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnActionMap_save(char * x__object, char * x__fileName, bool append)
{
ActionMap* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* fileName = (const char*)x__fileName;

{
   char buffer[1024];
   if(fileName)
   {
      if(Con::expandScriptFilename(buffer, sizeof(buffer), fileName))
         fileName = buffer;
   }
   object->dumpActionMap( fileName, append );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnActionMap_push(char * x__object)
{
ActionMap* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   SimSet* pActionMapSet = Sim::getActiveActionMapSet();
   pActionMapSet->pushObject( object );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnActionMap_pop(char * x__object)
{
ActionMap* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   SimSet* pActionMapSet = Sim::getActiveActionMapSet();
   pActionMapSet->removeObject( object );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnActionMap_getBinding(char * x__object, char * x__command,  char* retval)
{
dSprintf(retval,4096,"");
ActionMap* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* command = (const char*)x__command;
const char* wle_returnObject;
{
	{wle_returnObject =object->getBinding( command );	
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnActionMap_getCommand(char * x__object, char * x__device, char * x__action,  char* retval)
{
dSprintf(retval,4096,"");
ActionMap* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* device = (const char*)x__device;
const char* action = (const char*)x__action;
const char* wle_returnObject;
{
	{wle_returnObject =object->getCommand( device, action );	
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnActionMap_isInverted(char * x__object, char * x__device, char * x__action)
{
ActionMap* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* device = (const char*)x__device;
const char* action = (const char*)x__action;
bool wle_returnObject;
{
	{wle_returnObject =object->isInverted( device, action );	
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnActionMap_getScale(char * x__object, char * x__device, char * x__action)
{
ActionMap* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* device = (const char*)x__device;
const char* action = (const char*)x__action;
{
	return object->getScale( device, action );	
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnActionMap_getDeadZone(char * x__object, char * x__device, char * x__action,  char* retval)
{
dSprintf(retval,4096,"");
ActionMap* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* device = (const char*)x__device;
const char* action = (const char*)x__action;
const char* wle_returnObject;
{
	{wle_returnObject =object->getDeadZone( device, action );	
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnNetConnection_transmitPaths(char * x__object)
{
NetConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   gServerPathManager->transmitPaths(object);
   object->setMissionPathsSent(true);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnNetConnection_clearPaths(char * x__object)
{
NetConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setMissionPathsSent(false);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnNetConnection_getAddress(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
NetConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char * wle_returnObject;
{
   if(object->isLocalConnection())
      {wle_returnObject ="local";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   char *buffer = Con::getReturnBuffer(256);
   Net::addressToString(object->getNetAddress(), buffer);
   {wle_returnObject =buffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnNetConnection_setSimulatedNetParams(char * x__object, F32 packetLoss, S32 delay)
{
NetConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->setSimulatedNetParams(packetLoss, delay);
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnNetConnection_getPing(char * x__object)
{
NetConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)(( S32( object->getRoundTripTime() ) ));
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnNetConnection_getPacketLoss(char * x__object)
{
NetConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)(( S32( 100 * object->getPacketLoss() ) ));
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnNetConnection_checkMaxRate(char * x__object)
{
NetConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->checkMaxRate();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnNetConnection_resolveGhostID(char * x__object, S32 ghostID)
{
NetConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   // Safety check
   if(ghostID < 0 || ghostID > NetConnection::MaxGhostCount)return (S32)( 0);
   NetObject *foo = object->resolveGhost(ghostID);
   if(foo)
     return (S32)( foo->getId());
   else
     return (S32)( 0);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnNetConnection_resolveObjectFromGhostIndex(char * x__object, S32 ghostID)
{
NetConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   // Safety check
   if(ghostID < 0 || ghostID > NetConnection::MaxGhostCount)return (S32)( 0);
   NetObject *foo = object->resolveObjectFromGhostIndex(ghostID);
   if(foo)
     return (S32)( foo->getId());
   else
     return (S32)( 0);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnNetConnection_getGhostID(char * x__object, S32 realID)
{
NetConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   NetObject * foo;
   if(Sim::findObject(realID, foo))
   {
     return (S32)( object->getGhostIndex(foo));
   }
   else
   {
      Con::errorf("NetConnection::serverToGhostID - could not find specified object");
     return (S32)( -1);
   }
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnNetConnection_connect(char * x__object, char * x__remoteAddress)
{
NetConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* remoteAddress = (const char*)x__remoteAddress;
{
   NetAddress addr;
   if(!Net::stringToAddress(remoteAddress, &addr))
   {
      Con::errorf("NetConnection::connect: invalid address - %s", remoteAddress);
      return;
   }
   object->connect(&addr);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnNetConnection_connectLocal(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
NetConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   ConsoleObject *co = ConsoleObject::create(object->getClassName());
   NetConnection *client = object;
   NetConnection *server = dynamic_cast<NetConnection *>(co);
   BitStream *stream = BitStream::getPacketStream();
   if(!server || !server->canRemoteCreate())
   {
      delete co;
      {wle_returnObject ="error";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   }
      
   server->registerObject();
   server->setIsLocalClientConnection();
   server->setSequence(0);
   client->setSequence(0);
   client->setRemoteConnectionObject(server);
   server->setRemoteConnectionObject(client);
   //We need to reset the maxrate's here, because we
   // can't test if it is a local connection until RemoteConnectionObject
   // has been set
   server->checkMaxRate();  
   client->checkMaxRate();
   stream->setPosition(0);
   client->writeConnectRequest(stream);
   stream->setPosition(0);
   
   const char* error;
   if( !server->readConnectRequest( stream, &error ) )
   {
      client->onConnectionRejected( error );
      server->deleteObject();
      {wle_returnObject ="error";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   }
   stream->setPosition(0);
   server->writeConnectAccept(stream);
   stream->setPosition(0);
   if( !client->readConnectAccept( stream, &error ) )
   {
      client->handleStartupError( error );
      server->deleteObject();
      {wle_returnObject ="error";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   }
   client->onConnectionEstablished(true);
   server->onConnectionEstablished(false);
   client->setEstablished();
   server->setEstablished();
   client->setConnectSequence(0);
   server->setConnectSequence(0);
   NetConnection::setLocalClientConnection(server);
   server->assignName("LocalClientConnection");
   
   {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnNetConnection_getGhostsActive(char * x__object)
{
NetConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
	return object->getGhostsActive();
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnNetObject_scopeToClient(char * x__object, char * x__client)
{
NetObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
NetConnection* client; Sim::findObject(x__client, client ); 
{
	if(!client)
	{
		Con::errorf(ConsoleLogEntry::General, "NetObject::scopeToClient: Couldn't find connection %s", client);
		return;
	}
	client->objectLocalScopeAlways(object);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnNetObject_clearScopeToClient(char * x__object, char * x__client)
{
NetObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
NetConnection* client; Sim::findObject(x__client, client ); 
{
   if(!client)
   {
      Con::errorf(ConsoleLogEntry::General, "NetObject::clearScopeToClient: Couldn't find connection %s", client);
      return;
   }
   client->objectLocalClearAlways(object);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnNetObject_setScopeAlways(char * x__object)
{
NetObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->setScopeAlways();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnNetObject_getGhostID(char * x__object)
{
NetObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
	return object->getNetIndex();
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnNetObject_getClientObject(char * x__object)
{
NetObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
	NetObject *obj = object->getClientObject();
	if ( obj )
		return obj->getId();
	
	return NULL;
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnNetObject_getServerObject(char * x__object)
{
NetObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
	NetObject *obj = object->getServerObject();
	if ( obj )
		return obj->getId();
	
	return NULL;
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnNetObject_isClientObject(char * x__object)
{
NetObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
	{wle_returnObject =object->isClientObject();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnNetObject_isServerObject(char * x__object)
{
NetObject* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
	{wle_returnObject =object->isServerObject();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn__aiAddPlayer(char * x__a1, char * x__a2)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   // Create the player
   AIClient *aiPlayer = new AIClient();
   aiPlayer->registerObject();
   aiPlayer->setGhostFrom(false);
   aiPlayer->setGhostTo(false);
   aiPlayer->setSendingEvents(false);
   aiPlayer->setTranslatesStrings(true);
   aiPlayer->setEstablished();
   
   // Add the connection to the client group
   SimGroup *g = Sim::getClientGroup();
   g->addObject( aiPlayer );
   char *name = new char[ dStrlen( argv[1] ) + 1];
   char *ns = new char[ dStrlen( argv[2] ) + 1];
   dStrcpy( name, argv[1] );
   dStrcpy( ns, argv[2] );
   // Execute the connect console function, this is the same 
   // onConnect function invoked for normal client connections
   Con::executef( aiPlayer, "onConnect", name );
   // Now execute the onAdd command and feed it the namespace
   if( argc > 2 )
      aiPlayer->onAdd( ns );
   else
      aiPlayer->onAdd( "AIClient" );
  return (S32)( aiPlayer->getId());
}
arguments.clear();
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIClient_setMoveSpeed(char * x__object, char * x__a2)
{
AIClient* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   AIClient *ai = static_cast<AIClient *>( object );
   ai->setMoveSpeed( dAtof( argv[2] ) );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIClient_stop(char * x__object)
{
AIClient* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   AIClient *ai = static_cast<AIClient *>( object );
   ai->setMoveMode( AIClient::ModeStop );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIClient_setAimLocation(char * x__object, char * x__a2)
{
AIClient* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   AIClient *ai = static_cast<AIClient *>( object );
   Point3F v( 0.0f,0.0f,0.0f );
   dSscanf( argv[2], "%f %f %f", &v.x, &v.y, &v.z );
   ai->setAimLocation( v );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIClient_setMoveDestination(char * x__object, char * x__a2)
{
AIClient* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   AIClient *ai = static_cast<AIClient *>( object );
   Point3F v( 0.0f, 0.0f, 0.0f );
   dSscanf( argv[2], "%f %f", &v.x, &v.y );
   ai->setMoveDestination( v );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIClient_getAimLocation(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
AIClient* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char * wle_returnObject;
{
{
   AIClient *ai = static_cast<AIClient *>( object );
   Point3F aimPoint = ai->getAimLocation();
   char *returnBuffer = Con::getReturnBuffer( 256 );
   dSprintf( returnBuffer, 256, "%f %f %f", aimPoint.x, aimPoint.y, aimPoint.z );
   {wle_returnObject =returnBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIClient_getMoveDestination(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
AIClient* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char * wle_returnObject;
{
{
   AIClient *ai = static_cast<AIClient *>( object );
   Point3F movePoint = ai->getMoveDestination();
   char *returnBuffer = Con::getReturnBuffer( 256 );
   dSprintf( returnBuffer, 256, "%f %f %f", movePoint.x, movePoint.y, movePoint.z );
   {wle_returnObject =returnBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIClient_setTargetObject(char * x__object, char * x__a2)
{
AIClient* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   AIClient *ai = static_cast<AIClient *>( object );
   
   // Find the target
   ShapeBase *targetObject;
   if( Sim::findObject( argv[2], targetObject ) )
      ai->setTargetObject( targetObject );
   else
      ai->setTargetObject( NULL );
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnAIClient_getTargetObject(char * x__object)
{
AIClient* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
   AIClient *ai = static_cast<AIClient *>( object );
  return (S32)( ai->getTargetObject());
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIClient_missionCycleCleanup(char * x__object)
{
AIClient* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   AIClient *ai = static_cast<AIClient*>( object );
   ai->missionCycleCleanup();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIClient_move(char * x__object)
{
AIClient* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   AIClient *ai = static_cast<AIClient *>( object );
   ai->setMoveMode( AIClient::ModeMove );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIClient_getLocation(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
AIClient* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char * wle_returnObject;
{
{
   AIClient *ai = static_cast<AIClient *>( object );
   Point3F locPoint = ai->getLocation();
   char *returnBuffer = Con::getReturnBuffer( 256 );
   dSprintf( returnBuffer, 256, "%f %f %f", locPoint.x, locPoint.y, locPoint.z );
   {wle_returnObject =returnBuffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIClient_moveForward(char * x__object)
{
AIClient* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   
   AIClient *ai = static_cast<AIClient *>( object );
   ShapeBase *player = dynamic_cast<ShapeBase*>(ai->getControlObject());
   Point3F location;
   MatrixF const &myTransform = player->getTransform();
   myTransform.getColumn( 3, &location );
   location.y += 100.0f;
   
   ai->setMoveDestination( location );
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn__aiConnect(char * x__a1, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10, char * x__a11, char * x__a12, char * x__a13, char * x__a14, char * x__a15, char * x__a16, char * x__a17, char * x__a18, char * x__a19)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* a11 = (const char*)x__a11;
const char* a12 = (const char*)x__a12;
const char* a13 = (const char*)x__a13;
const char* a14 = (const char*)x__a14;
const char* a15 = (const char*)x__a15;
const char* a16 = (const char*)x__a16;
const char* a17 = (const char*)x__a17;
const char* a18 = (const char*)x__a18;
const char* a19 = (const char*)x__a19;
{
S32 argc = 20;
if (dStrlen(a19)==0)
if (dStrlen(a18)==0)
if (dStrlen(a17)==0)
if (dStrlen(a16)==0)
if (dStrlen(a15)==0)
if (dStrlen(a14)==0)
if (dStrlen(a13)==0)
if (dStrlen(a12)==0)
if (dStrlen(a11)==0)
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
else
argc=12;
else
argc=13;
else
argc=14;
else
argc=15;
else
argc=16;
else
argc=17;
else
argc=18;
else
argc=19;
else
argc=20;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
if (argc>=5)
arguments.push_back(a4);
if (argc>=6)
arguments.push_back(a5);
if (argc>=7)
arguments.push_back(a6);
if (argc>=8)
arguments.push_back(a7);
if (argc>=9)
arguments.push_back(a8);
if (argc>=10)
arguments.push_back(a9);
if (argc>=11)
arguments.push_back(a10);
if (argc>=12)
arguments.push_back(a11);
if (argc>=13)
arguments.push_back(a12);
if (argc>=14)
arguments.push_back(a13);
if (argc>=15)
arguments.push_back(a14);
if (argc>=16)
arguments.push_back(a15);
if (argc>=17)
arguments.push_back(a16);
if (argc>=18)
arguments.push_back(a17);
if (argc>=19)
arguments.push_back(a18);
if (argc>=20)
arguments.push_back(a19);
const char** argv = &arguments[0];
{
   // Create the connection
   AIConnection *aiConnection = new AIConnection();
   aiConnection->registerObject();
   // Add the connection to the client group
   SimGroup *g = Sim::getClientGroup();
   g->addObject( aiConnection );
   // Prep the arguments for the console exec...
   // Make sure and leav args[1] empty.
   const char* args[21];
   args[0] = "onConnect";
   for (S32 i = 1; i < argc; i++)
      args[i + 1] = argv[i];
   // Execute the connect console function, this is the same
   // onConnect function invoked for normal client connections
   Con::execute(aiConnection, argc + 1, args);
  return (S32)( aiConnection->getId());
}
arguments.clear();
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIConnection_setMove(char * x__object, char * x__a2, char * x__a3)
{
AIConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   Move move = object->getMove();
   // Ok, a little slow for now, but this is just an example..
   if (!dStricmp(argv[2],"x"))
      move.x = mClampF(dAtof(argv[3]),-1,1);
      else
   if (!dStricmp(argv[2],"y"))
      move.y = mClampF(dAtof(argv[3]),-1,1);
      else
   if (!dStricmp(argv[2],"z"))
      move.z = mClampF(dAtof(argv[3]),-1,1);
      else
   if (!dStricmp(argv[2],"yaw"))
      move.yaw = moveClamp(dAtof(argv[3]));
      else
   if (!dStricmp(argv[2],"pitch"))
      move.pitch = moveClamp(dAtof(argv[3]));
      else
   if (!dStricmp(argv[2],"roll"))
      move.roll = moveClamp(dAtof(argv[3]));
   //
   object->setMove(&move);
}
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnAIConnection_getMove(char * x__object, char * x__a2)
{
AIConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   const Move& move = object->getMove();
   if (!dStricmp(argv[2],"x"))
     return (F32)( move.x);
   if (!dStricmp(argv[2],"y"))
     return (F32)( move.y);
   if (!dStricmp(argv[2],"z"))
     return (F32)( move.z);
   if (!dStricmp(argv[2],"yaw"))
     return (F32)( move.yaw);
   if (!dStricmp(argv[2],"pitch"))
     return (F32)( move.pitch);
   if (!dStricmp(argv[2],"roll"))
     return (F32)( move.roll);
  return (F32)( 0);
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIConnection_setFreeLook(char * x__object, char * x__a2)
{
AIConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   Move move = object->getMove();
   move.freeLook = dAtob(argv[2]);
   object->setMove(&move);
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnAIConnection_getFreeLook(char * x__object)
{
AIConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
{
   {wle_returnObject =object->getMove().freeLook;
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIConnection_setTrigger(char * x__object, char * x__a2, char * x__a3)
{
AIConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   S32 idx = dAtoi(argv[2]);
   if (idx >= 0 && idx < MaxTriggerKeys)  {
      Move move = object->getMove();
      move.trigger[idx] = dAtob(argv[3]);
      object->setMove(&move);
   }
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnAIConnection_getTrigger(char * x__object, char * x__a2, char * x__a3)
{
AIConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
bool wle_returnObject;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   S32 idx = dAtoi(argv[2]);
   if (idx >= 0 && idx < MaxTriggerKeys)
      {wle_returnObject =object->getMove().trigger[idx];
return (S32)(wle_returnObject);}
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIConnection_getAddress(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
AIConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
{
   // Override the netConnection method to return to indicate
   // this is an ai connection.
   {wle_returnObject ="ai:local";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIPlayer_setAimObject(char * x__object, char * x__a2, char * x__a3)
{
AIPlayer* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   Point3F off( 0.0f, 0.0f, 0.0f );
   // Find the target
   GameBase *targetObject;
   if( Sim::findObject( argv[2], targetObject ) )
   {
      if (argc == 4)
         dSscanf( argv[3], "%g %g %g", &off.x, &off.y, &off.z );
      object->setAimObject( targetObject, off );
   }
   else
      object->setAimObject( 0, off );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIPlayer_stop(char * x__object)
{
AIPlayer* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->stopMove();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIPlayer_clearAim(char * x__object)
{
AIPlayer* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->clearAim();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIPlayer_setMoveSpeed(char * x__object, F32 speed)
{
AIPlayer* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->setMoveSpeed(speed);
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnAIPlayer_getMoveSpeed(char * x__object)
{
AIPlayer* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getMoveSpeed());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIPlayer_setMoveDestination(char * x__object, char * x__goal, bool slowDown)
{
AIPlayer* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F goal = Point3F();
sscanf(x__goal,"%f %f %f", &goal.x,&goal.y,&goal.z);
{
   object->setMoveDestination( goal, slowDown);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIPlayer_getMoveDestination(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
AIPlayer* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F wle_returnObject;
{
	{wle_returnObject =object->getMoveDestination();
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIPlayer_setAimLocation(char * x__object, char * x__target)
{
AIPlayer* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F target = Point3F();
sscanf(x__target,"%f %f %f", &target.x,&target.y,&target.z);
{
	object->setAimLocation(target);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAIPlayer_getAimLocation(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
AIPlayer* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F wle_returnObject;
{
	{wle_returnObject =object->getAimLocation();
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnAIPlayer_getAimObject(char * x__object)
{
AIPlayer* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
	GameBase* obj = object->getAimObject();
  return (S32)( obj? obj->getId(): -1);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnCamera_getMode(char * x__object)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
Camera::CameraMotionMode wle_returnObject;
{
   {wle_returnObject =object->getMode();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_getPosition(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F wle_returnObject;
{
   {wle_returnObject =object->getPosition();
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_getRotation(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F wle_returnObject;
{
   {wle_returnObject =object->getRotation();
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_setRotation(char * x__object, char * x__rot)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F rot = Point3F();
sscanf(x__rot,"%f %f %f", &rot.x,&rot.y,&rot.z);
{
   return object->setRotation( rot );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_getOffset(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F wle_returnObject;
{
   {wle_returnObject =object->getOffset();
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_setOffset(char * x__object, char * x__offset)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F offset = Point3F();
sscanf(x__offset,"%f %f %f", &offset.x,&offset.y,&offset.z);
{
   object->setOffset(offset);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_setOrbitMode(char * x__object, char * x__orbitObject, char * x__orbitPoint, F32 minDistance, F32 maxDistance, F32 initDistance, bool ownClientObj, char * x__offset, bool locked)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
GameBase* orbitObject; Sim::findObject(x__orbitObject, orbitObject ); 
TransformF orbitPoint = TransformF();
sscanf( x__orbitPoint,"%f %f %f %f %f %f %f", &orbitPoint.mPosition.x, &orbitPoint.mPosition.y, &orbitPoint.mPosition.z, &orbitPoint.mOrientation.axis.x, &orbitPoint.mOrientation.axis.y, &orbitPoint.mOrientation.axis.z, &orbitPoint.mOrientation.angle);


Point3F offset = Point3F();
sscanf(x__offset,"%f %f %f", &offset.x,&offset.y,&offset.z);
{
   MatrixF mat;
   orbitPoint.mOrientation.setMatrix(&mat);
   object->setOrbitMode(orbitObject, orbitPoint.mPosition, mat.toEuler(), offset, 
      minDistance, maxDistance, initDistance, ownClientObj, locked);
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnCamera_setOrbitObject(char * x__object, char * x__orbitObject, char * x__rotation, F32 minDistance, F32 maxDistance, F32 initDistance, bool ownClientObject, char * x__offset, bool locked)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
GameBase* orbitObject; Sim::findObject(x__orbitObject, orbitObject ); 
VectorF rotation = VectorF();
sscanf(x__rotation,"%f %f %f", &rotation.x, &rotation.y, &rotation.z);



Point3F offset = Point3F();
sscanf(x__offset,"%f %f %f", &offset.x,&offset.y,&offset.z);
bool wle_returnObject;
{
   if( !orbitObject )
   {
      Con::errorf( "Camera::setOrbitObject - Invalid object");
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   }
   object->setOrbitMode(orbitObject, Point3F(0.0f, 0.0f, 0.0f), rotation, offset, 
      minDistance, maxDistance, initDistance, ownClientObject, locked);
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_setOrbitPoint(char * x__object, char * x__orbitPoint, F32 minDistance, F32 maxDistance, F32 initDistance, char * x__offset, bool locked)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
TransformF orbitPoint = TransformF();
sscanf( x__orbitPoint,"%f %f %f %f %f %f %f", &orbitPoint.mPosition.x, &orbitPoint.mPosition.y, &orbitPoint.mPosition.z, &orbitPoint.mOrientation.axis.x, &orbitPoint.mOrientation.axis.y, &orbitPoint.mOrientation.axis.z, &orbitPoint.mOrientation.angle);


Point3F offset = Point3F();
sscanf(x__offset,"%f %f %f", &offset.x,&offset.y,&offset.z);
{
   MatrixF mat;
   orbitPoint.mOrientation.setMatrix(&mat);
   object->setOrbitMode(NULL, orbitPoint.mPosition, mat.toEuler(), offset, 
      minDistance, maxDistance, initDistance, false, locked);
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnCamera_setTrackObject(char * x__object, char * x__trackObject, char * x__offset)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
GameBase* trackObject; Sim::findObject(x__trackObject, trackObject ); 
Point3F offset = Point3F();
sscanf(x__offset,"%f %f %f", &offset.x,&offset.y,&offset.z);
bool wle_returnObject;
{
   if(!trackObject)
   {
      Con::warnf("Cannot track non-existing object.");
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   }
   object->setTrackObject(trackObject, offset);
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_setEditOrbitMode(char * x__object)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setEditOrbitMode();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_setFlyMode(char * x__object)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setFlyMode();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_setNewtonFlyMode(char * x__object)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setNewtonFlyMode();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnCamera_isRotationDamped(char * x__object)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isRotationDamped();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_getAngularVelocity(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
VectorF wle_returnObject;
{
   {wle_returnObject =object->getAngularVelocity();
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_setAngularVelocity(char * x__object, char * x__velocity)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
VectorF velocity = VectorF();
sscanf(x__velocity,"%f %f %f", &velocity.x, &velocity.y, &velocity.z);

{
   object->setAngularVelocity(velocity);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_setAngularForce(char * x__object, F32 force)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setAngularForce(force);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_setAngularDrag(char * x__object, F32 drag)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setAngularDrag(drag);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_setMass(char * x__object, F32 mass)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setMass(mass);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_getVelocity(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
VectorF wle_returnObject;
{
   {wle_returnObject =object->getVelocity();
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_setVelocity(char * x__object, char * x__velocity)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
VectorF velocity = VectorF();
sscanf(x__velocity,"%f %f %f", &velocity.x, &velocity.y, &velocity.z);

{
   object->setVelocity(velocity);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_setDrag(char * x__object, F32 drag)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setDrag(drag);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_setFlyForce(char * x__object, F32 force)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setFlyForce(force);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_setSpeedMultiplier(char * x__object, F32 multiplier)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setSpeedMultiplier(multiplier);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_setBrakeMultiplier(char * x__object, F32 multiplier)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setBrakeMultiplier(multiplier);
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnCamera_isEditOrbitMode(char * x__object)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isEditOrbitMode();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_setValidEditOrbitPoint(char * x__object, bool validPoint)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setValidEditOrbitPoint(validPoint);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_setEditOrbitPoint(char * x__object, char * x__point)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F point = Point3F();
sscanf(x__point,"%f %f %f", &point.x,&point.y,&point.z);
{
   object->setEditOrbitPoint(point);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_autoFitRadius(char * x__object, F32 radius)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->autoFitRadius(radius);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCamera_lookAt(char * x__object, char * x__point)
{
Camera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F point = Point3F();
sscanf(x__point,"%f %f %f", &point.x,&point.y,&point.z);
{
   object->lookAt(point);
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnDebris_init(char * x__object, char * x__inputPosition, char * x__inputVelocity)
{
Debris* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* inputPosition = (const char*)x__inputPosition;
const char* inputVelocity = (const char*)x__inputVelocity;
bool wle_returnObject;
{
   Point3F pos;
   dSscanf( inputPosition, "%f %f %f", &pos.x, &pos.y, &pos.z );
   Point3F vel;
   dSscanf( inputVelocity, "%f %f %f", &vel.x, &vel.y, &vel.z );
   object->init( pos, vel );
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__containerFindFirst(char * x__a1, char * x__a2, char * x__a3, char * x__a4, char * x__a5,  char* retval)
{
dSprintf(retval,4096,"");
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* wle_returnObject;
{
S32 argc = 6;
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
if (argc>=5)
arguments.push_back(a4);
if (argc>=6)
arguments.push_back(a5);
const char** argv = &arguments[0];
{
   //find out what we're looking for
   U32 typeMask = U32(dAtoi(argv[1]));
   //find the center of the container volume
   Point3F origin(0.0f, 0.0f, 0.0f);
   dSscanf(argv[2], "%g %g %g", &origin.x, &origin.y, &origin.z);
   //find the box dimensions
   Point3F size(0.0f, 0.0f, 0.0f);
   size.x = mFabs(dAtof(argv[3]));
   size.y = mFabs(dAtof(argv[4]));
   size.z = mFabs(dAtof(argv[5]));
   //build the container volume
   Box3F queryBox;
   queryBox.minExtents = origin;
   queryBox.maxExtents = origin;
   queryBox.minExtents -= size;
   queryBox.maxExtents += size;
   //initialize the list, and do the query
   sgServerQueryList.mList.clear();
   gServerContainer.findObjects(queryBox, typeMask, SimpleQueryList::insertionCallback, &sgServerQueryList);
   //return the first element
   sgServerQueryIndex = 0;
   char *buff = Con::getReturnBuffer(100);
   if (sgServerQueryList.mList.size())
      dSprintf(buff, 100, "%d", sgServerQueryList.mList[sgServerQueryIndex++]->getId());
   else
      buff[0] = '\0';
   {wle_returnObject =buff;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__containerFindNext(char* retval)
{
dSprintf(retval,4096,"");
const char* wle_returnObject;
{
{
   //return the next element
   char *buff = Con::getReturnBuffer(100);
   if (sgServerQueryIndex < sgServerQueryList.mList.size())
      dSprintf(buff, 100, "%d", sgServerQueryList.mList[sgServerQueryIndex++]->getId());
   else
      buff[0] = '\0';
   {wle_returnObject =buff;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGroundPlane_postApply(char * x__object)
{
GroundPlane* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->inspectPostApply();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMaterialPreview_setModel(char * x__object, char * x__shapeName)
{
GuiMaterialPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* shapeName = (const char*)x__shapeName;
{
   object->setObjectModel(shapeName);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMaterialPreview_deleteModel(char * x__object)
{
GuiMaterialPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->deleteModel();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMaterialPreview_setOrbitDistance(char * x__object, F32 distance)
{
GuiMaterialPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setOrbitDistance(distance);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMaterialPreview_reset(char * x__object)
{
GuiMaterialPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->resetViewport();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMaterialPreview_setLightColor(char * x__object, char * x__color)
{
GuiMaterialPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
ColorF color = ColorF();
sscanf(x__color,"%f %f %f %f",&color.red,&color.green,&color.blue,&color.alpha);
{
   object->setLightColor( color.red, color.green, color.blue );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiMaterialPreview_setAmbientLightColor(char * x__object, char * x__color)
{
GuiMaterialPreview* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
ColorF color = ColorF();
sscanf(x__color,"%f %f %f %f",&color.red,&color.green,&color.blue,&color.alpha);
{
   object->setAmbientLightColor( color.red, color.green, color.blue );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiObjectView_getModel(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiObjectView* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =Con::getReturnBuffer( object->getModelName() );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiObjectView_setModel(char * x__object, char * x__shapeName)
{
GuiObjectView* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* shapeName = (const char*)x__shapeName;
{
   object->setObjectModel( shapeName );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiObjectView_getMountedModel(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiObjectView* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =Con::getReturnBuffer( object->getMountedModelName() );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiObjectView_setMountedModel(char * x__object, char * x__shapeName)
{
GuiObjectView* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* shapeName = (const char*)x__shapeName;
{
   object->setObjectModel(shapeName);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiObjectView_getSkin(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
GuiObjectView* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =Con::getReturnBuffer( object->getSkin() );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiObjectView_setSkin(char * x__object, char * x__skinName)
{
GuiObjectView* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* skinName = (const char*)x__skinName;
{
   object->setSkin( skinName );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiObjectView_getMountSkin(char * x__object, S32 param1, S32 param2,  char* retval)
{
dSprintf(retval,4096,"");
GuiObjectView* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

const char* wle_returnObject;
{
   {wle_returnObject =Con::getReturnBuffer( object->getMountSkin() );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiObjectView_setMountSkin(char * x__object, char * x__skinName)
{
GuiObjectView* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* skinName = (const char*)x__skinName;
{
   object->setMountSkin(skinName);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiObjectView_setSeq(char * x__object, char * x__indexOrName)
{
GuiObjectView* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* indexOrName = (const char*)x__indexOrName;
{
   if( dIsdigit( indexOrName[0] ) )
      object->setObjectAnimation( dAtoi( indexOrName ) );
   else
      object->setObjectAnimation( indexOrName );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiObjectView_setMount(char * x__object, char * x__shapeName, char * x__mountNodeIndexOrName)
{
GuiObjectView* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* shapeName = (const char*)x__shapeName;
const char* mountNodeIndexOrName = (const char*)x__mountNodeIndexOrName;
{
   if( dIsdigit( mountNodeIndexOrName[0] ) )
      object->setMountNode( dAtoi( mountNodeIndexOrName ) );
   else
      object->setMountNode( mountNodeIndexOrName );
      
   object->setMountedObject( shapeName );
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnGuiObjectView_getOrbitDistance(char * x__object)
{
GuiObjectView* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getOrbitDistance());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiObjectView_setOrbitDistance(char * x__object, F32 distance)
{
GuiObjectView* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setOrbitDistance( distance );
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnGuiObjectView_getCameraSpeed(char * x__object)
{
GuiObjectView* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getCameraSpeed());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiObjectView_setCameraSpeed(char * x__object, F32 factor)
{
GuiObjectView* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setCameraSpeed( factor );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiObjectView_setLightColor(char * x__object, char * x__color)
{
GuiObjectView* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
ColorF color = ColorF();
sscanf(x__color,"%f %f %f %f",&color.red,&color.green,&color.blue,&color.alpha);
{  
   object->setLightColor( color );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiObjectView_setLightAmbient(char * x__object, char * x__color)
{
GuiObjectView* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
ColorF color = ColorF();
sscanf(x__color,"%f %f %f %f",&color.red,&color.green,&color.blue,&color.alpha);
{
   object->setLightAmbient( color );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGuiObjectView_setLightDirection(char * x__object, char * x__direction)
{
GuiObjectView* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F direction = Point3F();
sscanf(x__direction,"%f %f %f", &direction.x,&direction.y,&direction.z);
{
   object->setLightDirection( direction );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnItem_isStatic(char * x__object)
{
Item* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isStatic();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnItem_isAtRest(char * x__object)
{
Item* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isAtRest();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnItem_isRotating(char * x__object)
{
Item* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isRotating();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnItem_setCollisionTimeout(char * x__object, int ignoreColObj)
{
Item* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   ShapeBase* source = NULL;
   if (Sim::findObject(ignoreColObj,source)) {
      object->setCollisionTimeout(source);
      {wle_returnObject =true;
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnItem_getLastStickyPos(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
Item* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   char* ret = Con::getReturnBuffer(256);
   if (object->isServerObject())
      dSprintf(ret, 255, "%g %g %g",
               object->mStickyCollisionPos.x,
               object->mStickyCollisionPos.y,
               object->mStickyCollisionPos.z);
   else
      dStrcpy(ret, "0 0 0");
   {wle_returnObject =ret;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnItem_getLastStickyNormal(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
Item* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char * wle_returnObject;
{
   char* ret = Con::getReturnBuffer(256);
   if (object->isServerObject())
      dSprintf(ret, 255, "%g %g %g",
               object->mStickyCollisionNormal.x,
               object->mStickyCollisionNormal.y,
               object->mStickyCollisionNormal.z);
   else
      dStrcpy(ret, "0 0 0");
   {wle_returnObject =ret;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnLightBase_playAnimation(char * x__object, char * x__a2)
{
LightBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
    if ( argc == 2 )
    {
        object->playAnimation();
        return;
    }
    LightAnimData *animData;
    if ( !Sim::findObject( argv[2], animData ) )
    {
        Con::errorf( "LightBase::playAnimation() - Invalid LightAnimData '%s'.", argv[2] );
        return;
    }
    // Play Animation.
    object->playAnimation( animData );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnLightBase_pauseAnimation(char * x__object)
{
LightBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
    object->pauseAnimation();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnLightBase_setLightEnabled(char * x__object, bool state)
{
LightBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
  object->setLightEnabled( state );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnLightDescription_apply(char * x__object)
{
LightDescription* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
  object->inspectPostApply();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnLightFlareData_apply(char * x__object)
{
LightFlareData* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->inspectPostApply();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_getMissionAreaServerObject(char* retval)
{
dSprintf(retval,1024,"");
MissionArea* wle_returnObject;
{
	{wle_returnObject =MissionArea::getServerObject();
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMissionArea_getArea(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
MissionArea* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char * wle_returnObject;
{
   char* returnBuffer = Con::getReturnBuffer(48);
   RectI area = object->getArea();
   dSprintf(returnBuffer, sizeof(returnBuffer), "%d %d %d %d", area.point.x, area.point.y, area.extent.x, area.extent.y);
   {wle_returnObject =(returnBuffer);
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMissionArea_setArea(char * x__object, S32 x, S32 y, S32 width, S32 height)
{
MissionArea* object; Sim::findObject(x__object, object ); 
if (!object)
	return;


{
   if(object->isClientObject())
   {
      Con::errorf(ConsoleLogEntry::General, "MissionArea::cSetArea - cannot alter client object!");
      return;
   }
   RectI rect;
   rect.point.x = x;
   rect.point.y = y;
   rect.extent.x = width;
   rect.extent.y = height;
   object->setArea(rect);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMissionArea_postApply(char * x__object)
{
MissionArea* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->inspectPostApply();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSpawnSphere_spawnObject(char * x__object, char * x__a2)
{
SpawnSphere* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   String additionalProps;
   if (argc == 3)
      additionalProps = String(argv[2]);
   SimObject* obj = object->spawnObject(additionalProps);
   if (obj)
     return (S32)( obj->getId());
  return (S32)( -1);
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPathCamera_setPosition(char * x__object, F32 position)
{
PathCamera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setPosition(position);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPathCamera_setTarget(char * x__object, F32 position)
{
PathCamera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setTarget(position);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPathCamera_setState(char * x__object, char * x__newState)
{
PathCamera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* newState = (const char*)x__newState;
{
   if (!dStricmp(newState,"forward"))
      object->setState(PathCamera::Forward);
   else
      if (!dStricmp(newState,"backward"))
         object->setState(PathCamera::Backward);
      else
         object->setState(PathCamera::Stop);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPathCamera_reset(char * x__object, F32 speed)
{
PathCamera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->reset(speed);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPathCamera_pushBack(char * x__object, char * x__transform, F32 speed, char * x__type, char * x__path)
{
PathCamera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
TransformF transform = TransformF();
sscanf( x__transform,"%f %f %f %f %f %f %f", &transform.mPosition.x, &transform.mPosition.y, &transform.mPosition.z, &transform.mOrientation.axis.x, &transform.mOrientation.axis.y, &transform.mOrientation.axis.z, &transform.mOrientation.angle);

const char* type = (const char*)x__type;
const char* path = (const char*)x__path;
{
   QuatF rot(transform.getOrientation());
   object->pushBack( new CameraSpline::Knot(transform.getPosition(), rot, speed, resolveKnotType(type), resolveKnotPath(path)) );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPathCamera_pushFront(char * x__object, char * x__transform, F32 speed, char * x__type, char * x__path)
{
PathCamera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
TransformF transform = TransformF();
sscanf( x__transform,"%f %f %f %f %f %f %f", &transform.mPosition.x, &transform.mPosition.y, &transform.mPosition.z, &transform.mOrientation.axis.x, &transform.mOrientation.axis.y, &transform.mOrientation.axis.z, &transform.mOrientation.angle);

const char* type = (const char*)x__type;
const char* path = (const char*)x__path;
{
   QuatF rot(transform.getOrientation());
   object->pushFront( new CameraSpline::Knot(transform.getPosition(), rot, speed, resolveKnotType(type), resolveKnotPath(path)) );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPathCamera_popFront(char * x__object)
{
PathCamera* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->popFront();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPhysicalZone_activate(char * x__object)
{
PhysicalZone* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   if (object->isClientObject())
      return;
   object->activate();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPhysicalZone_deactivate(char * x__object)
{
PhysicalZone* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   if (object->isClientObject())
      return;
   object->deactivate();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPlayer_getPose(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
Player* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->getPoseName();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPlayer_allowAllPoses(char * x__object)
{
Player* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->allowAllPoses();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPlayer_allowJumping(char * x__object, bool state)
{
Player* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->allowJumping(state);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPlayer_allowJetJumping(char * x__object, bool state)
{
Player* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->allowJetJumping(state);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPlayer_allowSprinting(char * x__object, bool state)
{
Player* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->allowSprinting(state);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPlayer_allowCrouching(char * x__object, bool state)
{
Player* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->allowCrouching(state);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPlayer_allowProne(char * x__object, bool state)
{
Player* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->allowProne(state);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPlayer_allowSwimming(char * x__object, bool state)
{
Player* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->allowSwimming(state);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPlayer_getState(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
Player* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->getStateName();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPlayer_getDamageLocation(char * x__object, char * x__pos,  char* retval)
{
dSprintf(retval,4096,"");
Player* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F pos = Point3F();
sscanf(x__pos,"%f %f %f", &pos.x,&pos.y,&pos.z);
const char* wle_returnObject;
{
   const char *buffer1;
   const char *buffer2;
   object->getDamageLocation(pos, buffer1, buffer2);
   char *buff = Con::getReturnBuffer(128);
   dSprintf(buff, 128, "%s %s", buffer1, buffer2);
   {wle_returnObject =buff;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPlayer_setArmThread(char * x__object, char * x__name)
{
Player* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* name = (const char*)x__name;
bool wle_returnObject;
{
   {wle_returnObject =object->setArmThread( name );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPlayer_setActionThread(char * x__object, char * x__name, bool hold, bool fsp)
{
Player* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* name = (const char*)x__name;

bool wle_returnObject;
{
   {wle_returnObject =object->setActionThread( name, hold, true, fsp);
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPlayer_setControlObject(char * x__object, char * x__obj)
{
Player* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
ShapeBase* obj; Sim::findObject(x__obj, obj ); 
bool wle_returnObject;
{
   if (obj) {
      object->setControlObject(obj);
      {wle_returnObject =true;
return (S32)(wle_returnObject);}
   }
   else
      object->setControlObject(0);
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPlayer_getControlObject(char * x__object)
{
Player* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   ShapeBase* controlObject = object->getControlObject();
  return (S32)( controlObject ? controlObject->getId(): 0);
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPlayer_clearControlObject(char * x__object)
{
Player* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setControlObject(0);
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPlayer_checkDismountPoint(char * x__object, char * x__oldPos, char * x__pos)
{
Player* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
Point3F oldPos = Point3F();
sscanf(x__oldPos,"%f %f %f", &oldPos.x,&oldPos.y,&oldPos.z);
Point3F pos = Point3F();
sscanf(x__pos,"%f %f %f", &pos.x,&pos.y,&pos.z);
bool wle_returnObject;
{
   MatrixF oldPosMat(true);
   oldPosMat.setColumn(3, oldPos);
   MatrixF posMat(true);
   posMat.setColumn(3, pos);
   {wle_returnObject =object->checkDismountPosition(oldPosMat, posMat);
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPlayer_getNumDeathAnimations(char * x__object)
{
Player* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   S32 count = 0;
   const PlayerData * db = dynamic_cast<PlayerData*>( object->getDataBlock() );
   if ( db )
   {
      for ( S32 i = 0; i < db->actionCount; i++ )
         if ( db->actionList[i].death )
            count++;
   }
  return (S32)( count);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPortal_isInteriorPortal(char * x__object)
{
Portal* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isInteriorPortal();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPortal_isExteriorPortal(char * x__object)
{
Portal* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isExteriorPortal();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnProjectile_presimulate(char * x__object, F32 seconds)
{
Projectile* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->simulate( seconds );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnProximityMine_explode(char * x__object)
{
ProximityMine* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->explode();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBaseData_checkDeployPos(char * x__object, char * x__txfm)
{
ShapeBaseData* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
TransformF txfm = TransformF();
sscanf( x__txfm,"%f %f %f %f %f %f %f", &txfm.mPosition.x, &txfm.mPosition.y, &txfm.mPosition.z, &txfm.mOrientation.axis.x, &txfm.mOrientation.axis.y, &txfm.mOrientation.axis.z, &txfm.mOrientation.angle);
bool wle_returnObject;
{
   if (bool(object->mShape) == false)
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   MatrixF mat = txfm.getMatrix();
   Box3F objBox = object->mShape->bounds;
   Point3F boxCenter = (objBox.minExtents + objBox.maxExtents) * 0.5f;
   objBox.minExtents = boxCenter + (objBox.minExtents - boxCenter) * 0.9f;
   objBox.maxExtents = boxCenter + (objBox.maxExtents - boxCenter) * 0.9f;
   Box3F wBox = objBox;
   mat.mul(wBox);
   EarlyOutPolyList polyList;
   polyList.mNormal.set(0,0,0);
   polyList.mPlaneList.clear();
   polyList.mPlaneList.setSize(6);
   polyList.mPlaneList[0].set(objBox.minExtents,VectorF(-1,0,0));
   polyList.mPlaneList[1].set(objBox.maxExtents,VectorF(0,1,0));
   polyList.mPlaneList[2].set(objBox.maxExtents,VectorF(1,0,0));
   polyList.mPlaneList[3].set(objBox.minExtents,VectorF(0,-1,0));
   polyList.mPlaneList[4].set(objBox.minExtents,VectorF(0,0,-1));
   polyList.mPlaneList[5].set(objBox.maxExtents,VectorF(0,0,1));
   for (U32 i = 0; i < 6; i++)
   {
      PlaneF temp;
      mTransformPlane(mat, Point3F(1, 1, 1), polyList.mPlaneList[i], &temp);
      polyList.mPlaneList[i] = temp;
   }
   if (gServerContainer.buildPolyList(PLC_Collision, wBox, InteriorObjectType | StaticShapeObjectType, &polyList))
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBaseData_getDeployTransform(char * x__object, char * x__pos, char * x__normal,  char* retval)
{
dSprintf(retval,1024,"");
ShapeBaseData* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F pos = Point3F();
sscanf(x__pos,"%f %f %f", &pos.x,&pos.y,&pos.z);
Point3F normal = Point3F();
sscanf(x__normal,"%f %f %f", &normal.x,&normal.y,&normal.z);
TransformF wle_returnObject;
{
   normal.normalize();
   VectorF xAxis;
   if( mFabs(normal.z) > mFabs(normal.x) && mFabs(normal.z) > mFabs(normal.y))
      mCross( VectorF( 0, 1, 0 ), normal, &xAxis );
   else
      mCross( VectorF( 0, 0, 1 ), normal, &xAxis );
   VectorF yAxis;
   mCross( normal, xAxis, &yAxis );
   MatrixF testMat(true);
   testMat.setColumn( 0, xAxis );
   testMat.setColumn( 1, yAxis );
   testMat.setColumn( 2, normal );
   testMat.setPosition( pos );
   {wle_returnObject =testMat;
dSprintf(retval,1024,"%f %f %f %f %f %f %f ",wle_returnObject.mPosition.x,wle_returnObject.mPosition.y,wle_returnObject.mPosition.z,wle_returnObject.mOrientation.axis.x,wle_returnObject.mOrientation.axis.y,wle_returnObject.mOrientation.axis.z,wle_returnObject.mOrientation.angle);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_setHidden(char * x__object, bool show)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setHidden( show );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_isHidden(char * x__object)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isHidden();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_playAudio(char * x__object, S32 slot, char * x__track)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

SFXTrack* track; Sim::findObject(x__track, track ); 
bool wle_returnObject;
{
   if (track && slot >= 0 && slot < ShapeBase::MaxSoundThreads) {
      object->playAudio(slot,track);
      {wle_returnObject =true;
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_stopAudio(char * x__object, S32 slot)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxSoundThreads) {
      object->stopAudio(slot);
      {wle_returnObject =true;
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_playThread(char * x__object, S32 slot, char * x__name)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

const char* name = (const char*)x__name;
bool wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxScriptThreads) {
      if (!dStrEqual(name, "")) {
         if (object->getShape()) {
            S32 seq = object->getShape()->findSequence(name);
            if (seq != -1 && object->setThreadSequence(slot,seq))
               {wle_returnObject =true;
return (S32)(wle_returnObject);}
         }
      }
      else
         if (object->playThread(slot))
            {wle_returnObject =true;
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_setThreadDir(char * x__object, S32 slot, bool fwd)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

bool wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxScriptThreads) {
      if (object->setThreadDir(slot,fwd))
         {wle_returnObject =true;
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_setThreadTimeScale(char * x__object, S32 slot, F32 scale)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

bool wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxScriptThreads) {
      if (object->setThreadTimeScale(slot,scale))
         {wle_returnObject =true;
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_setThreadPosition(char * x__object, S32 slot, F32 pos)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

bool wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxScriptThreads) {
      if (object->setThreadPosition(slot,pos))
         {wle_returnObject =true;
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_stopThread(char * x__object, S32 slot)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxScriptThreads) {
      if (object->stopThread(slot))
         {wle_returnObject =true;
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_destroyThread(char * x__object, S32 slot)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxScriptThreads) {
      if (object->destroyThread(slot))
         {wle_returnObject =true;
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_pauseThread(char * x__object, S32 slot)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxScriptThreads) {
      if (object->pauseThread(slot))
         {wle_returnObject =true;
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_mountImage(char * x__object, char * x__image, S32 slot, bool loaded, char * x__skinTag)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
ShapeBaseImageData* image; Sim::findObject(x__image, image ); 

const char* skinTag = (const char*)x__skinTag;
bool wle_returnObject;
{
   if (image && slot >= 0 && slot < ShapeBase::MaxMountedImages) {
      NetStringHandle team;
      if (skinTag[0] == StringTagPrefixByte)
         team = NetStringHandle(U32(dAtoi(skinTag+1)));
      {wle_returnObject =object->mountImage( image, slot, loaded, team );
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_unmountImage(char * x__object, S32 slot)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages)
      {wle_returnObject =object->unmountImage(slot);
return (S32)(wle_returnObject);}
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_getMountedImage(char * x__object, S32 slot)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages)
      if (ShapeBaseImageData* data = object->getMountedImage(slot))
        return (S32)( data->getId());
  return (S32)( 0);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_getPendingImage(char * x__object, S32 slot)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages)
      if (ShapeBaseImageData* data = object->getPendingImage(slot))
        return (S32)( data->getId());
  return (S32)( 0);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_isImageFiring(char * x__object, S32 slot)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages)
      {wle_returnObject =object->isImageFiring(slot);
return (S32)(wle_returnObject);}
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_isImageMounted(char * x__object, char * x__image)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
ShapeBaseImageData* image; Sim::findObject(x__image, image ); 
bool wle_returnObject;
{
   {wle_returnObject =(image && object->isImageMounted(image));
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_getMountSlot(char * x__object, char * x__image)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
ShapeBaseImageData* image; Sim::findObject(x__image, image ); 
{
  return (S32)( image ? object->getMountSlot(image) : -1);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_getImageSkinTag(char * x__object, S32 slot)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages)
     return (S32)( object->getImageSkinTag(slot).getIndex());
  return (S32)( -1);
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_getImageState(char * x__object, S32 slot,  char* retval)
{
dSprintf(retval,4096,"");
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages)
      {wle_returnObject =object->getImageState(slot);
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   {wle_returnObject ="Error";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_hasImageState(char * x__object, S32 slot, char * x__state)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

const char* state = (const char*)x__state;
bool wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages)
      {wle_returnObject =object->hasImageState(slot, state);
return (S32)(wle_returnObject);}
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_getImageTrigger(char * x__object, S32 slot)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages)
      {wle_returnObject =object->getImageTriggerState(slot);
return (S32)(wle_returnObject);}
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_setImageTrigger(char * x__object, S32 slot, bool state)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

bool wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages) {
      object->setImageTriggerState(slot,state);
      {wle_returnObject =object->getImageTriggerState(slot);
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_getImageGenericTrigger(char * x__object, S32 slot, S32 trigger)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

bool wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages && trigger >= 0 && trigger < ShapeBaseImageData::MaxGenericTriggers)
      {wle_returnObject =object->getImageGenericTriggerState(slot, trigger);
return (S32)(wle_returnObject);}
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_setImageGenericTrigger(char * x__object, S32 slot, S32 trigger, bool state)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

{
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages && trigger >= 0 && trigger < ShapeBaseImageData::MaxGenericTriggers) {
      object->setImageGenericTriggerState(slot,trigger,state);
     return (S32)( object->getImageGenericTriggerState(slot,trigger));
   }
  return (S32)( -1);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_getImageAltTrigger(char * x__object, S32 slot)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages)
      {wle_returnObject =object->getImageAltTriggerState(slot);
return (S32)(wle_returnObject);}
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_setImageAltTrigger(char * x__object, S32 slot, bool state)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

bool wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages) {
      object->setImageAltTriggerState(slot,state);
      {wle_returnObject =object->getImageAltTriggerState(slot);
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_getImageAmmo(char * x__object, S32 slot)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages)
      {wle_returnObject =object->getImageAmmoState(slot);
return (S32)(wle_returnObject);}
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_setImageAmmo(char * x__object, S32 slot, bool state)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

bool wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages) {
      object->setImageAmmoState(slot,state);
      {wle_returnObject =state;
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_getImageLoaded(char * x__object, S32 slot)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages)
      {wle_returnObject =object->getImageLoadedState(slot);
return (S32)(wle_returnObject);}
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_setImageLoaded(char * x__object, S32 slot, bool state)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

bool wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages) {
      object->setImageLoadedState(slot, state);
      {wle_returnObject =state;
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_getImageTarget(char * x__object, S32 slot)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages)
      {wle_returnObject =object->getImageTargetState(slot);
return (S32)(wle_returnObject);}
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_setImageTarget(char * x__object, S32 slot, bool state)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

bool wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages) {
      object->setImageTargetState(slot,state);
      {wle_returnObject =state;
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_getImageScriptAnimPrefix(char * x__object, S32 slot,  char* retval)
{
dSprintf(retval,4096,"");
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages)
      {wle_returnObject =object->getImageScriptAnimPrefix(slot).getString();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_setImageScriptAnimPrefix(char * x__object, S32 slot, char * x__prefix)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

const char* prefix = (const char*)x__prefix;
{
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages) {
      NetStringHandle prefixHandle;
      if (prefix[0] == StringTagPrefixByte)
         prefixHandle = NetStringHandle(U32(dAtoi(prefix+1)));
      object->setImageScriptAnimPrefix(slot, prefixHandle);
   }
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_getMuzzleVector(char * x__object, S32 slot,  char* retval)
{
dSprintf(retval,1024,"");
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
VectorF wle_returnObject;
{
   VectorF vec(0, 1, 0);
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages)
      object->getMuzzleVector(slot, &vec);
   {wle_returnObject =vec;
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_getMuzzlePoint(char * x__object, S32 slot,  char* retval)
{
dSprintf(retval,1024,"");
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F wle_returnObject;
{
   Point3F pos(0, 0, 0);
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages)
      object->getMuzzlePoint(slot, &pos);
   {wle_returnObject =pos;
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_getSlotTransform(char * x__object, S32 slot,  char* retval)
{
dSprintf(retval,1024,"");
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
TransformF wle_returnObject;
{
   MatrixF xf(true);
   if (slot >= 0 && slot < ShapeBase::MaxMountedImages)
      object->getMountTransform( slot, MatrixF::Identity, &xf );
   {wle_returnObject =xf;
dSprintf(retval,1024,"%f %f %f %f %f %f %f ",wle_returnObject.mPosition.x,wle_returnObject.mPosition.y,wle_returnObject.mPosition.z,wle_returnObject.mOrientation.axis.x,wle_returnObject.mOrientation.axis.y,wle_returnObject.mOrientation.axis.z,wle_returnObject.mOrientation.angle);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_getAIRepairPoint(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F wle_returnObject;
{
   {wle_returnObject =object->getAIRepairPoint();
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_getVelocity(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
VectorF wle_returnObject;
{
   {wle_returnObject =object->getVelocity();
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_setVelocity(char * x__object, char * x__vel)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
Point3F vel = Point3F();
sscanf(x__vel,"%f %f %f", &vel.x,&vel.y,&vel.z);
bool wle_returnObject;
{
   object->setVelocity( vel );
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_applyImpulse(char * x__object, char * x__pos, char * x__vec)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
Point3F pos = Point3F();
sscanf(x__pos,"%f %f %f", &pos.x,&pos.y,&pos.z);
Point3F vec = Point3F();
sscanf(x__vec,"%f %f %f", &vec.x,&vec.y,&vec.z);
bool wle_returnObject;
{
   object->applyImpulse( pos, vec );
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_getEyeVector(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
VectorF wle_returnObject;
{
   MatrixF mat;
   object->getEyeTransform(&mat);
   {wle_returnObject =mat.getForwardVector();
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_getEyePoint(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F wle_returnObject;
{
   MatrixF mat;
   object->getEyeTransform(&mat);
   {wle_returnObject =mat.getPosition();
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_getEyeTransform(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
TransformF wle_returnObject;
{
   MatrixF mat;
   object->getEyeTransform(&mat);
   {wle_returnObject =mat;
dSprintf(retval,1024,"%f %f %f %f %f %f %f ",wle_returnObject.mPosition.x,wle_returnObject.mPosition.y,wle_returnObject.mPosition.z,wle_returnObject.mOrientation.axis.x,wle_returnObject.mOrientation.axis.y,wle_returnObject.mOrientation.axis.z,wle_returnObject.mOrientation.angle);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_getLookAtPoint(char * x__object, F32 distance, S32 typeMask,  char* retval)
{
dSprintf(retval,4096,"");
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

const char* wle_returnObject;
{
   MatrixF mat;
   object->getEyeTransform( &mat );
   
   // Get eye vector.
   
   VectorF eyeVector;
   mat.getColumn( 1, &eyeVector );
   
   // Get eye position.
   
   VectorF eyePos;
   mat.getColumn( 3, &eyePos );
   
   // Make sure the eye vector covers the distance.
   
   eyeVector *= distance;
   
   // Do a container search.
   
   VectorF start = eyePos;
   VectorF end = eyePos + eyeVector;
   
   RayInfo ri;
   if( !gServerContainer.castRay( start, end, typeMask, &ri ) || !ri.object )
      {wle_returnObject =""; 
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   
   // Gather hit info.
      
   enum { BUFFER_SIZE = 256 };
   char* buffer = Con::getReturnBuffer( BUFFER_SIZE );
   if( ri.material )
      dSprintf( buffer, BUFFER_SIZE, "%u %f %f %f %u",
         ri.object->getId(),
         ri.point.x,
         ri.point.y,
         ri.point.z,
         ri.material->getMaterial()->getId() );
   else
      dSprintf( buffer, BUFFER_SIZE, "%u %f %f %f",
         ri.object->getId(),
         ri.point.x,
         ri.point.y,
         ri.point.z );
   {wle_returnObject =buffer;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_setEnergyLevel(char * x__object, F32 level)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setEnergyLevel( level );
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnShapeBase_getEnergyLevel(char * x__object)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getEnergyLevel());
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnShapeBase_getEnergyPercent(char * x__object)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getEnergyValue());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_setDamageLevel(char * x__object, F32 level)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setDamageLevel( level );
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnShapeBase_getDamageLevel(char * x__object)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getDamageLevel());
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnShapeBase_getDamagePercent(char * x__object)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getDamageValue());
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnShapeBase_getMaxDamage(char * x__object)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{    
  return (F32)( object->getMaxDamage());    
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_setDamageState(char * x__object, char * x__state)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* state = (const char*)x__state;
bool wle_returnObject;
{
   {wle_returnObject =object->setDamageState( state );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_getDamageState(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->getDamageStateName();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_isDestroyed(char * x__object)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isDestroyed();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_isDisabled(char * x__object)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->getDamageState() != ShapeBase::Enabled;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_isEnabled(char * x__object)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->getDamageState() == ShapeBase::Enabled;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_applyDamage(char * x__object, F32 amount)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->applyDamage( amount );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_applyRepair(char * x__object, F32 amount)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->applyRepair( amount );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_setRepairRate(char * x__object, F32 rate)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   if(rate < 0)
      rate = 0;
   object->setRepairRate( rate );
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnShapeBase_getRepairRate(char * x__object)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getRepairRate());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_setRechargeRate(char * x__object, F32 rate)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setRechargeRate( rate );
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnShapeBase_getRechargeRate(char * x__object)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getRechargeRate());
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_getControllingClient(char * x__object)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   if (GameConnection* con = object->getControllingClient())
     return (S32)( con->getId());
  return (S32)( 0);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_getControllingObject(char * x__object)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   if (ShapeBase* con = object->getControllingObject())
     return (S32)( con->getId());
  return (S32)( 0);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_canCloak(char * x__object)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_setCloaked(char * x__object, bool cloak)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   if (object->isServerObject())
      object->setCloakedState( cloak );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_isCloaked(char * x__object)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->getCloakedState();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_setDamageFlash(char * x__object, F32 level)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   if (object->isServerObject())
      object->setDamageFlash( level );
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnShapeBase_getDamageFlash(char * x__object)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getDamageFlash());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_setWhiteOut(char * x__object, F32 level)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   if (object->isServerObject())
      object->setWhiteOut( level );
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnShapeBase_getWhiteOut(char * x__object)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getWhiteOut());
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnShapeBase_getDefaultCameraFov(char * x__object)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   if (object->isServerObject())
     return (F32)( object->getDefaultCameraFov());
  return (F32)( 0.0);
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnShapeBase_getCameraFov(char * x__object)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   if (object->isServerObject())
     return (F32)( object->getCameraFov());
  return (F32)( 0.0);
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_setCameraFov(char * x__object, F32 fov)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   if (object->isServerObject())
      object->setCameraFov( fov );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_setInvincibleMode(char * x__object, F32 time, F32 speed)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->setupInvincibleEffect( time, speed );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_startFade(char * x__object, S32 time, S32 delay, bool fadeOut)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->startFade( (F32)time / (F32)1000.0, delay / 1000.0, fadeOut );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_setDamageVector(char * x__object, char * x__vec)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F vec = Point3F();
sscanf(x__vec,"%f %f %f", &vec.x,&vec.y,&vec.z);
{
   vec.normalize();
   object->setDamageDir( vec );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_setShapeName(char * x__object, char * x__name)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* name = (const char*)x__name;
{
   object->setShapeName( name );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_getShapeName(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->getShapeName();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_setSkinName(char * x__object, char * x__name)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* name = (const char*)x__name;
{
   object->setSkinName( name );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_getSkinName(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->getSkinName();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_getVisibleDistance(char * x__object)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
		return (object->getVisibleDistance());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_setVisibleDistance(char * x__object, S32 dist)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->setVisibleDistance(dist);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_setAllMeshesHidden(char * x__object, bool hide)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setAllMeshesHidden( hide );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_setMeshHidden(char * x__object, char * x__name, bool hide)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* name = (const char*)x__name;

{
   object->setMeshHidden( name, hide );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_dumpMeshVisibility(char * x__object)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->dumpMeshVisibility();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_getTargetName(char * x__object, S32 index,  char* retval)
{
dSprintf(retval,4096,"");
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
	ShapeBase *obj = dynamic_cast< ShapeBase* > ( object );
	if(obj)
	{
		// Try to use the client object (so we get the reskinned targets in the Material Editor)
		if ((ShapeBase*)obj->getClientObject())
			obj = (ShapeBase*)obj->getClientObject();
		{wle_returnObject =obj->getShapeInstance()->getTargetName(index);
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
	}
	{wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnShapeBase_getTargetCount(char * x__object)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
	ShapeBase *obj = dynamic_cast< ShapeBase* > ( object );
	if(obj)
	{
		// Try to use the client object (so we get the reskinned targets in the Material Editor)
		if ((ShapeBase*)obj->getClientObject())
			obj = (ShapeBase*)obj->getClientObject();
		return obj->getShapeInstance()->getTargetCount();
	}
	return -1;
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_changeMaterial(char * x__object, char * x__mapTo, char * x__oldMat, char * x__newMat)
{
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* mapTo = (const char*)x__mapTo;
Material* oldMat; Sim::findObject(x__oldMat, oldMat ); 
Material* newMat; Sim::findObject(x__newMat, newMat ); 
{
   // if no valid new material, theres no reason for doing this
   if( !newMat )
   {
      Con::errorf("ShapeBase::changeMaterial failed: New material does not exist!");
      return;
   }
   // initilize server/client versions
   ShapeBase *serverObj = object;
   ShapeBase *clientObj = dynamic_cast< ShapeBase* > ( object->getClientObject() );
   // Check the mapTo name exists for this shape
   S32 matIndex = serverObj->getShape()->materialList->getMaterialNameList().find_next(String(mapTo));
   if (matIndex < 0)
   {
      Con::errorf("ShapeBase::changeMaterial failed: Invalid mapTo name '%s'", mapTo);
      return;
   }
   // Lets remap the old material off, so as to let room for our current material room to claim its spot
   if( oldMat )
      oldMat->mMapTo = String("unmapped_mat");
   newMat->mMapTo = mapTo;
   // Map the material in the in the matmgr
   MATMGR->mapMaterial( mapTo, newMat->mMapTo );
   // Replace instances with the new material being traded in. For ShapeBase
   // class we have to update the server/client objects separately so both
   // represent our changes
   delete serverObj->getShape()->materialList->mMatInstList[matIndex];
   serverObj->getShape()->materialList->mMatInstList[matIndex] = newMat->createMatInstance();
   if (clientObj)
   {
      delete clientObj->getShape()->materialList->mMatInstList[matIndex];
      clientObj->getShape()->materialList->mMatInstList[matIndex] = newMat->createMatInstance();
   }
   // Finish up preparing the material instances for rendering
   const GFXVertexFormat *flags = getGFXVertexFormat<GFXVertexPNTTB>();
   FeatureSet features = MATMGR->getDefaultFeatures();
   serverObj->getShape()->materialList->getMaterialInst(matIndex)->init( features, flags );
   if (clientObj)
      clientObj->getShapeInstance()->mMaterialList->getMaterialInst(matIndex)->init( features, flags );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnShapeBase_getModelFile(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
ShapeBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char * wle_returnObject;
{
	GameBaseData * datablock = object->getDataBlock();
	if( !datablock )
		{wle_returnObject =String::EmptyString;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
	const char *fieldName = StringTable->insert( String("shapeFile") );
   {wle_returnObject =datablock->getDataField( fieldName, NULL );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnStaticShape_setPoweredState(char * x__object, char * x__a2)
{
StaticShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   if(!object->isServerObject())
      return;
   object->setPowered(dAtob(argv[2]));
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnStaticShape_getPoweredState(char * x__object)
{
StaticShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
{
   if(!object->isServerObject())
      {wle_returnObject =(false);
return (S32)(wle_returnObject);}
   {wle_returnObject =(object->isPowered());
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnTrigger_getNumObjects(char * x__object)
{
Trigger* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getNumTriggeringObjects());
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnTrigger_getObject(char * x__object, S32 index)
{
Trigger* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   if (index >= object->getNumTriggeringObjects() || index < 0)
     return (S32)( -1);
   else
     return (S32)( object->getObject(U32(index))->getId());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnTSStatic_getTargetName(char * x__object, S32 index,  char* retval)
{
dSprintf(retval,4096,"");
TSStatic* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
	TSStatic *obj = dynamic_cast< TSStatic* > ( object );
	if(obj)
	{
		// Try to use the client object (so we get the reskinned targets in the Material Editor)
		if ((TSStatic*)obj->getClientObject())
			obj = (TSStatic*)obj->getClientObject();
		{wle_returnObject =obj->getShapeInstance()->getTargetName(index);
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
	}
	{wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnTSStatic_getTargetCount(char * x__object)
{
TSStatic* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
	TSStatic *obj = dynamic_cast< TSStatic* > ( object );
	if(obj)
	{
		// Try to use the client object (so we get the reskinned targets in the Material Editor)
		if ((TSStatic*)obj->getClientObject())
			obj = (TSStatic*)obj->getClientObject();
		return obj->getShapeInstance()->getTargetCount();
	}
	return -1;
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnTSStatic_changeMaterial(char * x__object, char * x__mapTo, char * x__oldMat, char * x__newMat)
{
TSStatic* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* mapTo = (const char*)x__mapTo;
Material* oldMat; Sim::findObject(x__oldMat, oldMat ); 
Material* newMat; Sim::findObject(x__newMat, newMat ); 
{
   // if no valid new material, theres no reason for doing this
   if( !newMat )
   {
      Con::errorf("TSShape::changeMaterial failed: New material does not exist!");
      return;
   }
   // Check the mapTo name exists for this shape
   S32 matIndex = object->getShape()->materialList->getMaterialNameList().find_next(String(mapTo));
   if (matIndex < 0)
   {
      Con::errorf("TSShape::changeMaterial failed: Invalid mapTo name '%s'", mapTo);
      return;
   }
   // Lets remap the old material off, so as to let room for our current material room to claim its spot
   if( oldMat )
      oldMat->mMapTo = String("unmapped_mat");
   newMat->mMapTo = mapTo;
   // Map the material in the in the matmgr
   MATMGR->mapMaterial( mapTo, newMat->mMapTo );
   // Replace instances with the new material being traded in. Lets make sure that we only
   // target the specific targets per inst, this is actually doing more than we thought
   delete object->getShape()->materialList->mMatInstList[matIndex];
   object->getShape()->materialList->mMatInstList[matIndex] = newMat->createMatInstance();
   // Finish up preparing the material instances for rendering
   const GFXVertexFormat *flags = getGFXVertexFormat<GFXVertexPNTTB>();
   FeatureSet features = MATMGR->getDefaultFeatures();
   object->getShape()->materialList->getMaterialInst(matIndex)->init( features, flags );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnTSStatic_getModelFile(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
TSStatic* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char * wle_returnObject;
{
	{wle_returnObject =object->getShapeFileName();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnZone_getZoneId(char * x__object)
{
Zone* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getZoneRangeStart());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnZone_dumpZoneState(char * x__object, bool updateFirst)
{
Zone* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->dumpZoneState( updateFirst );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnRenderMeshExample_postApply(char * x__object)
{
RenderMeshExample* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
	object->inspectPostApply();
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn_calcExplosionCoverage(char * x__pos, S32 id, U32 covMask)
{
Point3F pos = Point3F();
sscanf(x__pos,"%f %f %f", &pos.x,&pos.y,&pos.z);

{
   Point3F center;
   SceneObject* sceneObject = NULL;
   if (Sim::findObject(id, sceneObject) == false) {
      Con::warnf(ConsoleLogEntry::General, "calcExplosionCoverage: couldn't find object: %s", id);
     return (F32)( 1.0f);
   }
   if (sceneObject->isClientObject() || sceneObject->getContainer() == NULL) {
      Con::warnf(ConsoleLogEntry::General, "calcExplosionCoverage: object is on the client, or not in the container system");
     return (F32)( 1.0f);
   }
   sceneObject->getObjBox().getCenter(&center);
   center.convolve(sceneObject->getScale());
   sceneObject->getTransform().mulP(center);
   RayInfo rayInfo;
   sceneObject->disableCollision();
   if (sceneObject->getContainer()->castRay(pos, center, covMask, &rayInfo) == true) {
      // Try casting up and then out
      if (sceneObject->getContainer()->castRay(pos, pos + Point3F(0.0f, 0.0f, 1.0f), covMask, &rayInfo) == false)
      {
         if (sceneObject->getContainer()->castRay(pos + Point3F(0.0f, 0.0f, 1.0f), center, covMask, &rayInfo) == false)
         {
            sceneObject->enableCollision();
           return (F32)( 1.0f);
         }
      }
      sceneObject->enableCollision();
     return (F32)( 0.0f);
   } else {
      sceneObject->enableCollision();
     return (F32)( 1.0f);
   }
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_StartFoliageReplication()
{
{
   // Find the Replicator Set.
   SimSet *fxFoliageSet = dynamic_cast<SimSet*>(Sim::findObject("fxFoliageSet"));
   // Return if Error.
   if (!fxFoliageSet)
   {
      // Console Warning.
      Con::warnf("fxFoliageReplicator - Cannot locate the 'fxFoliageSet', this is bad!");
      // Return here.
      return;
   }
   // Parse Replication Object(s).
   U32 startupCount = 0;
   for (SimSetIterator itr(fxFoliageSet); *itr; ++itr)
   {
      // Fetch the Replicator Object.
      fxFoliageReplicator* Replicator = static_cast<fxFoliageReplicator*>(*itr);
      // Start Client Objects Only.
      if (Replicator->isClientObject())
      {
         Replicator->StartUp();
         startupCount++;
      }
   }
   // Info ...
   Con::printf("fxFoliageReplicator - replicated client foliage for %d objects", startupCount);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_StartClientReplication()
{
{
   // Find the Replicator Set.
   SimSet *fxReplicatorSet = dynamic_cast<SimSet*>(Sim::findObject("fxReplicatorSet"));
   // Return if Error.
   if (!fxReplicatorSet) return;
   // StartUp Replication Object.
   for (SimSetIterator itr(fxReplicatorSet); *itr; ++itr)
   {
      // Fetch the Replicator Object.
      fxShapeReplicator* Replicator = static_cast<fxShapeReplicator*>(*itr);
      // Start Client Objects Only.
      if (Replicator->isClientObject()) Replicator->StartUp();
   }
   // Info ...
   Con::printf("Client Replication Startup has Happened!");
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnLightning_warningFlashes(char * x__object)
{
Lightning* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   if (object->isServerObject()) 
      object->warningFlashes();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnLightning_strikeRandomPoint(char * x__object)
{
Lightning* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   if (object->isServerObject()) 
      object->strikeRandomPoint();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnLightning_strikeObject(char * x__object, S32 id)
{
Lightning* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   ShapeBase* pSB;
   if (object->isServerObject() && Sim::findObject(id, pSB))
      object->strikeObject(pSB);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnParticleData_reload(char * x__object)
{
ParticleData* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   char errorBuffer[256];
   object->reload(errorBuffer);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnParticleEmitterData_reload(char * x__object)
{
ParticleEmitterData* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->reload();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnParticleEmitterNode_setEmitterDataBlock(char * x__object, char * x__emitterDatablock)
{
ParticleEmitterNode* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
ParticleEmitterData* emitterDatablock; Sim::findObject(x__emitterDatablock, emitterDatablock ); 
{
   if ( !emitterDatablock )
   {
      Con::errorf("ParticleEmitterData datablock could not be found when calling setEmitterDataBlock in particleEmitterNode.");
      return;
   }
   object->setEmitterDataBlock(emitterDatablock);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnParticleEmitterNode_setActive(char * x__object, bool active)
{
ParticleEmitterNode* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setActive( active );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPrecipitation_setPercentage(char * x__object, F32 percentage)
{
Precipitation* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setPercentage(percentage);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPrecipitation_modifyStorm(char * x__object, F32 percentage, F32 seconds)
{
Precipitation* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->modifyStorm(percentage, S32(seconds * 1000.0f));
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPrecipitation_setTurbulence(char * x__object, F32 max, F32 speed, F32 seconds)
{
Precipitation* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->setTurbulence( max, speed, S32(seconds * 1000.0f));
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGameBase_getDataBlock(char * x__object)
{
GameBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getDataBlock()? object->getDataBlock()->getId(): 0);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGameBase_setDataBlock(char * x__object, char * x__data)
{
GameBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
GameBaseData* data; Sim::findObject(x__data, data ); 
bool wle_returnObject;
{
   {wle_returnObject =( data && object->setDataBlock(data) );
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGameBase_applyImpulse(char * x__object, char * x__pos, char * x__vel)
{
GameBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
Point3F pos = Point3F();
sscanf(x__pos,"%f %f %f", &pos.x,&pos.y,&pos.z);
VectorF vel = VectorF();
sscanf(x__vel,"%f %f %f", &vel.x, &vel.y, &vel.z);

bool wle_returnObject;
{
   object->applyImpulse(pos,vel);
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGameBase_applyRadialImpulse(char * x__object, char * x__origin, F32 radius, F32 magnitude)
{
GameBase* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F origin = Point3F();
sscanf(x__origin,"%f %f %f", &origin.x,&origin.y,&origin.z);

{
   object->applyRadialImpulse( origin, radius, magnitude );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGameConnection_setConnectArgs(char * x__object, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10, char * x__a11, char * x__a12, char * x__a13, char * x__a14, char * x__a15, char * x__a16)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* a11 = (const char*)x__a11;
const char* a12 = (const char*)x__a12;
const char* a13 = (const char*)x__a13;
const char* a14 = (const char*)x__a14;
const char* a15 = (const char*)x__a15;
const char* a16 = (const char*)x__a16;
{
S32 argc = 17;
if (dStrlen(a16)==0)
if (dStrlen(a15)==0)
if (dStrlen(a14)==0)
if (dStrlen(a13)==0)
if (dStrlen(a12)==0)
if (dStrlen(a11)==0)
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
else
argc=12;
else
argc=13;
else
argc=14;
else
argc=15;
else
argc=16;
else
argc=17;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
if (argc>5)
arguments.push_back(a5);
if (argc>6)
arguments.push_back(a6);
if (argc>7)
arguments.push_back(a7);
if (argc>8)
arguments.push_back(a8);
if (argc>9)
arguments.push_back(a9);
if (argc>10)
arguments.push_back(a10);
if (argc>11)
arguments.push_back(a11);
if (argc>12)
arguments.push_back(a12);
if (argc>13)
arguments.push_back(a13);
if (argc>14)
arguments.push_back(a14);
if (argc>15)
arguments.push_back(a15);
if (argc>16)
arguments.push_back(a16);
const char** argv = &arguments[0];
{
   object->setConnectArgs(argc - 2, argv + 2);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGameConnection_setJoinPassword(char * x__object, char * x__password)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* password = (const char*)x__password;
{
   object->setJoinPassword(password);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGameConnection_transmitDataBlocks(char * x__object, S32 sequence)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
    // Set the datablock sequence.
    object->setDataBlockSequence(sequence);
    // Store a pointer to the datablock group.
    SimDataBlockGroup* pGroup = Sim::getDataBlockGroup();
    // Determine the size of the datablock group.
    const U32 iCount = pGroup->size();
    // If this is the local client...
    if (GameConnection::getLocalClientConnection() == object)
    {
        // Set up a pointer to the datablock.
        SimDataBlock* pDataBlock = 0;
        // Set up a buffer for the datablock send.
        U8 iBuffer[16384];
        BitStream mStream(iBuffer, 16384);
        // Iterate through all the datablocks...
        for (U32 i = 0; i < iCount; i++)
        {
            // Get a pointer to the datablock in question...
            pDataBlock = (SimDataBlock*)(*pGroup)[i];
            // Set the client's new modified key.
            object->setMaxDataBlockModifiedKey(pDataBlock->getModifiedKey());
            // Pack the datablock stream.
            mStream.setPosition(0);
            mStream.clearCompressionPoint();
            pDataBlock->packData(&mStream);
            // Unpack the datablock stream.
            mStream.setPosition(0);
            mStream.clearCompressionPoint();
            pDataBlock->unpackData(&mStream);
            // Call the console function to set the number of blocks to be sent.
            Con::executef("onDataBlockObjectReceived",  Con::getIntArg(i),Con::getIntArg(iCount));
            // Preload the datablock on the dummy client.
            pDataBlock->preload(false, NetConnection::getErrorBuffer());
        }
        // Get the last datablock (if any)...
        if (pDataBlock)
        {
            // Ensure the datablock modified key is set.
            object->setDataBlockModifiedKey(object->getMaxDataBlockModifiedKey());
            // Ensure that the client knows that the datablock send is done...
            object->sendConnectionMessage(GameConnection::DataBlocksDone, object->getDataBlockSequence());
        }
    } 
    else
    {
        // Otherwise, store the current datablock modified key.
        const S32 iKey = object->getDataBlockModifiedKey();
        // Iterate through the datablock group...
        U32 i = 0;
        for (; i < iCount; i++)
        {
            // If the datablock's modified key has already been set, break out of the loop...
            if (((SimDataBlock*)(*pGroup)[i])->getModifiedKey() > iKey)
            {
                break;
            }
        }
        // If this is the last datablock in the group...
        if (i == iCount)
        {
            // Ensure that the client knows that the datablock send is done...
            object->sendConnectionMessage(GameConnection::DataBlocksDone, object->getDataBlockSequence());
            // Then exit out since nothing else needs to be done.
            return;
        }
        // Set the maximum datablock modified key value.
        object->setMaxDataBlockModifiedKey(iKey);
        // Get the minimum number of datablocks...
        const U32 iMax = getMin(i + DataBlockQueueCount, iCount);
        // Iterate through the remaining datablocks...
        for (;i < iMax; i++)
        {
            // Get a pointer to the datablock in question...
            SimDataBlock* pDataBlock = (SimDataBlock*)(*pGroup)[i];
            // Post the datablock event to the client.
            object->postNetEvent(new SimDataBlockEvent(pDataBlock, i, iCount, object->getDataBlockSequence()));
        }
    }
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGameConnection_activateGhosting(char * x__object)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->activateGhosting();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGameConnection_resetGhosting(char * x__object)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->resetGhosting();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGameConnection_setControlObject(char * x__object, char * x__ctrlObj)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
GameBase* ctrlObj; Sim::findObject(x__ctrlObj, ctrlObj ); 
bool wle_returnObject;
{
   if(!ctrlObj)
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   object->setControlObject(ctrlObj);
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGameConnection_getControlObject(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
GameBase* wle_returnObject;
{
   {wle_returnObject =object->getControlObject();
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGameConnection_isAIControlled(char * x__object)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isAIControlled();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGameConnection_isControlObjectRotDampedCamera(char * x__object)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isControlObjectRotDampedCamera();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGameConnection_play2D(char * x__object, char * x__profile)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
SFXProfile* profile; Sim::findObject(x__profile, profile ); 
bool wle_returnObject;
{
   if(!profile)
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   object->play2D(profile);
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGameConnection_play3D(char * x__object, char * x__profile, char * x__location)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
SFXProfile* profile; Sim::findObject(x__profile, profile ); 
TransformF location = TransformF();
sscanf( x__location,"%f %f %f %f %f %f %f", &location.mPosition.x, &location.mPosition.y, &location.mPosition.z, &location.mOrientation.axis.x, &location.mOrientation.axis.y, &location.mOrientation.axis.z, &location.mOrientation.angle);
bool wle_returnObject;
{
   if(!profile)
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   MatrixF mat = location.getMatrix();
   object->play3D(profile,&mat);
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGameConnection_chaseCam(char * x__object, S32 size)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   if (size != sChaseQueueSize) 
   {
      SAFE_DELETE_ARRAY(sChaseQueue);
      sChaseQueueSize = size;
      sChaseQueueHead = sChaseQueueTail = 0;
      if (size) 
      {
         sChaseQueue = new MatrixF[size];
         {wle_returnObject =true;
return (S32)(wle_returnObject);}
      }
   }
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnGameConnection_getControlCameraDefaultFov(char * x__object)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   F32 fov = 0.0f;
   if(!object->getControlCameraDefaultFov(&fov))
     return (F32)((0.0f));
  return (F32)((fov));
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGameConnection_setControlCameraFov(char * x__object, F32 newFOV)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setControlCameraFov(newFOV);
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnGameConnection_getControlCameraFov(char * x__object)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
   F32 fov = 0.0f;
   if(!object->getControlCameraFov(&fov))
     return (F32)((0.0f));
  return (F32)((fov));
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnGameConnection_getDamageFlash(char * x__object)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getDamageFlash());
};
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnGameConnection_getWhiteOut(char * x__object)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getWhiteOut());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGameConnection_setBlackOut(char * x__object, bool doFade, S32 timeMS)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->setBlackOut(doFade, timeMS);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGameConnection_setMissionCRC(char * x__object, S32 CRC)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   if(object->isConnectionToServer())
      return;
   object->postNetEvent(new SetMissionCRCEvent(CRC));
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGameConnection_delete(char * x__object, char * x__reason)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* reason = (const char*)x__reason;
{
   object->setDisconnectReason(reason);
   object->deleteObject();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGameConnection_startRecording(char * x__object, char * x__fileName)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* fileName = (const char*)x__fileName;
{
   char expFileName[1024];
   Con::expandScriptFilename(expFileName, sizeof(expFileName), fileName);
   object->startDemoRecord(expFileName);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGameConnection_stopRecording(char * x__object)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->stopRecording();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGameConnection_playDemo(char * x__object, char * x__demoFileName)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* demoFileName = (const char*)x__demoFileName;
bool wle_returnObject;
{
   char filename[1024];
   Con::expandScriptFilename(filename, sizeof(filename), demoFileName);
   // Note that calling onConnectionEstablished will change the values in argv!
   object->onConnectionEstablished(true);
   object->setEstablished();
   if(!object->replayDemoRecord(filename))
   {
      Con::printf("Unable to open demo file %s.", filename);
      object->deleteObject();
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   }
   // After demo has loaded, execute the scene re-light the scene
   //SceneLighting::lightScene(0, 0);
   GameConnection::smPlayingDemo.trigger();
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGameConnection_isDemoPlaying(char * x__object)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isPlayingBack();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGameConnection_isDemoRecording(char * x__object)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isRecording();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGameConnection_listClassIDs(char * x__object)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   Con::printf("--------------- Class ID Listing ----------------");
   Con::printf(" id    |   name");
   for(AbstractClassRep *rep = AbstractClassRep::getClassList();
      rep;
      rep = rep->getNextClass())
   {
      ConsoleObject *obj = rep->create();
      if(obj && rep->getClassId(object->getNetClassGroup()) >= 0)
         Con::printf("%7.7d| %s", rep->getClassId(object->getNetClassGroup()), rep->getClassName());
      delete obj;
   }
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGameConnection_setCameraObject(char * x__object, char * x__camera)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
GameBase* camera; Sim::findObject(x__camera, camera ); 
bool wle_returnObject;
{
   if(!camera)
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   object->setCameraObject(camera);
   {wle_returnObject =true;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGameConnection_getCameraObject(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
SimObject* wle_returnObject;
{
   SimObject *obj = dynamic_cast<SimObject*>(object->getCameraObject());
   {wle_returnObject =obj;
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGameConnection_clearCameraObject(char * x__object)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setCameraObject(NULL);
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnGameConnection_isFirstPerson(char * x__object)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   // Note: Transition to first person occurs over time via mCameraPos, so this
   // won't immediately return true after a set.
   {wle_returnObject =object->isFirstPerson();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnGameConnection_setFirstPerson(char * x__object, bool firstPerson)
{
GameConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setFirstPerson(firstPerson);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__dumpProcessList()
{
{
{
   Con::printf( "client process list:" );
   ClientProcessList::get()->dumpToConsole();
   Con::printf( "server process list:" );
   ServerProcessList::get()->dumpToConsole();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPhysicsDebrisData_preload(char * x__object)
{
PhysicsDebrisData* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   String errorStr;
   object->shape = NULL;
   if( !object->preload( false, errorStr ) )
      Con::errorf( "PhsysicsDebrisData::preload - error: %s", errorStr.c_str() );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPhysicsForce_attach(char * x__object, char * x__start, char * x__direction, F32 maxDist)
{
PhysicsForce* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F start = Point3F();
sscanf(x__start,"%f %f %f", &start.x,&start.y,&start.z);
Point3F direction = Point3F();
sscanf(x__direction,"%f %f %f", &direction.x,&direction.y,&direction.z);
{
   object->attach( start, direction, maxDist );
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPhysicsForce_detach(char * x__object, char * x__force)
{
PhysicsForce* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F force = Point3F();
sscanf(x__force,"%f %f %f", &force.x,&force.y,&force.z);
{
   object->detach( force );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPhysicsForce_isAttached(char * x__object)
{
PhysicsForce* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isAttached();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__physicsStartSimulation(char * x__a1)
{
const char* a1 = (const char*)x__a1;
{
S32 argc = 2;
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
const char** argv = &arguments[0];
{
   if ( PHYSICSMGR )
      PHYSICSMGR->enableSimulation( String( argv[1] ), true );
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__physicsStopSimulation(char * x__a1)
{
const char* a1 = (const char*)x__a1;
{
S32 argc = 2;
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
const char** argv = &arguments[0];
{
   if ( PHYSICSMGR )
      PHYSICSMGR->enableSimulation( String( argv[1] ), false );
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fn__physicsSimulationEnabled()
{
bool wle_returnObject;
{
{
   {wle_returnObject =PHYSICSMGR && PHYSICSMGR->isSimulationEnabled();
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fn__physicsGetTimeScale()
{
{
{
  return (F32)( PHYSICSMGR && PHYSICSMGR->getTimeScale());
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__physicsStoreState()
{
{
{
   PhysicsPlugin::getPhysicsResetSignal().trigger( PhysicsResetEvent_Store );
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnPhysicsShape_isDestroyed(char * x__object)
{
PhysicsShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->isDestroyed();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPhysicsShape_destroy(char * x__object)
{
PhysicsShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->destroy();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnPhysicsShape_restore(char * x__object)
{
PhysicsShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->restore();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAITurretShape_addToIgnoreList(char * x__object, char * x__obj)
{
AITurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
ShapeBase* obj; Sim::findObject(x__obj, obj ); 
{
   object->addToIgnoreList(obj);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAITurretShape_removeFromIgnoreList(char * x__object, char * x__obj)
{
AITurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
ShapeBase* obj; Sim::findObject(x__obj, obj ); 
{
   object->removeFromIgnoreList(obj);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAITurretShape_setTurretState(char * x__object, char * x__newState, bool force)
{
AITurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* newState = (const char*)x__newState;

{
   object->setTurretStateName(newState, force);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAITurretShape_activateTurret(char * x__object)
{
AITurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->activateTurret();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAITurretShape_deactivateTurret(char * x__object)
{
AITurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->deactivateTurret();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAITurretShape_startScanForTargets(char * x__object)
{
AITurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->startScanForTargets();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAITurretShape_stopScanForTargets(char * x__object)
{
AITurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->stopScanForTargets();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAITurretShape_startTrackingTarget(char * x__object)
{
AITurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->startTrackingTarget();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAITurretShape_stopTrackingTarget(char * x__object)
{
AITurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->stopTrackingTarget();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnAITurretShape_hasTarget(char * x__object)
{
AITurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->hasTarget();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAITurretShape_getTarget(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
AITurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
SimObject* wle_returnObject;
{
   {wle_returnObject =object->getTarget();
if (!wle_returnObject) 
return;
dSprintf(retval,1024,"%i",wle_returnObject->getId());
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAITurretShape_resetTarget(char * x__object)
{
AITurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->resetTarget();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAITurretShape_setWeaponLeadVelocity(char * x__object, F32 velocity)
{
AITurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setWeaponLeadVelocity(velocity);
}
}
extern "C" __declspec(dllexport) F32  __cdecl wle_fnAITurretShape_getWeaponLeadVelocity(char * x__object)
{
AITurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (F32)( object->getWeaponLeadVelocity());
};
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAITurretShape_setAllGunsFiring(char * x__object, bool fire)
{
AITurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->setAllGunsFiring(fire);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAITurretShape_setGunSlotFiring(char * x__object, S32 slot, bool fire)
{
AITurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;

{
   object->setGunSlotFiring(slot, fire);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnAITurretShape_recenterTurret(char * x__object)
{
AITurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->recenterTurret();
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnTurretShape_getAllowManualRotation(char * x__object)
{
TurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->getAllowManualRotation();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnTurretShape_setAllowManualRotation(char * x__object, bool allow)
{
TurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   return object->setAllowManualRotation(allow);
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnTurretShape_getAllowManualFire(char * x__object)
{
TurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->getAllowManualFire();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnTurretShape_setAllowManualFire(char * x__object, bool allow)
{
TurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   return object->setAllowManualFire(allow);
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnTurretShape_getState(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
TurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
   {wle_returnObject =object->getStateName();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnTurretShape_getTurretEulerRotation(char * x__object,  char* retval)
{
dSprintf(retval,1024,"");
TurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F wle_returnObject;
{
   Point3F euler = object->getTurretRotation();
   
   // Convert to degrees.
   euler.x = mRadToDeg( euler.x );
   euler.y = mRadToDeg( euler.y );
   euler.z = mRadToDeg( euler.z );
   
   {wle_returnObject =euler;
dSprintf(retval,1024,"%f %f %f ",wle_returnObject.x,wle_returnObject.y,wle_returnObject.z);
return;
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnTurretShape_setTurretEulerRotation(char * x__object, char * x__rot)
{
TurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
Point3F rot = Point3F();
sscanf(x__rot,"%f %f %f", &rot.x,&rot.y,&rot.z);
{
   object->setTurretRotation( rot );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnTurretShape_doRespawn(char * x__object)
{
TurretShape* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
   {wle_returnObject =object->doRespawn();
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnFlyingVehicle_useCreateHeight(char * x__object, bool enabled)
{
FlyingVehicle* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
   object->useCreateHeight( enabled );
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnWheeledVehicle_setWheelSteering(char * x__object, S32 wheel, F32 steering)
{
WheeledVehicle* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

bool wle_returnObject;
{
   if ( wheel >= 0 && wheel < object->getWheelCount() ) {
      object->setWheelSteering( wheel, steering );
      {wle_returnObject =true;
return (S32)(wle_returnObject);}
   }
   else
      Con::warnf("setWheelSteering: wheel index %d out of bounds, vehicle has %d hubs",
         wheel, object->getWheelCount());
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnWheeledVehicle_setWheelPowered(char * x__object, S32 wheel, bool powered)
{
WheeledVehicle* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

bool wle_returnObject;
{
   if ( wheel >= 0 && wheel < object->getWheelCount() ) {
      object->setWheelPowered( wheel, powered );
      {wle_returnObject =true;
return (S32)(wle_returnObject);}
   }
   else
      Con::warnf("setWheelPowered: wheel index %d out of bounds, vehicle has %d hubs",
         wheel, object->getWheelCount());
   {wle_returnObject =false;
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnWheeledVehicle_setWheelTire(char * x__object, S32 wheel, char * x__tire)
{
WheeledVehicle* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

WheeledVehicleTire* tire; Sim::findObject(x__tire, tire ); 
bool wle_returnObject;
{
   if (wheel >= 0 && wheel < object->getWheelCount()) {
      object->setWheelTire(wheel,tire);
      {wle_returnObject =true;
return (S32)(wle_returnObject);}
   }
   else {
      Con::warnf("setWheelTire: invalid tire datablock or wheel index, vehicle has %d hubs",
         object->getWheelCount());
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   }
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnWheeledVehicle_setWheelSpring(char * x__object, S32 wheel, char * x__spring)
{
WheeledVehicle* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;

WheeledVehicleSpring* spring; Sim::findObject(x__spring, spring ); 
bool wle_returnObject;
{
   if (spring && wheel >= 0 && wheel < object->getWheelCount()) {
      object->setWheelSpring(wheel,spring);
      {wle_returnObject =true;
return (S32)(wle_returnObject);}
   }
   else {
      Con::warnf("setWheelSpring: invalid spring datablock or wheel index, vehicle has %d hubs",
         object->getWheelCount());
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   }
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnWheeledVehicle_getWheelCount(char * x__object)
{
WheeledVehicle* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  return (S32)( object->getWheelCount());
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnTerrainBlock_save(char * x__object, char * x__fileName)
{
TerrainBlock* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* fileName = (const char*)x__fileName;
bool wle_returnObject;
{
	char filename[256];
	dStrcpy(filename,fileName);
   char *ext = dStrrchr(filename, '.');
   if (!ext || dStricmp(ext, ".ter") != 0)
      dStrcat(filename, ".ter");
   {wle_returnObject =static_cast<TerrainBlock*>(object)->save(filename);
return (S32)(wle_returnObject);}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__enableSamples(char * x__a1, char * x__a2)
{
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   const char* pattern = argv[ 1 ];
   bool state = true;
   if( argc > 2 )
      state = dAtob( argv[ 2 ] );
   Sampler::enableKeys( pattern, state );
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSettings_findFirstValue(char * x__object, char * x__a2, char * x__a3, char * x__a4,  char* retval)
{
dSprintf(retval,4096,"");
Settings* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* wle_returnObject;
{
S32 argc = 5;
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
const char** argv = &arguments[0];
{
	if( argc == 3 )
		{wle_returnObject =object->findFirstValue( argv[2] );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
	else if( argc == 4 )
		{wle_returnObject =object->findFirstValue( argv[2], argv[3] );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
	else if( argc == 5 )
		{wle_returnObject =object->findFirstValue( argv[2], argv[3], argv[4] );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
	else
		{wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSettings_findNextValue(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
Settings* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
{
	{wle_returnObject =object->findNextValue();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSettings_setValue(char * x__object, char * x__a2, char * x__a3)
{
Settings* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   const char *fieldName = StringTable->insert( argv[2] );
   
   if(argc == 3)
      object->setValue( fieldName);
   else if(argc == 4)
      object->setValue( fieldName, argv[3] );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSettings_setDefaultValue(char * x__object, char * x__a2, char * x__a3)
{
Settings* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   const char *fieldName = StringTable->insert( argv[2] );
   object->setDefaultValue( fieldName, argv[3] );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSettings_value(char * x__object, char * x__a2, char * x__a3,  char* retval)
{
dSprintf(retval,4096,"");
Settings* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* wle_returnObject;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   const char *fieldName = StringTable->insert( argv[2] );
   
   if(argc == 3)
      {wle_returnObject =object->value( fieldName );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   if(argc == 4)
      {wle_returnObject =object->value( fieldName, argv[3] );
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSettings_remove(char * x__object, char * x__a2, char * x__a3)
{
Settings* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   // there's a problem with some fields not being removed properly, but works if you run it twice,
   // a temporary solution for now is simply to call the remove twice
	if(argc == 3)
	{
		object->remove( argv[2] );
		object->remove( argv[2] );
	}
	else if(argc == 4)
	{
		object->remove( argv[2], argv[3] );
		object->remove( argv[2], argv[3] );
	}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSettings_write(char * x__object)
{
Settings* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
S32 argc = 2;
{
    
   {wle_returnObject =object->write();
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnSettings_read(char * x__object)
{
Settings* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
bool wle_returnObject;
{
S32 argc = 2;
{
    
   {wle_returnObject =object->read();
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSettings_beginGroup(char * x__object, char * x__a2, char * x__a3)
{
Settings* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   if(argc == 3)
      object->beginGroup( argv[2] );
   if(argc == 4)
	  object->beginGroup( argv[2], dAtob(argv[3]) );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSettings_endGroup(char * x__object)
{
Settings* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
S32 argc = 2;
{
    
   object->endGroup();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSettings_clearGroups(char * x__object)
{
Settings* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
S32 argc = 2;
{
    
   object->clearGroups();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnSettings_getCurrentGroups(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
Settings* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* wle_returnObject;
{
{
   {wle_returnObject =object->getCurrentGroups();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnCompoundUndoAction_addAction(char * x__object, char * x__a2)
{
CompoundUndoAction* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   UndoAction *action;
   if ( Sim::findObject( argv[2], action ) )
      object->addAction( action );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnUndoManager_clearAll(char * x__object)
{
UndoManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->clearAll();
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnUndoManager_getUndoCount(char * x__object)
{
UndoManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
  return (S32)( object->getUndoCount());
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnUndoManager_getUndoName(char * x__object, char * x__a2,  char* retval)
{
dSprintf(retval,4096,"");
UndoManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   {wle_returnObject =object->getUndoName(dAtoi(argv[2]));
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnUndoManager_getUndoAction(char * x__object, char * x__a2)
{
UndoManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   UndoAction * action = object->getUndoAction(dAtoi(argv[2]));
   if ( !action )
     return (S32)( -1);
   
   if ( !action->isProperlyAdded() )
      action->registerObject();
  return (S32)( action->getId());
}
}
;
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnUndoManager_getRedoCount(char * x__object)
{
UndoManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
{
  return (S32)( object->getRedoCount());
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnUndoManager_getRedoName(char * x__object, char * x__a2,  char* retval)
{
dSprintf(retval,4096,"");
UndoManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   {wle_returnObject =object->getRedoName(dAtoi(argv[2]));
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnUndoManager_getRedoAction(char * x__object, char * x__a2)
{
UndoManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   UndoAction * action = object->getRedoAction(dAtoi(argv[2]));
   if ( !action )
     return (S32)( -1);
   if ( !action->isProperlyAdded() )
      action->registerObject();
  return (S32)( action->getId());
}
}
;
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnUndoAction_addToManager(char * x__object, char * x__a2)
{
UndoAction* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   UndoManager *theMan = NULL;
   if(argc == 3)
   {
      SimObject *obj = Sim::findObject(argv[2]);
      if(obj)
         theMan = dynamic_cast<UndoManager*> (obj);
   }
   object->addToManager(theMan);
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnUndoAction_undo(char * x__object)
{
UndoAction* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->undo();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnUndoAction_redo(char * x__object)
{
UndoAction* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->redo();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnUndoManager_undo(char * x__object)
{
UndoManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->undo();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnUndoManager_redo(char * x__object)
{
UndoManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->redo();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnUndoManager_getNextUndoName(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
UndoManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char * wle_returnObject;
{
{
   const char *name = object->getNextUndoName();
   if(!name)
      {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   char *ret = Con::getReturnBuffer(dStrlen(name) + 1);
   dStrcpy(ret, name);
   {wle_returnObject =ret;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnUndoManager_getNextRedoName(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
UndoManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char * wle_returnObject;
{
{
   const char *name = object->getNextRedoName();
   if(!name)
      {wle_returnObject =NULL;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
   char *ret = Con::getReturnBuffer(dStrlen(name) + 1);
   dStrcpy(ret, name);
   {wle_returnObject =ret;
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnUndoManager_pushCompound(char * x__object, char * x__a2,  char* retval)
{
dSprintf(retval,4096,"");
UndoManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   String name;
   if( argc > 2 )
      name = argv[ 2 ];
      
   CompoundUndoAction* action = object->pushCompound( name );
   if( !action )
      {wle_returnObject ="";
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
      
   if( !action->isProperlyAdded() )
      action->registerObject();
      
   {wle_returnObject =action->getIdString();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnUndoManager_popCompound(char * x__object, char * x__a2)
{
UndoManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   if( !object->getCompoundStackDepth() )
   {
      Con::errorf( "%s::popCompound - no compound on stack", argv[ 0 ] );
      return;
   }
   
   bool discard = false;
   if( argc > 2 )
      discard = dAtob( argv[ 2 ] );
   
   object->popCompound( discard );
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnEventManager_registerEvent(char * x__object, char * x__a2)
{
EventManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
bool wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   {wle_returnObject =object->registerEvent( argv[2] );
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnEventManager_unregisterEvent(char * x__object, char * x__a2)
{
EventManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   object->unregisterEvent( argv[2] );
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnEventManager_isRegisteredEvent(char * x__object, char * x__a2)
{
EventManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
bool wle_returnObject;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   {wle_returnObject =object->isRegisteredEvent( argv[2] );
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnEventManager_postEvent(char * x__object, char * x__a2, char * x__a3)
{
EventManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
bool wle_returnObject;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   if( !object->getMessageQueue() || !object->getMessageQueue()[ 0 ] )
   {
      Con::errorf( "EventManager::postEvent - No queue name set on EventManager" );
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =object->postEvent( argv[2], argc > 3 ? argv[3] : "" );
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnEventManager_subscribe(char * x__object, char * x__a2, char * x__a3, char * x__a4)
{
EventManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
bool wle_returnObject;
{
S32 argc = 5;
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
if (argc>4)
arguments.push_back(a4);
const char** argv = &arguments[0];
{
   // Find the listener object.
   SimObject *cbObj = dynamic_cast<SimObject *>(Sim::findObject(argv[2]));
   if( cbObj == NULL )
   {
      Con::warnf( "EventManager::subscribe - Invalid listener." );
      {wle_returnObject =false;
return (S32)(wle_returnObject);}
   }
   {wle_returnObject =object->subscribe( cbObj, argv[3], argc > 4 ? argv[4] : NULL );
return (S32)(wle_returnObject);}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnEventManager_remove(char * x__object, char * x__a2, char * x__a3)
{
EventManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
{
S32 argc = 4;
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
else
argc=4;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
if (argc>3)
arguments.push_back(a3);
const char** argv = &arguments[0];
{
   // Find the listener object.
   SimObject * listener = dynamic_cast< SimObject * >( Sim::findObject( argv[2] ) );
   if( listener )
      object->remove( listener, argv[3] );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnEventManager_removeAll(char * x__object, char * x__a2)
{
EventManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   // Find the listener object.
   SimObject * listener = dynamic_cast< SimObject * >( Sim::findObject( argv[2] ) );
   if( listener )
      object->removeAll( listener );
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnEventManager_dumpEvents(char * x__object)
{
EventManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->dumpEvents();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnEventManager_dumpSubscribers(char * x__object, char * x__a2)
{
EventManager* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char* a2 = (const char*)x__a2;
{
S32 argc = 3;
if (dStrlen(a2)==0)
argc=2;
else
argc=3;
std::vector<const char*> arguments;
arguments.push_back("");
arguments.push_back("");
if (argc>2)
arguments.push_back(a2);
const char** argv = &arguments[0];
{
   if( argc > 2 )
      object->dumpSubscribers( argv[2] );
   else
      object->dumpSubscribers();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMessage_getType(char * x__object,  char* retval)
{
dSprintf(retval,4096,"");
Message* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
const char * wle_returnObject;
{
{
   {wle_returnObject =object->getType();
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMessage_addReference(char * x__object)
{
Message* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->addReference();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fnMessage_freeReference(char * x__object)
{
Message* object; Sim::findObject(x__object, object ); 
if (!object)
	return;
{
{
   object->freeReference();
}
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn__dnEval_Direct_New(char * x__a1, char * x__a2, char * x__a3, char * x__a4, char * x__a5, char * x__a6, char * x__a7, char * x__a8, char * x__a9, char * x__a10, char * x__a11, char * x__a12, char * x__a13, char * x__a14, char * x__a15, char * x__a16, char * x__a17, char * x__a18, char * x__a19,  char* retval)
{
dSprintf(retval,4096,"");
const char* a1 = (const char*)x__a1;
const char* a2 = (const char*)x__a2;
const char* a3 = (const char*)x__a3;
const char* a4 = (const char*)x__a4;
const char* a5 = (const char*)x__a5;
const char* a6 = (const char*)x__a6;
const char* a7 = (const char*)x__a7;
const char* a8 = (const char*)x__a8;
const char* a9 = (const char*)x__a9;
const char* a10 = (const char*)x__a10;
const char* a11 = (const char*)x__a11;
const char* a12 = (const char*)x__a12;
const char* a13 = (const char*)x__a13;
const char* a14 = (const char*)x__a14;
const char* a15 = (const char*)x__a15;
const char* a16 = (const char*)x__a16;
const char* a17 = (const char*)x__a17;
const char* a18 = (const char*)x__a18;
const char* a19 = (const char*)x__a19;
const char * wle_returnObject;
{
S32 argc = 20;
if (dStrlen(a19)==0)
if (dStrlen(a18)==0)
if (dStrlen(a17)==0)
if (dStrlen(a16)==0)
if (dStrlen(a15)==0)
if (dStrlen(a14)==0)
if (dStrlen(a13)==0)
if (dStrlen(a12)==0)
if (dStrlen(a11)==0)
if (dStrlen(a10)==0)
if (dStrlen(a9)==0)
if (dStrlen(a8)==0)
if (dStrlen(a7)==0)
if (dStrlen(a6)==0)
if (dStrlen(a5)==0)
if (dStrlen(a4)==0)
if (dStrlen(a3)==0)
if (dStrlen(a2)==0)
if (dStrlen(a1)==0)
argc=1;
else
argc=2;
else
argc=3;
else
argc=4;
else
argc=5;
else
argc=6;
else
argc=7;
else
argc=8;
else
argc=9;
else
argc=10;
else
argc=11;
else
argc=12;
else
argc=13;
else
argc=14;
else
argc=15;
else
argc=16;
else
argc=17;
else
argc=18;
else
argc=19;
else
argc=20;
std::vector<const char*> arguments;
arguments.push_back("");
if (argc>=2)
arguments.push_back(a1);
if (argc>=3)
arguments.push_back(a2);
if (argc>=4)
arguments.push_back(a3);
if (argc>=5)
arguments.push_back(a4);
if (argc>=6)
arguments.push_back(a5);
if (argc>=7)
arguments.push_back(a6);
if (argc>=8)
arguments.push_back(a7);
if (argc>=9)
arguments.push_back(a8);
if (argc>=10)
arguments.push_back(a9);
if (argc>=11)
arguments.push_back(a10);
if (argc>=12)
arguments.push_back(a11);
if (argc>=13)
arguments.push_back(a12);
if (argc>=14)
arguments.push_back(a13);
if (argc>=15)
arguments.push_back(a14);
if (argc>=16)
arguments.push_back(a15);
if (argc>=17)
arguments.push_back(a16);
if (argc>=18)
arguments.push_back(a17);
if (argc>=19)
arguments.push_back(a18);
if (argc>=20)
arguments.push_back(a19);
const char** argv = &arguments[0];
{
	{wle_returnObject =cs_Instance_Eval_Direct_New(argc,argv);
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
arguments.clear();
}
}
extern "C" __declspec(dllexport) void  __cdecl wle_fn_dnEval(char * x__script,  char* retval)
{
dSprintf(retval,4096,"");
const char* script = (const char*)x__script;
const char * wle_returnObject;
{
	{wle_returnObject =cs_Instance_Eval(script);
if (!wle_returnObject) 
return;
dSprintf(retval,4096,"%s",wle_returnObject);
return;
}
}
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnNetConnection_GetGhostIndex(char * x__object, char * x__obj)
{
NetConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
NetObject* obj; Sim::findObject(x__obj, obj ); 
{
  if (obj)
   return (S32)( object->getGhostIndex(obj));
 return (S32)( 0);
};
}
extern "C" __declspec(dllexport) S32  __cdecl wle_fnNetConnection_ResolveGhost(char * x__object, int ghostIndex)
{
NetConnection* object; Sim::findObject(x__object, object ); 
if (!object)
	return 0;
{
  if (ghostIndex != -1)
  {
    NetObject* pObject = NULL;
    if( object->isGhostingTo())
      pObject = object->resolveGhost(ghostIndex);
    else if( object->isGhostingFrom())
      pObject = object->resolveObjectFromGhostIndex(ghostIndex);
    if (pObject)
     return (S32)( pObject->getId());
  } 
 return (S32)( 0);
};
}

