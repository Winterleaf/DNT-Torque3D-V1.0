// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNT or DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to DNT or DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.
// 
// Last updated: 10/18/2012
// 

#region

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using WinterLeaf.Classes;
using WinterLeaf.Containers;

#endregion

namespace WinterLeaf
    {
    public sealed partial class dnTorque
        {
        #region Console

        internal void SetFullScreen(bool On)
            {
            NativeMethods.FakeFullScreen(torque_gethwnd(), On);
            }

        internal IntPtr _torque_gethwnd()
            {
            return SafeNativeMethods.mtorque_gethwnd();
            }

        ///// <summary>
        /////   This object is used to control threaded access inside of Evaluate, Thread safety.
        ///// </summary>
        //private readonly object _evallock = new object();

        /// <summary>
        ///   Removes the tagged string from Torque.
        /// </summary>
        /// <param name="tag"> </param>
        internal void _removeTaggedString(string tag)
            {
            StringBuilder sb = new StringBuilder(tag, 1024);

            SafeNativeMethods.mremoveTaggedString(sb);
            }

        /// <summary>
        ///   This function evaluates a script block and returns the value, It is a carry over and now the Util.eval should be used.
        /// </summary>
        /// <param name="script"> </param>
        /// <param name="returnmeaval"> </param>
        /// <returns> </returns>
        internal string Evaluate(string script, bool returnmeaval)
            {
            if (!script.Trim().EndsWith("}"))

                if (!script.Trim().EndsWith(";"))

                    script = script.Trim() + ";";

            script = script.Trim();

            if (script.Length > 16384)

                throw new Exception("Script Block Exceeds 16k characters");

            string result = "";

            // lock (_evallock)
                {
                string varnam = "$IReallyUniqueForthisWorkAround12365412v";

                SetVar(varnam, "0");

                bool dovalcatch = false;

                if ((script.Contains('=')) || !returnmeaval)

                    dovalcatch = false;

                else
                    {
                    if (script.Contains("[") || script.Contains("("))

                        dovalcatch = true;
                    }


                if (dovalcatch)
                    {
                    script = varnam + "=" + script;

                    try
                        {


                            {
                            StringBuilder s = new StringBuilder(script, 65536);

                            StringBuilder r = new StringBuilder(4096);

                            SafeNativeMethods.mConsoleCall(s, r, Debugging);

                            result = GetVar(varnam);
                            }
                        }
                    catch (Exception err)
                        {
                        Error("Evaluate failed: " + err.StackTrace);
                        }
                    }

                else
                    {
                    try
                        {


                            {
                            StringBuilder s = new StringBuilder(script, 65536);

                            StringBuilder r = new StringBuilder(4096);

                            SafeNativeMethods.mConsoleCall(s, r, Debugging);

                            result = r.ToString().Trim();
                            }
                        }
                    catch (Exception err)
                        {
                        Error("Evaluate failed: " + err.StackTrace);
                        }
                    }
                }
            return result;
            }

        /// <summary>
        ///   Gets a tagged string object from torque.
        /// </summary>
        /// <param name="tag"> </param>
        /// <returns> </returns>
        internal string GetTaggedString(string tag)
            {
            StringBuilder t = new StringBuilder(tag, 1024);

            StringBuilder ret = new StringBuilder(4096);

            SafeNativeMethods.mgetTaggedString(t, ret);

            return ret.ToString();
            }

        //Handles getting variables from the engine.

        /// <summary>
        ///   Adds the passed string to the Torques Tagged String list.
        /// </summary>
        /// <param name="mystring"> </param>
        /// <returns> </returns>
        internal string AddTaggedString(string mystring)
            {
            //fun days...
            //we need to encode colors.
            StringBuilder newstring = new StringBuilder();

            for (int i = 0; i < mystring.Length; i++)
                {
                if (mystring[i] == '\\')
                    {
                    if ((mystring[i + 1] == 'c') || (mystring[i + 1] == 'C'))
                        {
                        switch (mystring[i + 2])
                            {
                                case '0':

                                    newstring.Append((char) 2);

                                    newstring.Append((char) 1);

                                    i = i + 2;

                                    break;

                                case '1':

                                    newstring.Append((char) 2);

                                    i = i + 2;

                                    break;

                                case '2':

                                    newstring.Append((char) 3);

                                    i = i + 2;

                                    break;

                                case '3':

                                    newstring.Append((char) 4);

                                    i = i + 2;

                                    break;

                                case '4':

                                    newstring.Append((char) 5);

                                    i = i + 2;

                                    break;

                                case '5':

                                    newstring.Append((char) 6);

                                    i = i + 2;

                                    break;

                                case '6':

                                    newstring.Append((char) 7);

                                    i = i + 2;

                                    break;

                                case '7':

                                    newstring.Append((char) 11);

                                    i = i + 2;

                                    break;

                                case '8':

                                    newstring.Append((char) 12);

                                    i = i + 2;

                                    break;

                                case '9':

                                    newstring.Append((char) 14);

                                    i = i + 2;

                                    break;

                                default:

                                    newstring.Append(mystring[i]);

                                    break;
                            }
                        }

                    else

                        newstring.Append(mystring[i]);
                    }
                else
                    {
                    newstring.Append(mystring[i]);
                    }
                }

            StringBuilder ms = new StringBuilder(newstring.ToString(), 4096);

            if (mystring.Length > 4096)

                throw new Exception("String exceed length of 4096");

            StringBuilder r = new StringBuilder(4096);

            SafeNativeMethods.maddTaggedString(ms, r);

            string rr = r.ToString();

            return rr;
            }

        /// <summary>
        ///   Posts a message inside of the Torque console as a warning.
        /// </summary>
        /// <param name="message"> </param>
        internal void Warn(string message)
            {
            if (message.Length > 4096)

                throw new Exception("Message Length exceeds 4096 characters");

            StringBuilder s = new StringBuilder(message, 4096);

            SafeNativeMethods.mConsole_warnf(s);
            }

        /// <summary>
        ///   Posts a message inside of the Troque console as a Print.
        /// </summary>
        /// <param name="message"> </param>
        internal void Print(string message)
            {
            if (message.Length > 4096)

                throw new Exception("Message Length exceeds 4096 characters");

            StringBuilder s = new StringBuilder(message, 4096);

            SafeNativeMethods.mConsole_printf(s);
            }

        /// <summary>
        ///   Posts a message inside of the Torque console as a Error.
        /// </summary>
        /// <param name="message"> </param>
        internal void Error(string message)
            {
            if (message.Length > 4096)

                throw new Exception("Message Length exceeds 4096 characters");

            StringBuilder s = new StringBuilder(message, 4096);

            SafeNativeMethods.mConsole_errorf(s);
            }

        /// <summary>
        ///   Deletes the variable from Torques Memory.
        /// </summary>
        /// <param name="global_variable"> </param>
        internal void DeleteVariables(string global_variable)
            {
            StringBuilder sb = new StringBuilder(global_variable, 4096);

            SafeNativeMethods.mdeleteVariables(sb);
            }

        /// <summary>
        ///   Returns true or false if the object passed has the function.
        /// </summary>
        /// <param name="simobject"> </param>
        /// <param name="method"> </param>
        /// <returns> </returns>
        internal bool ObjectHasMethod(string simobject, string method)
            {
            if (simobject.Contains('.'))
                simobject = GetVar(simobject);

            StringBuilder s = new StringBuilder(simobject, 4096);

            StringBuilder m = new StringBuilder(method, 4096);

            bool r = SafeNativeMethods.mobjectHasMethod(s, m);

            return r;
            }

        /// <summary>
        ///   Returns true or false if the function exists inside of Torque.
        /// </summary>
        /// <param name="function_name"> </param>
        /// <returns> </returns>
        internal bool IsFunction(string function_name)
            {
            if (function_name.Length > 4096)

                throw new Exception("Function name exceeds 4096");

            StringBuilder sb = new StringBuilder(function_name, 4096);

            bool result = SafeNativeMethods.misFunction(sb);

            return result;
            }

        /// <summary>
        ///   Gets the ID (UINT32) of the object passed.
        /// </summary>
        /// <param name="simobj_id"> </param>
        /// <returns> </returns>
        internal UInt32 GetObjectID(string simobj_id)
            {
            if (simobj_id.Contains('.'))
                simobj_id = GetVar(simobj_id);

            StringBuilder ss = new StringBuilder(simobj_id, 4096);

            UInt32 id = SafeNativeMethods.mGetObjectID(ss);

            return id;
            }


        /// <summary>
        ///   Calls PathOnMissionLoadDone inside of Torque
        /// </summary>
        internal void PathOnMissionLoadDone()
            {
            SafeNativeMethods.mpathOnMissionLoadDone();
            }

        /// <summary>
        ///   Calls ClearServerPaths inside of Torque
        /// </summary>
        internal void ClearServerPaths()
            {
            SafeNativeMethods.mclearServerPaths();
            }


        /// <summary>
        ///   Returns the datablock id to the passed simobject.
        /// </summary>
        /// <param name="simobject"> </param>
        /// <returns> </returns>
        internal UInt32 GetDatablock(string simobject)
            {
            if (simobject.Contains('.'))
                simobject = GetVar(simobject);
            StringBuilder sb = new StringBuilder(simobject, 4096);
            return SafeNativeMethods.mgetDataBlock(sb);
            }


        /// <summary>
        ///   Gets the name of the object passed, usually the ID of an object.
        /// Note this function accepts compound simobjects... 
        /// 
        /// i.e. 
        /// player.client
        /// 1233.client.3
        /// 123.3.3
        ///  
        /// </summary>
        /// <param name="simobject"> </param>
        /// <returns> </returns>
        internal string GetName(string simobject)
            {
            if ((simobject.StartsWith("$")) || (!simobject.Contains('.')))

                return _getName_(simobject);

            string[] parts = simobject.Split('.');
            string v1 = parts[0];

            for (int i = 1; i <= parts.GetUpperBound(0); i++)
                {
                if (parts[i].Trim() == "")
                    continue;

                v1 = __GetVar(v1 + "." + parts[i]);

                if (v1 == "")

                    break;
                }

            return v1.Trim() != "" ? _getName_(v1) : "";
            }

        private string _getName_(string simobject)
            {
            string itemname = simobject;

            if (simobject.IsNumeric())
                {
                StringBuilder re = new StringBuilder(4096);

                SafeNativeMethods.mgetName(simobject.AsUint(), re);

                itemname = re.ToString().Trim();
                }

            return itemname;
            }

        /// <summary>
        ///   Gets the ID of the name passed.
        /// </summary>
        /// <param name="name"> </param>
        /// <returns> </returns>
        internal Int32 NameToId(string name)
            {
            StringBuilder n = new StringBuilder(name, 4096);

            Int32 r = SafeNativeMethods.mnameToID(n);

            return r;
            }

        /// <summary>
        ///   Determines if the classname is a member of the superclassname
        /// </summary>
        /// <param name="classname"> </param>
        /// <param name="superclassname"> </param>
        /// <returns> </returns>
        internal bool IsMemberOfClass(string classname, string superclassname)
            {
            if (classname.Length > 4096)

                throw new Exception("Classname exceeds 4096 characters");

            if (superclassname.Length > 4096)

                throw new Exception("SuperClassName exceeds 4096");

            StringBuilder cs = new StringBuilder(classname, 4096);

            StringBuilder scn = new StringBuilder(superclassname, 4096);

            bool r = SafeNativeMethods.misMemberOfClass(cs, scn);

            return r;
            }

        /// <summary>
        ///   Calls Torque's spawn object code.
        /// </summary>
        /// <param name="spawnClass"> </param>
        /// <param name="spawnDataBlock"> </param>
        /// <param name="spawnName"> </param>
        /// <param name="spawnProperties"> </param>
        /// <param name="spawnScript"> </param>
        /// <returns> </returns>
        internal UInt32 SpawnObject(string spawnClass, string spawnDataBlock, string spawnName, string spawnProperties, string spawnScript)
            {
            StringBuilder sc = new StringBuilder(spawnClass, 4096);

            StringBuilder spb = new StringBuilder(spawnDataBlock, 4096);

            StringBuilder sn = new StringBuilder(spawnName, 4096);

            StringBuilder sp = new StringBuilder(spawnProperties, 4096);

            StringBuilder ss = new StringBuilder(spawnScript, 4096);

            UInt32 result = 0;

            result = SafeNativeMethods.mspawnObject(sc, spb, sn, sp, ss);

            return result;
            }

        /// <summary>
        ///   Gets the classname of the simobject.
        /// </summary>
        /// <param name="simobject"> </param>
        /// <returns> </returns>
        internal string GetClassName(string simobject)
            {
            StringBuilder so = new StringBuilder(simobject, 4096);

            StringBuilder ret = new StringBuilder(4096);

            SafeNativeMethods.mgetClassName(so, ret);

            return ret.ToString();
            }


        /// <summary>
        ///   Calls a function on a object in a parent package for the object. So.. function AIPlayer::something(%this) { Parent::SomeThing(%this); }
        /// </summary>
        /// <param name="simobject"> </param>
        /// <param name="function"> </param>
        /// <param name="namespacedepth"> How many parents to go up. </param>
        /// <param name="parameters"> </param>
        /// <param name="donotpassdepth"> Use this flag, when the parent being called is a C++ function. </param>
        /// <returns> </returns>
        internal string ConsoleCallParent(string simobject, string function, int namespacedepth, string[] parameters, bool donotpassdepth = false)
            {
            if (simobject.Contains('.'))
                simobject = GetVar(simobject);

            StringBuilder so = new StringBuilder(simobject, 1024);

            StringBuilder f = new StringBuilder(function, 1024);

            StringBuilder ret = new StringBuilder("", 1024);

            List<IntPtr> myp = new List<IntPtr>();

            string[] newparams = new string[parameters.GetUpperBound(0) + (donotpassdepth ? 2 : 3)];

            newparams[0] = "";

            if (!donotpassdepth)

                newparams[parameters.GetUpperBound(0) + 2] = namespacedepth.ToString(CultureInfo.InvariantCulture);

            int c = 1;

            foreach (string p in parameters)
                {
                if (parameters[c - 1] == "")

                    newparams[c] = " ";

                else

                    newparams[c] = parameters[c - 1];

                c++;
                }

            myp.AddRange(newparams.Select(Marshal.StringToCoTaskMemAnsi));

            SafeNativeMethods.mParentCall(so, f, namespacedepth, ret, myp.Count, myp.ToArray(), Debugging);

            foreach (IntPtr ptr in myp)

                Marshal.FreeCoTaskMem(ptr);

            return ret.ToString();
            }

        /// <summary>
        ///   Calls a parent function to a global function.
        /// </summary>
        /// <param name="function"> </param>
        /// <param name="namespacedepth"> </param>
        /// <param name="parameters"> </param>
        /// <param name="DoNotPassDepth"> </param>
        /// <returns> </returns>
        internal string ConsoleCallParent(string function, int namespacedepth, string[] parameters, bool DoNotPassDepth = false)
            {
            StringBuilder f = new StringBuilder(function, 1024);

            StringBuilder ret = new StringBuilder("", 1024);

            List<IntPtr> myp = new List<IntPtr>();

            string[] newparams = new string[parameters.GetUpperBound(0) + (DoNotPassDepth ? 2 : 3)];

            newparams[0] = "";

            if (!DoNotPassDepth)

                newparams[parameters.GetUpperBound(0) + 2] = namespacedepth.ToString(CultureInfo.InvariantCulture);

            int c = 1;

            foreach (string p in parameters)
                {
                if (parameters[c - 1] == "")

                    newparams[c] = " ";

                else

                    newparams[c] = parameters[c - 1];

                c++;
                }

            myp.AddRange(newparams.Select(Marshal.StringToCoTaskMemAnsi));

            SafeNativeMethods.mParentCallFunct(f, namespacedepth, ret, myp.Count, myp.ToArray(), Debugging);

            foreach (IntPtr ptr in myp)

                Marshal.FreeCoTaskMem(ptr);

            return ret.ToString();
            }

        /// <summary>
        ///   This function is a generic handler for the Object::Function() syntax. The classname is really a misnomer since it can be a classname, package or simobject.
        /// </summary>
        /// <param name="classname"> </param>
        /// <param name="function"> </param>
        /// <param name="parameters"> </param>
        /// <returns> </returns>
        internal string ConsoleCallCn(string classname, string function, string[] parameters)
            {
            StringBuilder cn = new StringBuilder(classname);

            StringBuilder f = new StringBuilder(function, 1024);

            StringBuilder ret = new StringBuilder("", 1024);

            List<IntPtr> myp = new List<IntPtr>();

            string[] newparams = new string[parameters.GetUpperBound(0) + 3];

            newparams[0] = "";

            int c = 1;

            foreach (string p in parameters)
                {
                if (parameters[c - 1] == "")

                    newparams[c] = " ";

                else

                    newparams[c] = parameters[c - 1];

                c++;
                }

            myp.AddRange(newparams.Select(Marshal.StringToCoTaskMemAnsi));

            SafeNativeMethods.mClassname_Call(cn, f, myp.Count, myp.ToArray(), ret, Debugging);

            foreach (IntPtr ptr in myp)

                Marshal.FreeCoTaskMem(ptr);

            return ret.ToString();
            }

        /// <summary>
        ///   Sends the command to client just like TorqueScript's function.
        /// </summary>
        /// <param name="client"> </param>
        /// <param name="function"> </param>
        /// <param name="parameters"> </param>
        internal void CommandToClient(string client, string function, string[] parameters)
            {
            if (client.LastIndexOf('.') > 0)

                client = _GetVar(client);

            function = (byte) function[0] == (byte) 1 ? function : AddTaggedString(function);

            string[] newparams = new string[parameters.GetUpperBound(0) + 4];

            newparams[0] = "CommandToClient";

            newparams[1] = client;

            newparams[2] = function;

            int c = 3;

            foreach (string p in parameters)
                {
                if (parameters[c - 3] == "")

                    newparams[c] = " ";

                else
                    {
                    newparams[c] = parameters[c - 3];

                    if (parameters[c - 3].ToLower() == "true")

                        newparams[c] = "1";

                    if (parameters[c - 3].ToLower() == "false")

                        newparams[c] = "0";
                    }

                c++;
                }

            List<IntPtr> myp = new List<IntPtr>();

            myp.AddRange(newparams.Select(Marshal.StringToCoTaskMemAnsi));

            SafeNativeMethods.mcommandToClient(myp.Count, myp.ToArray());

            foreach (IntPtr ptr in myp)

                Marshal.FreeCoTaskMem(ptr);
            }

        /// <summary>
        ///   Sends a command to the server just like the TorqueScript function.
        /// </summary>
        /// <param name="function"> </param>
        /// <param name="parameters"> </param>
        internal void CommandToServer(string function, string[] parameters)
            {
            function = (byte) function[0] == (byte) 1 ? function : AddTaggedString(function);

            string[] newparams = new string[parameters.GetUpperBound(0) + 3];

            newparams[0] = "CommandToServer";

            newparams[1] = function;

            int c = 2;

            foreach (string p in parameters)
                {
                if (parameters[c - 2] == "")

                    newparams[c] = " ";

                else

                    newparams[c] = parameters[c - 2];

                if (parameters[c - 2].ToLower() == "true")

                    newparams[c] = "1";

                if (parameters[c - 2].ToLower() == "false")

                    newparams[c] = "0";

                c++;
                }

            List<IntPtr> myp = new List<IntPtr>();

            myp.AddRange(newparams.Select(Marshal.StringToCoTaskMemAnsi));

            SafeNativeMethods.mcommandToServer(myp.Count, myp.ToArray());

            foreach (IntPtr ptr in myp)

                Marshal.FreeCoTaskMem(ptr);
            }

        /// <summary>
        ///   Returns the simtime from Torque.
        /// </summary>
        /// <returns> </returns>
        internal int ConsoleGetSimTime()
            {
            return SafeNativeMethods.mConsole_getSimTime();
            }

        /// <summary>
        ///   Determines if the id or name passed is an object. Note: handles player.client
        /// </summary>
        /// <param name="simobjectid"> </param>
        /// <returns> </returns>
        internal bool IsObject(string simobjectid)
            {
            if (simobjectid.IndexOf('.') > 1)

                simobjectid = GetVar(simobjectid);

            if (simobjectid == "0")

                return false;

            else
                {
                StringBuilder sod = new StringBuilder(simobjectid, 4096);

                return SafeNativeMethods.misObject(sod);
                }
            }

        /// <summary>
        ///   Determines if the simobject has the field passed.
        /// </summary>
        /// <param name="simobjectId"> </param>
        /// <param name="fieldname"> </param>
        /// <returns> </returns>
        internal bool SimObjectIsField(string simobjectId, string fieldname)
            {
            if (simobjectId.Contains('.'))
                simobjectId = GetVar(simobjectId);

            StringBuilder sb = new StringBuilder(simobjectId, 1024);

            StringBuilder fn = new StringBuilder(fieldname, 1024);

            bool r = false;

            r = SafeNativeMethods.mSimObject_isField(sb, fn);

            return r;
            }

        /// <summary>
        ///   Determines if the namespace passed has the function.
        /// </summary>
        /// <param name="namespaceorObject"> </param>
        /// <param name="method"> </param>
        /// <returns> </returns>
        internal bool NameSpaceIsMethod(string namespaceorObject, string method)
            {
            StringBuilder sb = new StringBuilder(namespaceorObject, 1024);

            StringBuilder m = new StringBuilder(method, 1024);

            bool r = SafeNativeMethods.mNameSpace_isMethod(sb, m);

            return r;
            }


        internal bool NameSpaceIsInNamespaceHierarchy(string simobjectId, string name)
            {
            StringBuilder sb = new StringBuilder(simobjectId, 1024);

            StringBuilder n = new StringBuilder(name, 1024);

            return SafeNativeMethods.mNameSpace_isInNamespaceHierarchy(sb, n);
            }


        /// <summary>
        ///   Customized container radius search which returns a list of simobject ID's in the radius.
        /// </summary>
        /// <param name="p"> </param>
        /// <param name="searchradius"> </param>
        /// <param name="searchmask"> </param>
        /// <param name="useclientcontainer"> </param>
        /// <returns> </returns>
        internal List<UInt32> ContainerRadiusSearch(Point3F p, double searchradius, UInt32 searchmask, bool useclientcontainer)
            {
            uint[] foundid = new UInt32[100];

            List<uint> lid = new List<uint>();

            Int32 countof = SafeNativeMethods.mContainerRadiusSearch(p.x, p.y, p.z,(float) searchradius, searchmask, useclientcontainer, foundid);

            if (countof > 0)

                for (int i = 0; i < foundid.GetUpperBound(0); i++)

                    lid.Add(foundid[i]);


            return lid;
            }

        #region GetVar

        /// <summary>
        /// 
        /// </summary>
        /// <param name="variable"></param>
        /// <returns></returns>
        internal string GetVar(string variable)
            {
            return _GetVar(variable);
            }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="variable"></param>
        /// <returns></returns>
        private string _GetVar(string variable)
            {
            variable = variable.Trim();

            if (variable == "")

                return "";

            if ((variable[0] == '$') || !variable.Contains('.'))

                return __GetVar(variable);

            #region Compound Variable

            string[] stack = variable.Split('.');

            string result = "";

            result = stack[0];

            int counter = 1;

            int stackupperbound = stack.GetUpperBound(0);

            while (counter <= stackupperbound)
                {
                string fieldname = stack[counter];

                counter++;

                int index = -1;

                if (fieldname.Contains("["))
                    {
                    string[] indexes = fieldname.Split('[');

                    string indexv = indexes[1].Replace("]", "");

                    if (indexv.IsNumeric())
                        {
                        index = indexv.AsInt();

                        fieldname = indexes[0];
                        }
                    else

                        fieldname = fieldname.Replace("[", "").Replace("]", "");
                    }

                result = fn_SimObject_getFieldValue(result, fieldname, index);
                }

            #endregion

            return result;
            }


        private string __GetVar(string variable)
            {
            if (variable.Length > 4096)

                throw new Exception("Variable Name exceeds 4096 characters.");

            string result = "";

            StringBuilder s = new StringBuilder(variable.Replace("[", "").Replace("]", ""), 4096);

            StringBuilder r = new StringBuilder(4096);

            SafeNativeMethods.mcs_torque_getvariable(s, r);

            result = r.ToString().Trim();

            if (Debugging)

                Console.WriteLine("Requested Variable:'" + s + "' Response was:'" + result + "'");

            return result;
            }

        #endregion

        #region SetVar

        #region

        internal void SetVar(string variable, Int16 value)
            {
            _SetVar(variable, value.ToString(CultureInfo.InvariantCulture));
            }

        internal void SetVar(string variable, Int32 value)
            {
            _SetVar(variable, value.ToString(CultureInfo.InvariantCulture));
            }

        internal void SetVar(string variable, Int64 value)
            {
            _SetVar(variable, value.ToString());
            }

        internal void SetVar(string variable, UInt16 value)
            {
            _SetVar(variable, value.ToString(CultureInfo.InvariantCulture));
            }

        internal void SetVar(string variable, UInt32 value)
            {
            _SetVar(variable, value.ToString(CultureInfo.InvariantCulture));
            }

        internal void SetVar(string variable, UInt64 value)
            {
            _SetVar(variable, value.ToString(CultureInfo.InvariantCulture));
            }

        internal void SetVar(string variable, bool value)
            {
            _SetVar(variable, value.ToString(CultureInfo.InvariantCulture));
            }

        internal void SetVar(UInt32 variable, string value)
            {
            _SetVar(variable.ToString(CultureInfo.InvariantCulture), value);
            }

        internal void SetVar(UInt32 variable, Int16 value)
            {
            _SetVar(variable.ToString(CultureInfo.InvariantCulture), value.ToString(CultureInfo.InvariantCulture));
            }

        internal void SetVar(UInt32 variable, Int32 value)
            {
            _SetVar(variable.ToString(CultureInfo.InvariantCulture), value.ToString(CultureInfo.InvariantCulture));
            }

        internal void SetVar(UInt32 variable, Int64 value)
            {
            _SetVar(variable.ToString(CultureInfo.InvariantCulture), value.ToString(CultureInfo.InvariantCulture));
            }

        internal void SetVar(UInt32 variable, UInt16 value)
            {
            _SetVar(variable.ToString(CultureInfo.InvariantCulture), value.ToString(CultureInfo.InvariantCulture));
            }

        internal void SetVar(UInt32 variable, UInt32 value)
            {
            _SetVar(variable.ToString(CultureInfo.InvariantCulture), value.ToString(CultureInfo.InvariantCulture));
            }

        internal void SetVar(UInt32 variable, UInt64 value)
            {
            _SetVar(variable.ToString(CultureInfo.InvariantCulture), value.ToString(CultureInfo.InvariantCulture));
            }

        internal void SetVar(UInt32 variable, bool value)
            {
            _SetVar(variable.ToString(CultureInfo.InvariantCulture), value.ToString(CultureInfo.InvariantCulture));
            }

        internal void SetVar(string variable, string value)
            {
            _SetVar(variable, value);
            }

        #endregion

        private void _SetVar(string variable, string value)
            {
            if (variable.StartsWith("$") || (!variable.Contains('.')))
                {
                __SetVar(variable, value);

                return;
                }

            #region variable is compound i.e. %varname.test.t

            string[] parts = variable.Split('.');

            string leftMostSimObject = parts[0];

            for (int i = 1; i <= parts.GetUpperBound(0) - 1; i++)
                {
                if (parts[i].Trim() == "")
                    continue;

                leftMostSimObject = _GetVar(leftMostSimObject + "." + parts[i]);

                if (leftMostSimObject == "")

                    break;
                }


            if (leftMostSimObject.Trim() == "")
                return;


            string property = parts[parts.GetUpperBound(0)]; //grabs client

            int index = -1;

            if (property.Contains('['))
                {
                string[] pstack = property.Split('[');

                string idxs = pstack[1].Replace("]", "");

                if (idxs.IsNumeric())
                    {
                    property = pstack[0];

                    index = idxs.AsInt();
                    }

                else

                    property = property.Replace("[", "").Replace("]", "");
                }

            fn_SimObject_setFieldValue(leftMostSimObject, property, value, index);

            #endregion
            }

        private void __SetVar(string variable, string value)
            {
            if (value.ToLower().Trim() == "false")

                value = "0";

            if (value.ToLower().Trim() == "true")

                value = "1";

            if (variable.Length > 4096)

                throw new Exception("Variable Name exceeds 4096 characters.");

            variable = variable.Replace("[", "").Replace("]", "");

            StringBuilder s = new StringBuilder(variable, 4096);

            StringBuilder r = new StringBuilder(value);

            SafeNativeMethods.mcs_torque_setvariable(s, r);

            if (!Debugging)
                return;

            Console.WriteLine("Setting variable: '" + s + "' to value: '" + r + "'");

            r = new StringBuilder(4096);

            SafeNativeMethods.mcs_torque_getvariable(s, r);

            if (r.ToString() == value)
                return;

            Error("Failed to update variable '" + s + "' to '" + value + "' the check value was '" + r + "'.");

            Console.WriteLine("Failed to update variable '" + s + "' to '" + value + "' the check value was '" + r + "'.");
            }

        #endregion

        #endregion

        #region "Scene Object Helpers"

        /// <summary>
        ///   Get's the mask type of the object.
        /// </summary>
        /// <param name="sceneObject"> </param>
        /// <returns> </returns>
        internal UInt32 SceneObjectGetTypeMask(string sceneObject)
            {
            if (sceneObject.Contains('.'))
                sceneObject = GetVar(sceneObject);
            StringBuilder so = new StringBuilder(sceneObject, 1024);

            UInt32 r = 0;

            r = SafeNativeMethods.mSceneObject_getTypeMask(so);

            return r;
            }

        /// <summary>
        ///   Does a raidus search for a specified simobject type.
        /// </summary>
        /// <param name="pos"> </param>
        /// <param name="radius"> </param>
        /// <param name="mask"> </param>
        /// <param name="useclientcontainer"> </param>
        /// <returns> </returns>
        internal Dictionary<uint, float> SceneObjectInitContainerRadiusSearch(Point3F pos, float radius, UInt32 mask, bool useclientcontainer)
            {
            uint[] results = new uint[500];

            float[] disresults = new float[500];

            SafeNativeMethods.mSceneObject_initContainerRadiusSearch(pos.x, pos.y, pos.z, radius, mask, useclientcontainer, results, disresults);

            Dictionary<uint, float> r = new Dictionary<uint, float>();

            for (int i = 0; i < 500; i++)
                {
                if (results[i] != 0)

                    r.Add(results[i], disresults[i]);

                else

                    break;
                }

            return r;
            }

        #endregion

        #region "Client Group Helpers"

        /// <summary>
        ///   Gets the number of objects in the client group.
        /// </summary>
        /// <returns> </returns>
        internal UInt32 ClientGroupGetCount()
            {
            UInt32 r = 0;

            r = SafeNativeMethods.mclientGroup_getCount();

            return r;
            }

        /// <summary>
        ///   Gets the specified object back from the client group.
        /// </summary>
        /// <param name="index"> </param>
        /// <returns> </returns>
        internal UInt32 ClientGroupGetObject(UInt32 index)
            {
            UInt32 r = 0;

            r = SafeNativeMethods.mclientGroup_getObject(index);

            return r;
            }

        #endregion

        /// <summary>
        ///   Executes the function with the passed parameters.
        /// </summary>
        /// <param name="function"> </param>
        /// <param name="parameters"> </param>
        /// <returns> </returns>
        internal string Execute(string function, string[] parameters)
            {
            StringBuilder ret = new StringBuilder(4096);

            string[] newparams = parameters.GetUpperBound(0) == -1 ? new string[1] : new string[parameters.GetUpperBound(0) + 2];

            newparams[0] = function;

            int c = 1;

            foreach (string p in parameters)
                {
                if (parameters[c - 1] == "")

                    newparams[c] = " ";

                else
                    {
                    newparams[c] = parameters[c - 1];

                    if (parameters[c - 1].ToLower() == "true")

                        newparams[c] = "1";

                    if (parameters[c - 1].ToLower() == "false")

                        newparams[c] = "0";
                    }

                c++;
                }

            List<IntPtr> myp = new List<IntPtr>();

            myp.AddRange(newparams.Select(Marshal.StringToCoTaskMemAnsi));

            SafeNativeMethods.mexecute(newparams.Count(), myp.ToArray(), ret);

            foreach (IntPtr intPtr in myp)

                Marshal.FreeCoTaskMem(intPtr);

            return ret.ToString();
            }

        /// <summary>
        ///   Calls the member function on the simobject with the passed parameters.
        /// </summary>
        /// <param name="simobject"> </param>
        /// <param name="function"> </param>
        /// <param name="parameters"> </param>
        /// <returns> </returns>
        internal string SimObjectCall(string simobject, string function, string[] parameters)
            {
            if (simobject.Contains('.'))

                simobject = _GetVar(simobject);

            StringBuilder so = new StringBuilder(simobject, 1024);

            StringBuilder ret = new StringBuilder(4096);

            string[] newparams = new string[parameters.GetUpperBound(0) + 3];

            newparams[0] = function;

            newparams[1] = "";

            int c = 2;

            foreach (string p in parameters)
                {
                if (parameters[c - 2] == "")

                    newparams[c] = " ";

                else
                    {
                    newparams[c] = parameters[c - 2];

                    if (parameters[c - 2].ToLower() == "true")

                        newparams[c] = "1";

                    if (parameters[c - 2].ToLower() == "false")

                        newparams[c] = "0";
                    }

                c++;
                }

            List<IntPtr> myp = new List<IntPtr>();

            myp.AddRange(newparams.Select(Marshal.StringToCoTaskMemAnsi));

            SafeNativeMethods.mSimObject_Call(so, newparams.Count(), myp.ToArray(), ret);

            foreach (IntPtr intPtr in myp)

                Marshal.FreeCoTaskMem(intPtr);

            return ret.ToString();
            }

        /// <summary>
        ///   Gets Eular Rotation.
        /// </summary>
        /// <param name="simobject"> </param>
        /// <returns> </returns>
        internal TransformF GetEulerRotation(string simobject)
            {
            StringBuilder sb = new StringBuilder(simobject, 4096);

            double x = 0;

            double y = 0;

            double z = 0;

            SafeNativeMethods.mgetEulerRotation(sb, (float) x, (float) y, (float) z);

            TransformF ret = new TransformF((float) x, (float) y, (float) z);

            return ret;
            }

        /// <summary>
        ///   Create Matrix from Euler.
        /// </summary>
        /// <param name="transform"> </param>
        /// <returns> </returns>
        internal TransformF MathMatrixCreateFromEuler(TransformF transform)
            {
            StringBuilder ret = new StringBuilder(1024);

            SafeNativeMethods.mMath_MatrixCreateFromEuler(transform.MOrientation.x, transform.MOrientation.y, transform.MOrientation.z, ret);

            return new TransformF(ret.ToString());
            }

        /// <summary>
        ///   Creates Matrix from vector.
        /// </summary>
        /// <param name="transform"> </param>
        /// <param name="vector"> </param>
        /// <returns> </returns>
        internal TransformF MathMatrixMulVector(TransformF transform, Point3F vector)
            {
            float x = transform.MPosition.x;

            float y = transform.MPosition.y;

            float z = transform.MPosition.z;

            float ang = transform.MAngle;

            float ax = transform.MOrientation.x;

            float ay = transform.MOrientation.y;

            float az = transform.MOrientation.z;

            float XX = vector.x;

            float YY = vector.y;

            float ZZ = vector.z;

            StringBuilder ret = new StringBuilder(1024);

            SafeNativeMethods.mMath_MatrixMulVector(x, y, z, ang, ax, ay, az, XX, YY, ZZ, ret);

            TransformF r = new TransformF(ret.ToString());

            return r;
            }
        }
    }
