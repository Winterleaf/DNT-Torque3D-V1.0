// Copyright (C) 2012 Winterleaf Entertainment L,L,C.
// 
// THE SOFTW ARE IS PROVIDED ON AN “ AS IS” BASIS, WITHOUT W ARRANTY OF ANY KIND,
// INCLUDING WITHOUT LIMIT ATION THE W ARRANTIES OF MERCHANT ABILITY, FITNESS
// FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT . THE ENTIRE RISK AS TO THE
// QUALITY AND PERFORMANCE OF THE SOFTW ARE IS THE RESPONSIBILITY OF LICENSEE.
// SHOULD THE SOFTW ARE PROVE DEFECTIVE IN ANY RESPECT , LICENSEE AND NOT LICEN -
// SOR OR ITS SUPPLIERS OR RESELLERS ASSUMES THE ENTIRE COST OF AN Y SERVICE AND
// REPAIR. THIS DISCLAIMER OF W ARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS
// AGREEMENT. NO USE OF THE SOFTW ARE IS AUTHORIZED HEREUNDER EXCEPT UNDER
// THIS DISCLAIMER.
// 
// The use of the WinterLeaf Entertainment LLC DotNetT orque (“DNT ”) and DotNetT orque
// Customizer (“DNTC”)is governed by this license agreement (“ Agreement”).
// 
// R E S T R I C T I O N S
// 
// (a) Licensee may not: (i) create any derivative works of DNT or DNTC, including but not
// limited to translations, localizations, technology add-ons, or game making software
// other than Games; (ii) reverse engineer , or otherwise attempt to derive the algorithms
// for DNT or DNTC (iii) redistribute, encumber , sell, rent, lease, sublicense, or otherwise
// transfer rights to DNT or DNTC; or (iv) remove or alter any tra demark, logo, copyright
// or other proprietary notices, legends, symbols or labels in DNT or DNTC; or (iiv) use
// the Software to develop or distribute any software that compete s with the Software
// without WinterLeaf Entertainment’s prior written consent; or (i iiv) use the Software for
// any illegal purpose.
// (b) Licensee may not distribute the DNTC in any manner.
// 
// LI C E N S E G R A N T .
// This license allows companies of any size, government entities or individuals to cre -
// ate, sell, rent, lease, or otherwise profit commercially from, games using executables
// created from the source code of DNT
// 
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// THE SOURCE CODE GENERATED BY DNTC CAN BE  DISTRIBUTED PUBLICLY PROVIDED THAT THE 
// DISTRIBUTOR PROVIDES  THE GENERATE SOURCE CODE FREE OF CHARGE.
// 
// THIS SOURCE CODE (DNT) CAN BE DISTRIBUTED PUBLICLY PROVIDED THAT THE DISTRIBUTOR 
// PROVIDES  THE SOURCE CODE (DNT) FREE OF CHARGE.
// **********************************************************************************
// **********************************************************************************
// **********************************************************************************
// 
// Please visit http://www.winterleafentertainment.com for more information about the project and latest updates.
// 
// Last updated: 10/18/2012
// 

#region

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Xml.Serialization;
using WinterLeaf.Classes;
using WinterLeaf.Enums;

#endregion

namespace WinterLeaf
    {
    /// <summary>
    /// This enumeration is used to direct callbacks from T3D to the correct
    /// C# class instance to find the function in.
    /// </summary>
    public enum ScriptType
        {
        /// <summary>
        /// In TorqueScript this would be the Scripts/Server folder
        /// </summary>
        Server,

        /// <summary>
        /// In TorqueScript this would be the Scripts/client Folder
        /// </summary>
        Client,

        /// <summary>
        /// In TorqueScript this would be the Scripts/ folder
        /// </summary>
        Main,

        /// <summary>
        /// In TorqueScript this would be the Core/Scripts/Server folder
        /// </summary>
        Core_Server,

        /// <summary>
        /// In TorqueScript this would be the Core/Scripts/Client folder
        /// </summary>
        Core_Client,

        /// <summary>
        /// In TorqueScript this would be the Core/Scripts folder.
        /// </summary>
        Core_Main
        }

    /// <summary>
    /// This class is the brokering program between C# and T3D.  It handles all of the marshalling,
    /// eventing and translation between C# and T3D
    /// </summary>
    public sealed partial class dnTorque
        {
        #region Delegates

        public delegate void ShutDownEventHandler(object sender, EventArgs e);

        #endregion

        private readonly IntPtr mhinstance = IntPtr.Zero;
        private Icon _WindowIcon;

        /// <summary>
        ///   A flag used to turn on verbose debugging messages.
        /// </summary>
        private bool _debuging;

        public dnTorque(IntPtr hinstance)
            {
            mhinstance = hinstance;
            }

        #region "Private Local Variables"

        private static string _mTorque_dll;

        /// <summary>
        ///   The C# Assembly which has the script logic to attach to T3D.
        /// </summary>
        private static Assembly _mAssembly;

        /// <summary>
        ///   The class type for the Script/Server script logic class .
        /// </summary>
        private static Type _mServerScripttype;

        /// <summary>
        ///   An instance of the Script/Server class object.
        /// </summary>
        private static object _mServerClassinstance;

        /// <summary>
        ///   The class type for the Core/Server class
        /// </summary>
        private static Type _mCoreServerScripttype;

        /// <summary>
        ///   An instance of the Core/Server class
        /// </summary>
        private static object _mCoreServerClassinstance;

        /// <summary>
        ///   The class type for the Script/Client class
        /// </summary>
        private static Type _mClientScripttype;

        /// <summary>
        ///   An instance of the Script/Client class
        /// </summary>
        private static object _mClientClassinstance;

        /// <summary>
        ///   The class type for the Core/Client class.
        /// </summary>
        private static Type _mCoreClientScripttype;

        /// <summary>
        ///   An instance of the Core/Client class
        /// </summary>
        private static object _mCoreClientClassinstance;

        /// <summary>
        ///   The class type of the main entry class
        /// </summary>
        private static Type _mMainScripttype;

        /// <summary>
        ///   An instance of the main entry class
        /// </summary>
        private static object _mMainClassinstance;

        /// <summary>
        ///   The class type of the core main entry class.
        /// </summary>
        private static Type _mCoreMainScripttype;

        /// <summary>
        ///   An instance of the core/main class.
        /// </summary>
        private static object _mCoreMainClassinstance;

        /// <summary>
        ///   Flag telling the T3D loop to stop and post exit.
        /// </summary>
        private static bool _mStopTorque;

        /// <summary>
        ///   Array containing command line parameters to send to T3D dll.
        /// </summary>
        private static string[] _mTorqueCmdParams;

        /// <summary>
        /// This List is a list of all the C# functions decorated in the Scripts Dll.
        /// </summary>
        private static readonly List<Torque_Decorations.TorqueCallBackInfo> MFunctionMaps = new List<Torque_Decorations.TorqueCallBackInfo>();


        /// <summary>
        ///   Holds a handle to the Instance Eval Callback delegate which is passed to the T3D Dll for callbacks from torque.
        /// </summary>
        private static SafeNativeMethods.Instance_Eval m_localhandle_Instance_Eval_CallBack;

        /// <summary>
        ///   Holds a handle to the Instance Eval Direct Callback delegate which is passed to the T3D Dll for callbacks from torque.
        /// 
        /// Note:Experimental, pass function by id.
        /// </summary>
        private static SafeNativeMethods.Instance_Eval_Direct_New m_localhandle_Instance_Eval_CallBack_Direct_New;

        /// <summary>
        ///   Used for the Monitor to lock the engine tick when making calls to the T3D dll async.
        /// </summary>
        public object tick = new object();

        #endregion

        public bool IsRunning
            {
            get { return !_mStopTorque; }
            }

        ///// <summary>
        /////   A handle to the window that T3D passes back when it is initialized.
        ///// </summary>
        //internal IntPtr _hwndhndl;

        /// <summary>
        ///   Turns on verbose debugging messages.
        /// </summary>
        public bool Debugging
            {
            get { return _debuging; }
            set { _debuging = value; }
            }

        /// <summary>
        ///   Flag telling the T3D loop to stop and post exit.
        /// </summary>
        internal static bool MStopTorque
            {
            get { return _mStopTorque; }
            }

        public Icon WindowIcon
            {
            get { return _WindowIcon; }
            set { _WindowIcon = value; }
            }

        private void SetParentIcon(Icon icon)
            {
            IntPtr hwnd = this.torque_gethwnd();
            if (hwnd != null && hwnd != IntPtr.Zero)
                {
                //                System.Drawing.Icon icon = new System.Drawing.Icon("ApplicationIcon.ico");
                NativeMethods.SendMessage(hwnd, (int)WM.SETICON, 1 /*ICON_LARGE*/, (int)icon.Handle);
                }
            }

        public IntPtr torque_gethwnd()
            {
            return SafeNativeMethods.mtorque_gethwnd();
            }

        /// <summary>
        ///   Stops the T3D dll and this program posting an exit command to windows.
        /// </summary>
        public void Stop()
            {
            _mStopTorque = true;
            }

        /// <summary>
        ///   Injects the specified scripttype into Torque ordered by weight and only include the functions weighted between the start and end
        /// </summary>
        /// <param name="scripttype"> The type of script to inject </param>
        /// <param name="weightStart"> The lowest script weight </param>
        /// <param name="weightEnd"> The highest script weight </param>
        public void DoScriptInjection(ScriptType scripttype, int weightStart, int weightEnd)
            {
            _DoScriptInjection(scripttype, weightStart, weightEnd);
            }

        /// <summary>
        ///   Internal function, Injects the specified scripttype into Torque ordered by weight and only include the functions weighted between the start and end
        /// </summary>
        /// <param name="scripttype"> The type of script to inject </param>
        /// <param name="weightStart"> The lowest script weight </param>
        /// <param name="weightEnd"> The highest script weight </param>
        internal void _DoScriptInjection(ScriptType scripttype, int weightStart, int weightEnd)
            {
            //A list to keep track of the packages that we have already injected
            //so we don't inject them twice.
            List<string> processedPackages = new List<string>();

            IEnumerable<Torque_Decorations.TorqueCallBackInfo> r = null;

            //"We select from the approapriate Collection all the functions that meet our critera"

            #region Select functions to inject

            if (scripttype == ScriptType.Server)

                r = from e in (new List<Torque_Decorations.TorqueCallBackInfo>(MFunctionMaps)) where ((e.Functionweight >= weightStart) && (e.Functionweight <= weightEnd) && e.TorqueScriptType == ScriptType.Server) orderby e.Functionweight ascending select e;

            if (scripttype == ScriptType.Client)
                r = from e in (new List<Torque_Decorations.TorqueCallBackInfo>(MFunctionMaps)) where ((e.Functionweight >= weightStart) && (e.Functionweight <= weightEnd) && e.TorqueScriptType == ScriptType.Client) orderby e.Functionweight ascending select e;

            if (scripttype == ScriptType.Main)
                r = from e in (new List<Torque_Decorations.TorqueCallBackInfo>(MFunctionMaps)) where ((e.Functionweight >= weightStart) && (e.Functionweight <= weightEnd) && e.TorqueScriptType == ScriptType.Main) orderby e.Functionweight ascending select e;

            if (scripttype == ScriptType.Core_Server)
                r = from e in (new List<Torque_Decorations.TorqueCallBackInfo>(MFunctionMaps)) where ((e.Functionweight >= weightStart) && (e.Functionweight <= weightEnd) && e.TorqueScriptType == ScriptType.Core_Server) orderby e.Functionweight ascending select e;

            if (scripttype == ScriptType.Core_Client)
                r = from e in (new List<Torque_Decorations.TorqueCallBackInfo>(MFunctionMaps)) where ((e.Functionweight >= weightStart) && (e.Functionweight <= weightEnd) && e.TorqueScriptType == ScriptType.Core_Client) orderby e.Functionweight ascending select e;

            if (scripttype == ScriptType.Core_Main)
                r = from e in (new List<Torque_Decorations.TorqueCallBackInfo>(MFunctionMaps)) where ((e.Functionweight >= weightStart) && (e.Functionweight <= weightEnd) && e.TorqueScriptType == ScriptType.Core_Main) orderby e.Functionweight ascending select e;

            #endregion

            if (r != null)


                foreach (Torque_Decorations.TorqueCallBackInfo tcbi in r)
                    {
                    //Is the function we are looking at a member of a Torque Package?

                    if (tcbi.TorquePackageName != "")
                        {
                        #region Torque Package Process

                        //Have we already processed this Torque Package?
                        if (!processedPackages.Contains(tcbi.TorquePackageName.ToLower()))
                            {
                            StringBuilder output = new StringBuilder();

                            output.AppendFormat("Starting Construction of Package ({0})\r\n", tcbi.TorquePackageName);

                            //We haven't processed this package yet, so lets grab all of the functions that below 
                            //to it and process them as one.

                            #region Grab all functions belonging to this Torque Package

                            IEnumerable<Torque_Decorations.TorqueCallBackInfo> rPackages = null;

                            if (scripttype == ScriptType.Server)

                                rPackages = from e in (new List<Torque_Decorations.TorqueCallBackInfo>(MFunctionMaps)) where ((e.TorquePackageName.ToLower() == tcbi.TorquePackageName.ToLower()) && ((e.Functionweight >= weightStart) && (e.Functionweight <= weightEnd)) && e.TorqueScriptType == ScriptType.Server) orderby e.Functionweight ascending select e;

                            if (scripttype == ScriptType.Client)

                                rPackages = from e in (new List<Torque_Decorations.TorqueCallBackInfo>(MFunctionMaps)) where ((e.TorquePackageName.ToLower() == tcbi.TorquePackageName.ToLower()) && ((e.Functionweight >= weightStart) && (e.Functionweight <= weightEnd)) && e.TorqueScriptType == ScriptType.Client) orderby e.Functionweight ascending select e;

                            if (scripttype == ScriptType.Main)

                                rPackages = from e in (new List<Torque_Decorations.TorqueCallBackInfo>(MFunctionMaps)) where ((e.TorquePackageName.ToLower() == tcbi.TorquePackageName.ToLower()) && ((e.Functionweight >= weightStart) && (e.Functionweight <= weightEnd)) && e.TorqueScriptType == ScriptType.Main) orderby e.Functionweight ascending select e;

                            if (scripttype == ScriptType.Core_Server)

                                rPackages = from e in (new List<Torque_Decorations.TorqueCallBackInfo>(MFunctionMaps)) where ((e.TorquePackageName.ToLower() == tcbi.TorquePackageName.ToLower()) && ((e.Functionweight >= weightStart) && (e.Functionweight <= weightEnd)) && e.TorqueScriptType == ScriptType.Core_Server) orderby e.Functionweight ascending select e;

                            if (scripttype == ScriptType.Core_Client)

                                rPackages = from e in (new List<Torque_Decorations.TorqueCallBackInfo>(MFunctionMaps)) where ((e.TorquePackageName.ToLower() == tcbi.TorquePackageName.ToLower()) && ((e.Functionweight >= weightStart) && (e.Functionweight <= weightEnd)) && e.TorqueScriptType == ScriptType.Core_Client) orderby e.Functionweight ascending select e;

                            if (scripttype == ScriptType.Core_Main)

                                rPackages = from e in (new List<Torque_Decorations.TorqueCallBackInfo>(MFunctionMaps)) where ((e.TorquePackageName.ToLower() == tcbi.TorquePackageName.ToLower()) && ((e.Functionweight >= weightStart) && (e.Functionweight <= weightEnd)) && e.TorqueScriptType == ScriptType.Core_Main) orderby e.Functionweight ascending select e;

                            #endregion

                            StringBuilder packstring = new StringBuilder();

                            packstring.Append("package " + tcbi.TorquePackageName + "\r\n{\r\n");

                            bool executeme = false;

                            //Go through each function in the Package and assemble them together into a script block to inject.
                            foreach (Torque_Decorations.TorqueCallBackInfo pd in rPackages)
                                {
                                output.AppendFormat("Adding  Class Name: '{1}' Function:'{2} to package {3}.\r\n", "", pd.TorqueClassname, pd.TorqueFunction, pd.TorquePackageName);

                                packstring.Append(pd.GetScript(scripttype, Debugging));

                                packstring.Append("\r\n");

                                if (pd.ExecuteAfterCompile)

                                    executeme = true;
                                }

                            packstring.Append("\r\n};\r\n");

                            //We are done constructing the package script.

                            output.AppendFormat("Finished Construction of Package ({0})\r\n", tcbi.TorquePackageName);

                            if (Debugging)

                                Print(output.ToString());

                            //Send the string of text to the T3D console for evaluation.
                            Evaluate(packstring.ToString(), false);

                            //This will activate the package after compilation.
                            if (executeme)
                                {
                                if (Debugging)

                                    Print(string.Format("Activating Package: {0}", tcbi.TorquePackageName));

                                fn_activatePackage(tcbi.TorquePackageName);
                                }

                            //Add the name of the Package to the processed packages so we don't do it again.
                            processedPackages.Add(tcbi.TorquePackageName.ToLower());
                            }

                        #endregion
                        }

                    else
                        {
                        #region Non Package Functions.

                        if (Debugging)

                            Warn(string.Format("Loading  Class Name: '{1}' Function:'{2}", "", tcbi.TorqueClassname, tcbi.TorqueFunction));

                        //Send the Torque Script function stub to the T3D engine.

                        Evaluate(tcbi.GetScript(scripttype, Debugging), false);

                        //Are we to execute this function after loading it?

                        if (tcbi.ExecuteAfterCompile)

                            //oops, we can only load functions which have no parameters.

                            if (tcbi.TorqueMaxArgs > 0)

                                Warn("!!!!!!!!!!!!CANNOT EXECUTE FUNCTION, Min Arguments Greater than 0!!!!!!!!!!!");

                            else

                                //Evalue the function.
                                Evaluate(tcbi.TorqueClassname.Trim() != "" ? string.Format(@"eval (""{0}::{1}();"");", tcbi.TorqueClassname, tcbi.TorqueFunction) : string.Format(@"eval (""{0}();"");", tcbi.TorqueFunction), false);

                        #endregion
                        }
                    }
            }

        /// <summary>
        /// Used to resize the T3D interface.
        /// </summary>
        /// <param name="width"></param>
        /// <param name="height"></param>
        public void WindowResize(int width, int height)
            {
            if (SafeNativeMethods.consolemapped)
                SafeNativeMethods.mtorque_resizewindow(width, height);
            }


        /// <summary>
        ///   Initializes the T3D dll and starts torque.
        /// </summary>
        /// <param name="torqueCmdParams"> Command Line Parameters to be sent to the T3D dll </param>
        /// <param name="csharpServerClassName"> The classname of the Script/Server </param>
        /// <param name="csharpClientClassName"> The classname of the Script/Client </param>
        /// <param name="csharpMainClassName"> The classname of the Script </param>
        /// <param name="csharpCoreServerClassName"> The classname of the core/Server </param>
        /// <param name="csharpCoreClientClassName"> The classname of the core/Client </param>
        /// <param name="csharpCoreMainClassName"> The classname of the core </param>
        /// <param name="csharpDllPath"> The filepath to the DotNet Dll </param>
        /// <param name="csharpDllFilename"> The name of the DotNet DLL </param>
        public void InitializeTorque(string[] torqueCmdParams, string csharpServerClassName, string csharpClientClassName, string csharpMainClassName, string csharpCoreServerClassName, string csharpCoreClientClassName, string csharpCoreMainClassName, string csharpDllPath, string csharpDllFilename, string T3D_DLLName = "FPS Example.dll")
            {
            _InitializeTorque(torqueCmdParams, csharpServerClassName, csharpClientClassName, csharpMainClassName, csharpCoreServerClassName, csharpCoreClientClassName, csharpCoreMainClassName, csharpDllPath, csharpDllFilename, T3D_DLLName);
            }

        /// <summary>
        ///   Worker function to initializes the T3D dll and starts torque.
        /// </summary>
        /// <param name="torqueCmdParams"> Command Line Parameters to be sent to the T3D dll </param>
        /// <param name="csharpServerClassName"> The classname of the Script/Server </param>
        /// <param name="csharpClientClassName"> The classname of the Script/Client </param>
        /// <param name="csharpMainClassName"> The classname of the Script </param>
        /// <param name="csharpCoreServerClassName"> The classname of the core/Server </param>
        /// <param name="csharpCoreClientClassName"> The classname of the core/Client </param>
        /// <param name="csharpCoreMainClassName"> The classname of the core </param>
        /// <param name="csharpDllPath"> The filepath to the DotNet Dll </param>
        /// <param name="csharpDllFilename"> The name of the DotNet DLL </param>
        private void _InitializeTorque(string[] torqueCmdParams, string csharpServerClassName, string csharpClientClassName, string csharpMainClassName, string csharpCoreServerClassName, string csharpCoreClientClassName, string csharpCoreMainClassName, string csharpDllPath, string csharpDllFilename, string T3D_DLLName)
            {
            //Save a copy of the Command Params.
            _mTorqueCmdParams = torqueCmdParams;

            _mTorque_dll = T3D_DLLName;

            //Check to make sure the path to the dll exists.
            if (!Directory.Exists(csharpDllPath))
                throw new Exception("CSharp Path not found");

            //Check to make sure the DotNet dll exists.
            if (!File.Exists(csharpDllPath + csharpDllFilename))
                throw new Exception(@"CSharp DLL not found, example path = 'C:\some\' filename = 'test.dll'");

            #region "Scripts"

            #region "Load Server Class"

            //Use reflections to load the assembly from disk
            _mAssembly = Assembly.LoadFrom(csharpDllPath + csharpDllFilename);

            //Did the assembly load?
            if (csharpServerClassName != "")
                if (_mAssembly != null)
                    {
                    ConstructorInfo ci;

                    try
                        {
                        //Set the Script type
                        _mServerScripttype = _mAssembly.GetType(csharpServerClassName);

                        //Get the constructor information for the class, make sure it takes a dnTorque ref as a parameter
                        ci = _mAssembly.GetType(csharpServerClassName, false).GetConstructor(new[] { typeof(dnTorque).MakeByRefType() });
                        }
                    catch (Exception err)
                        {
                        throw new Exception("Unable to find the Server Classname or it's constructor.");
                        }


                    if (ci == null)

                        throw new Exception("The server constructor doesn't take a parameter of WinterLeaf.csTorque.Forms.Console");

                    //Try to create an instance of the class
                    _mServerClassinstance = ci.Invoke(new object[] { this });

                    if (_mServerClassinstance == null)

                        throw new Exception(string.Format("Did you capitalize and spell the program and classname correctly?  dll:{0} classname: {1}", csharpDllFilename, csharpServerClassName));

                    //Ok, so we need to determine all the hooks on the script.
                    MethodInfo[] micol = _mServerScripttype.GetMethods();

                    foreach (Torque_Decorations.TorqueCallBackInfo tcbi in from mi in micol let ats = mi.GetCustomAttributes(typeof(Torque_Decorations.TorqueCallBack), true) where ats.GetUpperBound(0) == 0 select new Torque_Decorations.TorqueCallBackInfo((Torque_Decorations.TorqueCallBack)ats[0], mi, mi.GetParameters()) { TorqueScriptType = ScriptType.Server, TorqueFunctionID = MFunctionMaps.Count })
                        {
                        MFunctionMaps.Add(tcbi);
                        }
                    }
                else
                    {
                    throw new Exception(string.Format("Unable to find Assembly '{0}{1}'", csharpDllPath, csharpDllFilename));
                    }

            #endregion

            #region "Load Client Class"

            if (csharpClientClassName != "")
                if (_mAssembly != null)
                    {
                    ConstructorInfo ci;
                    try
                        {
                        _mClientScripttype = _mAssembly.GetType(csharpClientClassName);

                        ci = _mAssembly.GetType(csharpClientClassName, false).GetConstructor(new[] { typeof(dnTorque).MakeByRefType() });
                        }
                    catch (Exception)
                        {
                        throw new Exception("Unable to find the Client Classname or it's constructor.");
                        }


                    if (ci == null)
                        throw new Exception("The client constructor doesn't take a parameter of WinterLeaf.csTorque.Forms.Console");

                    _mClientClassinstance = ci.Invoke(new object[] { this });

                    if (_mClientClassinstance == null)
                        throw new Exception(string.Format("Did you capitalize and spell the program and classname correctly?  dll:{0} classname: {1}", csharpDllFilename, csharpClientClassName));
                    //Ok, so we need to determine all the hooks on the script.
                    MethodInfo[] micol = _mClientScripttype.GetMethods();

                    foreach (Torque_Decorations.TorqueCallBackInfo tcbi in from mi in micol let ats = mi.GetCustomAttributes(typeof(Torque_Decorations.TorqueCallBack), true) where ats.GetUpperBound(0) == 0 select new Torque_Decorations.TorqueCallBackInfo((Torque_Decorations.TorqueCallBack)ats[0], mi, mi.GetParameters()) { TorqueScriptType = ScriptType.Client, TorqueFunctionID = MFunctionMaps.Count })
                        {
                        MFunctionMaps.Add(tcbi);
                        }
                    }

                else

                    throw new Exception(string.Format("Unable to find Assembly '{0}{1}'", csharpDllPath, csharpDllFilename));

            #endregion

            #region "Load Main Class"

            if (_mAssembly != null)
                {
                ConstructorInfo ci;
                try
                    {
                    _mMainScripttype = _mAssembly.GetType(csharpMainClassName);

                    ci = _mAssembly.GetType(csharpMainClassName, false).GetConstructor(new[] { typeof(dnTorque).MakeByRefType() });
                    }
                catch (Exception)
                    {
                    throw new Exception("Unable to find the Main Classname or it's constructor.");
                    }


                if (ci == null)

                    throw new Exception("The client constructor doesn't take a parameter of WinterLeaf.csTorque.Forms.Console");

                _mMainClassinstance = ci.Invoke(new object[] { this });

                if (_mMainClassinstance == null)

                    throw new Exception(string.Format("Did you capitalize and spell the program and classname correctly?  dll:{0} classname: {1}", csharpDllFilename, csharpMainClassName));

                //Ok, so we need to determine all the hooks on the script.
                MethodInfo[] micol = _mMainScripttype.GetMethods();

                foreach (Torque_Decorations.TorqueCallBackInfo tcbi in from mi in micol let ats = mi.GetCustomAttributes(typeof(Torque_Decorations.TorqueCallBack), true) where ats.GetUpperBound(0) == 0 select new Torque_Decorations.TorqueCallBackInfo((Torque_Decorations.TorqueCallBack)ats[0], mi, mi.GetParameters()) { TorqueScriptType = ScriptType.Main, TorqueFunctionID = MFunctionMaps.Count })
                    {
                    MFunctionMaps.Add(tcbi);
                    }
                }
            else
                throw new Exception(string.Format("Unable to find Assembly '{0}{1}'", csharpDllPath, csharpDllFilename));

            #endregion

            #endregion

            #region "Core Scripts"

            #region "Load Server Class"

            _mAssembly = Assembly.LoadFrom(csharpDllPath + csharpDllFilename);
            if (csharpCoreServerClassName != "")
                if (_mAssembly != null)
                    {
                    _mCoreServerScripttype = _mAssembly.GetType(csharpCoreServerClassName);

                    ConstructorInfo ci = _mAssembly.GetType(csharpCoreServerClassName, false).GetConstructor(new[] { typeof(dnTorque).MakeByRefType() });

                    if (ci == null)

                        throw new Exception("The server constructor doesn't take a parameter of WinterLeaf.csTorque.Forms.Console");

                    _mCoreServerClassinstance = ci.Invoke(new object[] { this });

                    if (_mCoreServerClassinstance == null)

                        throw new Exception(string.Format("Did you capitalize and spell the program and classname correctly?  dll:{0} classname: {1}", csharpDllFilename, csharpCoreServerClassName));

                    //Ok, so we need to determine all the hooks on the script.
                    MethodInfo[] micol = _mCoreServerScripttype.GetMethods();

                    foreach (Torque_Decorations.TorqueCallBackInfo tcbi in from mi in micol let ats = mi.GetCustomAttributes(typeof(Torque_Decorations.TorqueCallBack), true) where ats.GetUpperBound(0) == 0 select new Torque_Decorations.TorqueCallBackInfo((Torque_Decorations.TorqueCallBack)ats[0], mi, mi.GetParameters()) { TorqueScriptType = ScriptType.Core_Server, TorqueFunctionID = MFunctionMaps.Count })
                        {
                        MFunctionMaps.Add(tcbi);
                        }
                    }
                else
                    {
                    throw new Exception(string.Format("Unable to find Assembly '{0}{1}'", csharpDllPath, csharpDllFilename));
                    }

            #endregion

            #region "Load Client Class"

            if (csharpCoreClientClassName != "")
                if (_mAssembly != null)
                    {
                    _mCoreClientScripttype = _mAssembly.GetType(csharpCoreClientClassName);

                    ConstructorInfo ci = _mAssembly.GetType(csharpCoreClientClassName, false).GetConstructor(new[] { typeof(dnTorque).MakeByRefType() });

                    if (ci == null)
                        throw new Exception("The client constructor doesn't take a parameter of WinterLeaf.csTorque.Forms.Console");

                    _mCoreClientClassinstance = ci.Invoke(new object[] { this });

                    if (_mCoreClientClassinstance == null)
                        throw new Exception(string.Format("Did you capitalize and spell the program and classname correctly?  dll:{0} classname: {1}", csharpDllFilename, csharpCoreClientClassName));

                    //Ok, so we need to determine all the hooks on the script.
                    MethodInfo[] micol = _mCoreClientScripttype.GetMethods();

                    foreach (Torque_Decorations.TorqueCallBackInfo tcbi in from mi in micol let ats = mi.GetCustomAttributes(typeof(Torque_Decorations.TorqueCallBack), true) where ats.GetUpperBound(0) == 0 select new Torque_Decorations.TorqueCallBackInfo((Torque_Decorations.TorqueCallBack)ats[0], mi, mi.GetParameters()) { TorqueScriptType = ScriptType.Core_Client, TorqueFunctionID = MFunctionMaps.Count })
                        {
                        MFunctionMaps.Add(tcbi);
                        }
                    }
                else
                    throw new Exception(string.Format("Unable to find Assembly '{0}{1}'", csharpDllPath, csharpDllFilename));

            #endregion

            #region "Load Main Class"

            if (csharpCoreMainClassName != "")
                if (_mAssembly != null)
                    {
                    _mCoreMainScripttype = _mAssembly.GetType(csharpCoreMainClassName);

                    ConstructorInfo ci = _mAssembly.GetType(csharpCoreMainClassName, false).GetConstructor(new[] { typeof(dnTorque).MakeByRefType() });

                    if (ci == null)
                        throw new Exception("The client constructor doesn't take a parameter of WinterLeaf.csTorque.Forms.Console");

                    _mCoreMainClassinstance = ci.Invoke(new object[] { this });

                    if (_mCoreMainClassinstance == null)
                        throw new Exception(string.Format("Did you capitalize and spell the program and classname correctly?  dll:{0} classname: {1}", csharpDllFilename, csharpCoreMainClassName));

                    //Ok, so we need to determine all the hooks on the script.
                    MethodInfo[] micol = _mCoreMainScripttype.GetMethods();

                    foreach (Torque_Decorations.TorqueCallBackInfo tcbi in from mi in micol let ats = mi.GetCustomAttributes(typeof(Torque_Decorations.TorqueCallBack), true) where ats.GetUpperBound(0) == 0 select new Torque_Decorations.TorqueCallBackInfo((Torque_Decorations.TorqueCallBack)ats[0], mi, mi.GetParameters()) { TorqueScriptType = ScriptType.Core_Main, TorqueFunctionID = MFunctionMaps.Count })
                        {
                        MFunctionMaps.Add(tcbi);
                        }
                    }
                else

                    throw new Exception(string.Format("Unable to find Assembly '{0}{1}'", csharpDllPath, csharpDllFilename));

            #endregion

            #endregion

            //All functions which CAN be exported into T3D have been reflected and indexed.

            //Create a new background worker to run the engine tick in.
            using (BackgroundWorker bwr = new BackgroundWorker())
                {
                bwr.DoWork += bwr_InitializeTorque;

                bwr.RunWorkerAsync();
                }
            }

        private void ShutDownCleanUp()
            {
            SafeNativeMethods.FreeDLL();

            Marshal.CleanupUnusedObjectsInCurrentContext();

            OnShutDownEvent();
            }


        /// <summary>
        ///   This function is called from the _InitializeTorque and is where the engine tick is called from.
        /// </summary>
        /// <param name="sender"> </param>
        /// <param name="e"> </param>
        private void bwr_InitializeTorque(object sender, DoWorkEventArgs e)
            {
            //Clean up any managed memory objects, really shouldn't be any, but....
            Marshal.CleanupUnusedObjectsInCurrentContext();

            SafeNativeMethods.SetUpDynamicDLL(_mTorque_dll);

            //create a list of pointers for our parameters
            List<IntPtr> myp = new List<IntPtr> { Marshal.StringToCoTaskMemAnsi(Assembly.GetExecutingAssembly().Location) };

            //Add the pointer to a managed memory string containing the location of the Assembly.

            //Create a managed memory string object and put our command line parameters in each one, 
            //then add the pointer to that object into our list.
            myp.AddRange(_mTorqueCmdParams.Select(Marshal.StringToCoTaskMemAnsi));

            //Now, this if fun stuff, we need to save the pointer to the instance eval delegate
            //and save it to a static variable so the DotNet's Garabage collection doesn't
            //decide to through it away on a cleanup since no object inside of DotNet
            //will have a reference to it.  
            m_localhandle_Instance_Eval_CallBack = Instance_Eval_event;

            //Just incase the static reference doesn't work, lets tell the GC to suppress
            //any cleanup of the object as well.
            GC.SuppressFinalize(m_localhandle_Instance_Eval_CallBack);

            //We do the save for the direct calls as well.
            m_localhandle_Instance_Eval_CallBack_Direct_New = Instance_Eval_event_Direct_New;

            GC.SuppressFinalize(m_localhandle_Instance_Eval_CallBack_Direct_New);

            //We make an extern call to the T3D dll passing our pointers so the T3D can
            //make callbacks.

            SafeNativeMethods.mSetHandler_Instance_Eval(m_localhandle_Instance_Eval_CallBack);
            SafeNativeMethods.mSetHandler_Instance_Eval_Direct_New(m_localhandle_Instance_Eval_CallBack_Direct_New);


            //Initialize the T3D dll and capture its window handle.
            SafeNativeMethods.mdnt_torque_engineinit(myp.Count, myp.ToArray(), mhinstance);
            SetParentIcon(this._WindowIcon);

            foreach (IntPtr ptr in myp)

                Marshal.FreeCoTaskMem(ptr);


            //We make one cal to the engine tick before doing anything else at this point
            //so Torque can set everything up.
            SafeNativeMethods.mtorque_enginetick();


            //Loop until told to stop.
            while (!MStopTorque)
                {
                //I use to have this in a try/catch block, but since errors through from calling a managed memory object
                //are considered "Hard" errors, a try catch block will not catch them.

                //Since Torque's console is not multi-threaded we have to be careful on async calls, i.e. calls
                //made to torque not as a result of torque calling a exported function, but instead of a 
                //csharp function running in a seperate thread.
                //So to prevent corruption, only allow async functions to make calls back to Torque when it is
                //in an idle state, i.e. not "Ticking".  This way there is no way to calls can enter the same Torque
                //function at the same time and cause memory corruption.
                lock (tick)
                    {
                    if (SafeNativeMethods.mtorque_enginetick() != 1)
                        _mStopTorque = true;
                    }
                }
			SafeNativeMethods.mtorque_enginesignalshutdown();
            SafeNativeMethods.mtorque_enginetick();
            SafeNativeMethods.mtorque_engineshutdown();

            GC.ReRegisterForFinalize(m_localhandle_Instance_Eval_CallBack);
            m_localhandle_Instance_Eval_CallBack = null;
            GC.ReRegisterForFinalize(m_localhandle_Instance_Eval_CallBack_Direct_New);
            m_localhandle_Instance_Eval_CallBack_Direct_New = null;
            GC.Collect();

            ShutDownCleanUp();
            }


        /// <summary>
        ///   This function is used when you want to execute some arbitrary CSharp code. It should be prefixed with the type of script to call then the csharp. i.e. server.callsomefunction(variable1,variable2).returnedobject.someproperty.tostring(); It will just keep walking down the csharp string until it either errors out or finishes.
        /// </summary>
        /// <param name="sbevalstatement">Arbitrary cSharp Code, must be prefixed with which class to look in:
        /// i.e. Server,Client,Main,Core_Server,Core_Client,Core_Main.  An example would be "Server.somecsharpfunction();"  </param>
        /// <returns> </returns>
        internal void Instance_Eval_event(StringBuilder sbevalstatement, byte[] returnbuff)
            {
            string evalstatement = sbevalstatement.ToString();
            object retvalue = "";
            //Did Torque tell us to shut down?

            if (evalstatement.ToLower().Trim().StartsWith("shutdown()"))
                {
                Stop();
                return; // "";
                }

            try
                {
                //Find out which class object the code should live in.
                string calledtype = evalstatement;

                calledtype = calledtype.Split('.')[0];

                evalstatement = evalstatement.Substring(calledtype.Length + 1);

                string resultvalue = "";

                if (Debugging)

                    Error(string.Format("------> Instance Eval (Start) ({0})", evalstatement));



                try
                    {
                    switch (calledtype.ToLower())
                        {
                        case "server":

                            if (_mServerClassinstance != null)

                                retvalue = myReflections.ResolveObject(evalstatement, _mServerClassinstance);

                            break;

                        case "client":

                            if (_mClientClassinstance != null)

                                retvalue = myReflections.ResolveObject(evalstatement, _mClientClassinstance);

                            break;

                        case "main":

                            if (_mClientClassinstance != null)

                                retvalue = myReflections.ResolveObject(evalstatement, _mMainClassinstance);

                            break;

                        case "core_server":

                            if (_mServerClassinstance != null)

                                retvalue = myReflections.ResolveObject(evalstatement, _mCoreServerClassinstance);

                            break;

                        case "core_client":

                            if (_mClientClassinstance != null)

                                retvalue = myReflections.ResolveObject(evalstatement, _mCoreClientClassinstance);

                            break;

                        case "core_main":

                            if (_mClientClassinstance != null)

                                retvalue = myReflections.ResolveObject(evalstatement, _mCoreMainClassinstance);

                            break;
                        }
                    }
                catch (Exception r)
                    {
                    string errortext = r.Message;

                    if (r.StackTrace != null)
                        errortext += r.StackTrace;

                    if (r.InnerException != null)
                        errortext += r.InnerException;

                    resultvalue = errortext + "--->" + evalstatement;
                    }

                //Is the final value a primitive type or a string?  then just return it.
                if ((retvalue.GetType().IsPrimitive) || (retvalue is string))

                    resultvalue = retvalue.ToString();

                else
                    {
                    //We will try to serialize the object into XML.
                    try
                        {
                        XmlSerializer ser = new XmlSerializer(retvalue.GetType());

                        StringBuilder sb = new StringBuilder();

                        using (StringWriter writer = new StringWriter(sb))
                            {
                            ser.Serialize(writer, retvalue);

                            resultvalue = (sb.ToString().Replace("<?xml version=\"1.0\" encoding=\"utf-16\"?>\r\n", ""));
                            }
                        }

                    catch (Exception r)
                        {
                        string errortext = r.Message;

                        if (r.StackTrace != null)
                            errortext += r.StackTrace;

                        if (r.InnerException != null)
                            errortext += r.InnerException;

                        resultvalue = errortext + "--->" + evalstatement;
                        }
                    }
                }
            catch (Exception err)
                {
                Console.WriteLine(err.ToString());
                }
            if (Debugging)

                Error(string.Format("------> Instance Eval (End) ({0})", evalstatement));


            int ai = 0;


            foreach (byte c in Encoding.ASCII.GetBytes(retvalue.ToString()))
                {
                returnbuff[ai] = c;
                ai++;
                }
            returnbuff[ai] = 0;
            }


        /// <summary>
        /// This function is not intended for human consumption. It uses a key to the function with parameters to look up the function and execute it. This code is generated by the injection code.
        /// 
        /// This code might seem a bit confusing, but it really is simple, every function exported to T3D is given an ID, and the script injected into torque has that
        /// function id as the first parameter.  So by pulling the first param I know what function in the array of functions to call.
        /// </summary>
        /// <param name="argc">Count of arguments passed</param>
        /// <param name="argv">Vector of arguments</param>
        /// <returns></returns>
        internal void Instance_Eval_event_Direct_New(int argc, IntPtr argv, byte[] returnbuff)
            {
            int function = 0;
            object ret = "";
            try
                {
                List<string> myparams = new List<string>();

                //ok, argv is a list of pointers null terminated.

                StringBuilder tparams = new StringBuilder();


                for (int i = 1; i < argc; i++)

                    if (i == 1)

                        function = Marshal.PtrToStringAnsi(Marshal.ReadIntPtr(argv, 4 * i)).AsInt();

                    else
                        {
                        string p = Marshal.PtrToStringAnsi(Marshal.ReadIntPtr(argv, 4 * i));
                        myparams.Add(p);
                        tparams.Append(" Param: '" + p + "'");
                        }


                Torque_Decorations.TorqueCallBackInfo tcbi = MFunctionMaps[function];

                if (Debugging)

                    Error("BEGIN Direct Call: Function ID: " + tcbi.TorqueFunctionID + " Tag: " + tcbi + " Params:" + tparams);



                switch (tcbi.TorqueScriptType)
                    {
                    case ScriptType.Main:

                        ret = myReflections.MethodCall(_mMainClassinstance, tcbi.FunctionInvoke, myparams.ToArray(), tcbi.FunctionParams);

                        break;

                    case ScriptType.Client:

                        ret = myReflections.MethodCall(_mClientClassinstance, tcbi.FunctionInvoke, myparams.ToArray(), tcbi.FunctionParams);

                        break;

                    case ScriptType.Server:

                        ret = myReflections.MethodCall(_mServerClassinstance, tcbi.FunctionInvoke, myparams.ToArray(), tcbi.FunctionParams);

                        break;

                    case ScriptType.Core_Server:

                        ret = myReflections.MethodCall(_mCoreServerClassinstance, tcbi.FunctionInvoke, myparams.ToArray(), tcbi.FunctionParams);

                        break;

                    case ScriptType.Core_Main:

                        ret = myReflections.MethodCall(_mCoreMainClassinstance, tcbi.FunctionInvoke, myparams.ToArray(), tcbi.FunctionParams);

                        break;

                    case ScriptType.Core_Client:

                        ret = myReflections.MethodCall(_mCoreClientClassinstance, tcbi.FunctionInvoke, myparams.ToArray(), tcbi.FunctionParams);

                        break;
                    }
                if (Debugging)

                    Error("END Direct Call: Function ID: " + tcbi.TorqueFunctionID + " Tag: " + tcbi + " Params:" + tparams);

                //  returnbuff.Append(ret);
                }

            catch (Exception err)
                {
                }

            int ai = 0;

            foreach (byte c in Encoding.ASCII.GetBytes(ret.ToString()))
                {
                returnbuff[ai] = c;
                ai++;
                }
            returnbuff[ai] = 0;
            }

        /// <summary>
        /// T3D is shutting down and exiting.
        /// </summary>
        public event ShutDownEventHandler onShutDown;

        /// <summary>
        /// Used to signal the host that the engine is shutting down.
        /// </summary>
        internal void OnShutDownEvent()
            {
            if (onShutDown != null)
                onShutDown(null, EventArgs.Empty);
            }
        }
    }


